<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络知识点梳理</title>
    <link href="/2021/08/12/tech/CSBase/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/12/tech/CSBase/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h1><p>七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>五层：物理层、数据链路层、网络层、运输层、应用层。</p><table><thead><tr><th>七层网络体系结构</th><th>任务</th><th>功能</th><th>传输单位</th><th>实现硬件</th><th>协议</th></tr></thead><tbody><tr><td>物理层</td><td>传比特流传比特流</td><td>为数据段设备提供传送数据通路为数据段设备</td><td>比特</td><td>集线器、中继器</td><td></td></tr><tr><td>数据链路层</td><td>将IP报文封装成帧</td><td>链路连接的建立、拆除和分离；帧定界和帧同步；差错检测</td><td>帧</td><td>交换机、网桥</td><td>PPP、STP、ARQ</td></tr><tr><td>网络层</td><td>将传输层的报文封装成分组；选择路由，将报文交付到目的主机。</td><td>为传输层提供服务；组包和拆包；路由选择；拥塞控制</td><td>数据段</td><td>路由器</td><td>ICMP、ARP、IP、IGMP、OSPF</td></tr><tr><td>传输层</td><td>负责主机中两个进程的通信</td><td>为端到端连接提供可靠的服务；为端到端连接提供流量控制、差错控制、服务质量管理等</td><td>报文段（TCP）、用户数据报（UDP）</td><td></td><td>TCP、UDP</td></tr><tr><td>会话层</td><td>不同主机各进程间的对话</td><td>管理主机间的会话进程，端到端服务。</td><td></td><td></td><td></td></tr><tr><td>表示层</td><td>负责处理两个内部数据表示结构不同的通信系统间交换信息的表示格式。</td><td>为数据加密和解密；为提高传输效率提供必需的数据压缩和解压。</td><td></td><td></td><td></td></tr><tr><td>应用层</td><td>提供系统与用户的接口</td><td>文件传输；访问和管理；电子邮件服务</td><td></td><td></td><td>FTP、SMTP、POP3、HTTP、DNS</td></tr></tbody></table><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p><em><strong>DNS的定义</strong></em></p><p>DNS的全称是domain name system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。</p><p>DNS要做的就是将域名解析成IP。</p><p><em><strong>DNS解析域名的过程</strong></em></p><ol><li>在浏览器中输入 <a href="http://www.baidu.com/">www.baidu.com</a> 域名，操作系统会先检查自己本地的hosts文件是否有这个域名的映射关系，如果有，就先调用这个IP地址映射，完成域名解析；</li><li>如果hosts文件中没有，则查询本地DNS解析器缓存，如果有，则完成地址解析；</li><li>如果本地DNS解析器缓存中没有，则去查找本地DNS服务器，如果查到，完成解析。</li><li>如果没有，则本地服务器会向根域名服务器发起查询请求。根域名服务器会告诉本地域名服务器去查询哪个顶级域名服务器；</li><li>本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地域名服务器去查找哪个权限域名服务器；</li><li>本地域名服务器向权限域名服务器发起查询请求，权限域名服务器告诉本地域名服务器<a href="http://www.baidu.com/">www.baidu.com</a> 所对应的IP地址；</li><li>本地域名服务器告诉主机<a href="http://www.baidu.com/">www.baidu.com</a> 所对应的IP地址。</li></ol><blockquote><p>主机向本地域名服务器的查询一般是采用递归查询，而本地域名服务器向根域名的查询一般是采用迭代查询。<br><em><strong>递归查询</strong></em>：主机向本地域名发送查询请求报文，而本地域名服务器不知道该域名对应的IP地址时，本地域名会继续向根域名发送查询请求报文，不是通知主机自己向根域名发送查询请求报文。<br><em><strong>迭代查询</strong></em>：本地域名服务器向根域名发出查询请求报文后，根域名不会继续向顶级域名服务器发送查询请求报文，而是通知本地域名服务器向顶级域名发送查询请求报文。</p></blockquote><p><em><strong>URI和URL的区别</strong></em></p><p><strong>URI(Uniform Resource Identifier)</strong> ：中文全称为统一资源标志符，主要作用是唯一标识一个资源。<br><strong>URL(Uniform Resource Location)</strong> ：中文全称为统一资源定位符，主要作用是提供资源的路径。<br>有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td></tr><tr><td>POST</td><td>传输实体主体</td></tr><tr><td>PUT</td><td>上传文件</td></tr><tr><td>DELETE</td><td>删除文件</td></tr><tr><td>HEAD</td><td>和GET方法类似，但只返回报文首部，不返回报文实体主体部分</td></tr><tr><td>PATCH</td><td>对资源进行部分修改</td></tr><tr><td>OPTIONS</td><td>查询指定的URL支持的方法</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td></tr><tr><td>TRACE</td><td>服务器会将通信路径返回给客户端</td></tr></tbody></table><p><em><strong>GET和POST的差别</strong></em></p><ul><li><p>作用</p><p>GET用于获取资源，POST用于传输实体主体</p></li><li><p>参数位置</p><p>GET的参数放在URL中，POST的参数存储在实体主体中，并且GET方法提交的请求的URL中的数据做多是2048字节，POST请求没有大小限制。</p></li><li><p>安全性</p><p>GET方法因为参数放在URL中，安全性相对于POST较差一些。</p></li><li><p>幂等性</p><p>GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的。</p></li></ul><p><em><strong>POST和PUT的区别</strong></em></p><p>二者都用于请求数据的更新和创建。</p><p>但二者最本质的区别在于POST不是幂等的，而PUT是幂等的。即PUT多次返回结果是一样的，但POST多次会返回不同的对象。POST由服务器来指定地址，而PUT是用户指定的。</p><p>比如一个用户要对一个账号反复修改密码，就要用PUT，而一个用户想要创建多个账号，就要用POST。</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ol><li><p>1XX：信息性状态码，表示接受的请求正在处理</p><p> 100 Continue：表示正常，客户端可以继续发送请求<br> 101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。</p></li><li><p>2XX：成功状态码，表示请求正常处理完毕</p><p> 200 OK：请求成功<br> 201 Created：已创建，表示成功请求并创建了新的资源<br> 202 Accepted：已接受，已接受请求，但未处理完成。<br> 204 No Content：无内容，服务器成功处理，但未返回内容。<br> 205 Reset Content：重置内容，服务器处理成功，客户端应重置文档视图。<br> 206 Partial Content：表示客户端进行了范围请求，响应报文应包含Content-Range指定范围的实体内容</p></li><li><p>3XX：重定向状态码，表示需要进行附加操作以完成请求</p><p> 301 Moved Permanently：永久性重定向<br> 302 Found：临时重定向<br> 303 See Other：和301功能类似，但要求客户端采用get方法获取资源<br> 304 Not Modified：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。<br> 305 Use Proxy：所请求的资源必须通过代理访问<br> 307 Temporary Redirect： 临时重定向，与302类似，要求使用get请求重定向。</p></li><li><p>4XX：客户端错误码，服务器无法处理请求</p><p> 400 Bad Request：客户端请求的语法错误，服务器无法理解。<br> 401 Unauthorized：表示发送的请求需要有认证信息。<br> 403 Forbidden：服务器理解用户的请求，但是拒绝执行该请求<br> 404 Not Found：服务器无法根据客户端的请求找到资源。<br> 405 Method Not Allowed：客户端请求中的方法被禁止<br> 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求<br> 408 Request Time-out：服务器等待客户端发送的请求时间过长，超时</p></li><li><p>5XX：服务器错误码，服务器处理请求出错</p><p> 500 Internal Server Error：服务器内部错误，无法完成请求<br> 501 Not Implemented：服务器不支持请求的功能，无法完成请求</p></li></ol><h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h3><table><thead><tr><th align="center"></th><th align="center">HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td align="center">端口</td><td align="center">80</td><td>443</td></tr><tr><td align="center">安全性</td><td align="center">无加密，安全性较差</td><td>有加密机制，安全性较高</td></tr><tr><td align="center">资源消耗</td><td align="center">较少</td><td>由于加密处理，资源消耗更多</td></tr><tr><td align="center">是否需要证书</td><td align="center">不需要</td><td>需要</td></tr><tr><td align="center">协议</td><td align="center">运行在TCP协议之上</td><td>运行在SSL协议之上，SSL运行在TCP协议之上</td></tr></tbody></table><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><em><strong>加密过程</strong></em></p><p>HTTPS使用混合加密方式，使用非对称加密来传输对称密钥来保证安全性，使用对称加密来保证通信的效率。</p><ol><li>客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。</li><li>服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。</li><li>服务端将证书发给客服端。</li><li>客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。</li><li>客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。</li><li>服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。</li><li>通信双方可用对称密钥来加密解密信息。</li></ol><p><em><strong>各版本区别</strong></em></p><p><strong>HTTP 1.0和HTTP 1.1</strong></p><ol><li><p>长连接</p><p> HTTP 1.1支持长连接和请求的流水线操作。</p><p> 长连接是指不在需要每次请求都重新建立一次连接，HTTP 1.0默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大。</p><p> 请求的流水线操作是指客户端在收到HTTP的响应报文之前可以先发送新的请求报文，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。</p></li><li><p>管道化（假并行传输）</p><p> 当网络请求包含多个文本、图像、视频等资源时，HTTP1.1 支持并行发送。</p><p> 但对处理器而言，必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。</p><p> HTTP管道化可以把先进先出队列从客户端(请求队列)迁移到服务端(响应队列)，但其并没有解决队头阻塞的问题。</p></li><li><p>支持响应请求的某部分资源</p><p>HTTP1.1支持断点续传功能，服务端可以只响应客户端请求对象的一部分。在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分，返回的状态码为206。</p><p>而在HTTP 1.0中会存在浪费带宽的现象，主要是因为不支持断点续传功能，客户端只是需要某个对象的一部分，服务端却将整个对象都传了过来。</p><p>如此可以优化网络带宽。</p></li><li><p>增加缓存处理，支持断点续传</p><p> HTTP1.1还加入了缓存处理(强缓存和协商缓存)，新的字段如cache-control，支持断点传输，以及增加了Host字段(使得一个服务器能够用来创建多个Web站点)</p></li></ol><p><strong>HTTP2.0 新特性</strong></p><ol><li><p>二进制分帧</p><p> HTTP2.0通过在应用层和传输层之间增加一个二进制分层帧，突破了HTTP1.1解析是基于文本的性能限制，改进传输性能。</p></li><li><p>多路复用</p><p> 一条TCP连接可以承载任意流量的双向数据流，数据流会被拆分成帧，乱序发送，然后再根据每个帧头部的流标识符（stream_id）重新封装。</p><p> 现阶段浏览器的优化策略是，同时建立多个TCP的会话，实现真并行。</p><p> 对并行性能的分析：</p><pre><code> 1. 并行连接可能会因为充分利用客户端的带宽从而提高加载速度；  2. 在客户端带宽不充足的情况下，并不会提高加载速度，而且并行连接会产生额外的开销；  3. 浏览器做的渐进式并行加载会让用户感觉加载速度快了。</code></pre></li><li><p>header压缩</p><p> 在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，同时通信双方各自缓存一份header fields表，避免了header的重复传输。</p></li><li><p>服务端推送</p><p> 客户端在请求一个资源时，会把相关资源一起发给客户端，这样客户端就不需要再次发起请求。</p></li></ol><p><em><strong>HTTP3.0 新特性</strong></em></p><p>HTTP3.0是基于google的QUIC协议，而QUIC协议是使用UDP实现的。</p><p>QUIC协议特性：</p><ol><li><p>0-RTT ：传输层和加密层在0-RTT就能建立连接。</p><p> 缓存当前会话的上下文，下次恢复会话的时候，只需要将之前的缓存传递给服务器，验证通过，就可以进行传输了。</p></li><li><p>多路复用</p><p> QUIC基于UDP，一个连接上的多个stream之间没有依赖，即使丢包，只需要重发丢失的包即可，不需要重传整个连接。</p></li><li><p>移动端表现更好</p><p> QUIC在移动端的表现比TCP好，因为TCP是基于IP识别连接，而QUIC是通过ID识别链接。 无论网络环境如何变化，只要ID不便，就能迅速重新连上。</p></li><li><p>报文加密认证 </p><p> QUIC几乎所有报文头部都是经过认证的，报文Body都是经过加密的。</p><p> TCP协议头没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改、注入和窃听。</p></li><li><p>向前纠错机制 </p><p> 每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。</p><p> 向前纠错牺牲了每个数据包可以发送数据的上限，但是优化了数据重传的时间消耗，提升了传输性能。</p></li></ol><p>参考链接：<a href="https://blog.csdn.net/gogzf/article/details/78287166">参考1</a>、<a href="https://network.51cto.com/art/202010/628901.htm">参考2</a>、<a href="https://juejin.cn/post/6844903976354185230#heading-0">参考3</a></p><h2 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h2><p><em><strong>在浏览器中输⼊url地址到显示主⻚的过程</strong></em></p><ol><li>对输入到浏览器的url进行DNS解析，将域名转换为IP地址。</li><li>和目的服务器建立TCP连接</li><li>向目的服务器发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析并渲染页面</li></ol><p><em><strong>cookie 和 session</strong></em></p><p>HTTP协议是无状态的，即服务器无法判断用户身份。Session和Cookie可以用来进行身份辨认。</p><p><strong>Cookie</strong></p><p>Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。</p><p><strong>Session</strong></p><p>Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。</p><p><strong>Token</strong></p><p>客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。</p><table><thead><tr><th align="center"></th><th align="center">存放位置</th><th align="center">占用空间</th><th align="center">安全性</th><th>应用场景</th></tr></thead><tbody><tr><td align="center">Cookie</td><td align="center">客户端浏览器</td><td align="center">小</td><td align="center">较低</td><td>一般存放配置信息</td></tr><tr><td align="center">Session</td><td align="center">服务端</td><td align="center">多</td><td align="center">较高</td><td>存放较为重要的信息</td></tr></tbody></table><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p><img src="/img/2021/TCP%E9%A6%96%E9%83%A8.webp" alt="TCP首部"></p><p><em><strong>TCP都有哪几种状态，分别都代表什么含义？</strong></em></p><ol><li>SYN：同步位，SYN = 1 表示连接请求；</li><li>FIN：终止位，FIN = 1 表示释放连接；</li><li>ACK：确认位，ACK = 1 表示确认号有效；</li><li>RST：复位位，RST = 1 表示TCP连接出现严重错误（主机崩溃等），需要重新建立连接；</li><li>PSH：推送位，PSH = 1 表示接收端要尽快交付任务，不要等到缓存满了再提交；</li><li>URG：紧急位，URG = 1 表示告诉系统该报文段为高优，需要加急传送。</li></ol><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p><em><strong>三次握手</strong></em></p><table><thead><tr><th>握手</th><th>发送端</th><th>标志位</th><th>序号（seq）</th><th>确认号（ack）</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>client</td><td>SYN=1</td><td>x</td><td>-</td><td>CLOSE -&gt; SYN_SENT</td></tr><tr><td>2</td><td>server</td><td>SYN=1 ACK=1</td><td></td><td>x+1</td><td>CLOSE -&gt; SYN_RCVD</td></tr><tr><td>3</td><td>client</td><td>ACK=1</td><td>x+1</td><td>y+1</td><td>SYN_RCVD -&gt; ESTABLISHED</td></tr></tbody></table><p><img src="/img/2021/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.webp" alt="TCP三次握手"></p><p><em><strong>为什么是三次握手，不是两次？</strong></em></p><ol><li>server给client发送的ack丢失了，client认为没有建立连接，但server认为已经建立连接，server发送数据会浪费网络资源；</li><li>server接受到了一个失效的client发送的连接请求，会发送给client一个ack，但client不会发送数据，TCP连接也没有意义。</li></ol><p><em><strong>四次挥手</strong></em></p><table><thead><tr><th>挥手</th><th>发送端</th><th>标志位</th><th>序号（seq）</th><th>确认号（ack）</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>client</td><td>FIN=1</td><td>u</td><td></td><td>ESTABLISHED -&gt; FIN-WAIT-1</td></tr><tr><td>2</td><td>server</td><td>ACK=1</td><td>v</td><td>u+1</td><td>ESTABLISHED -&gt; CLOSE-WAIT <br />FIN-WAIT-1 - &gt; FIN-WAIT-2</td></tr><tr><td>3</td><td>server</td><td>FIN=1 ACK=1</td><td>w</td><td>u+1</td><td>CLOSE-WAIT -&gt; LAST-ACK</td></tr><tr><td>4</td><td>client</td><td>ACK=1</td><td>u+1</td><td>w+1</td><td>FIN-WAIT-2 -&gt; TIME-WAIT</td></tr></tbody></table><p><img src="/img/2021/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.webp" alt="TCP四次挥手"></p><p><em><strong>为什么是四次握手？</strong></em></p><ol><li>c-&gt;s-&gt;c-&gt;s ：TCP是全双工通信，第一次挥手是c不发数据了，第二次挥手是s对c不发数据的确认，第三次挥手是c收到s对c关闭连接的确认。但s还是可以单通道给c发数据的，并没有主动的释放连接。（而s对c的ack和s的FIN不能同时进行，因为如果s不主动FIN，c就会不停的给s发送FIN。）</li><li>c-&gt;s, s-&gt;c, s-&gt;c：s需要一个c对其FIN的确认，否则会超时重传。</li></ol><p><em><strong>为什么TIME-WAIT之后要等2MSL？</strong></em></p><ol><li>可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。</li><li>当第四次挥手数据包丢失，server会超时重传，client要预留出来这部分时间，否则server无法正常关闭。</li></ol><p><em><strong>MSL、TTL及RTT的区别</strong></em></p><p>MSL(Maximum Segment Lifetime) ：报文最大生存时间，超过这个时间，报文就将在网络中被丢弃。在TCP第四次挥手进入TIME_WAIT后，要等待2MSL的时间。</p><p>TTL(time to live)：ip数据报可以经过的最大路由数，由源主机设置初始值时给定。每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。</p><p>RTT(round-trip time)：C/S往返所花时间。由TCP自适应算法计算动态给出，随着网络拥塞状态的变化而变化。</p><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>TCP是如何保证可靠传输的？</p><p>主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。</p><p><em><strong>校验和</strong></em></p><p>具体步骤：</p><p>发送方将校验和报文段置0，加上12位的伪首部（伪首部 + 首部 + 数据），将拼接后的报文视为若干个16位的数据，按二进制反码计算这些16位数据的和，然后将结果的反码写到校验和报文段里。接收方拿到报文段，加上伪首部，做同样的操作，如果得到的为全1，则说明无差错。</p><blockquote><p>IP、UDP、TCP校验和计算方式相似，都是二进制反码运算求和再取反。区别在于IP只校验IP报文的首部，UDP和TCP校验首部和数据部分。</p></blockquote><p><em><strong>序列号</strong></em></p><p>TCP会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答(ACK报文)，并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。</p><p><em><strong>重传</strong></em></p><p>超时重传 ：RTT超过RTO要进行重传。</p><blockquote><p>RTT（Round-Trip Time） ：TCP发送报文和收到确认的时间差。<br>RTO（Retransmission Time-Out） ：超时计时器设置的超时时间。</p></blockquote><p>冗余确认 ：利用序列号对缺失报文段进行计数，缩短超时周期，提高重传效率。</p><p><em><strong>停止等待协议</strong></em></p><p>每发完一个分组就停止发送，等待对方确认，在收到确认后再发下一个分组。</p><p>TCP默认使用累计确认，只确认第一个丢失包的序号位置。</p><blockquote><p>确认号(ack)：期望收到对方下一个报文段的数据的第一个字节的序号。</p></blockquote><p><em><strong>流量控制</strong></em></p><p>流量控制是匹配发送方的发送速率与接收方的读取速率。</p><p>TCP提供的是一种基于滑动窗口的控制机制。</p><p>接收方根据自己接收缓存的大小，动态调整接收窗口的大小通知发送方（通过调整TCP首部的“窗口”字段）；发送方根据当前网络拥塞程度确定拥塞窗口，取接受窗口和拥塞窗口的最小值作为发送窗口大小。</p><p><code>接收窗口 = 接收端缓存大小</code></p><p><code>发送窗口 = min&#123;接收窗口, 拥塞窗口&#125;</code></p><p>拥塞窗口：由发送方根据网络拥塞状态决定。</p><p><em><strong>拥塞控制</strong></em></p><p>拥塞控制的过程由四部分：慢开始、拥塞避免、快重传、快恢复。</p><p>慢开始：拥塞窗口初始值为1，然后指数增长，直到慢开始设定的门限。</p><p>拥塞避免：拥塞窗口达到慢开始门限后开始线性增长，直到网络阻塞，调整慢开始门限为网络拥塞时窗口的一半，重新从再慢开始。</p><p>快重传：当冗余确认超过预设值的时候，直接认为网络拥塞，相对拥塞避免，这是另一种认为网络拥塞的判决条件。</p><p>快恢复：快重传之后，将此时的发送窗口调整为拥塞窗口的一半，进行线性增长的发送数据。</p><blockquote><p>流量控制和拥塞控制的区别：流量控制是点对点的，是发生在TCP连接的两个socket之间，而拥塞控制是发生在全局网络的，在主机和路由器之间。</p></blockquote><p><img src="/img/2021/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B.webp" alt="拥塞控制过程"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><img src="/img/2021/UDP%E9%A6%96%E9%83%A8.webp" alt="UDP首部"></p><table><thead><tr><th align="center"></th><th align="center">是否面向连接</th><th align="center">可靠性</th><th align="center">传输形式</th><th align="center">传输效率</th><th align="center">消耗资源</th><th align="center">应用场景</th><th align="center">首部字节</th></tr></thead><tbody><tr><td align="center">TCP</td><td align="center">面向连接</td><td align="center">可靠</td><td align="center">字节流</td><td align="center">慢</td><td align="center">多</td><td align="center">文件/邮件传输</td><td align="center">20~60</td></tr><tr><td align="center">UDP</td><td align="center">无连接</td><td align="center">不可靠</td><td align="center">数据报文段</td><td align="center">快</td><td align="center">少</td><td align="center">视频/语音传输</td><td align="center">8</td></tr></tbody></table><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP报文"><a href="#IP报文" class="headerlink" title="IP报文"></a>IP报文</h2><p><a href="/img/2021/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.png">IP数据包格式</a></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP协议的主要作用是实现从IP地址转换为MAC地址。</p><p><em><strong>ARP的工作流程</strong></em></p><ol><li>在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。</li><li>如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。</li><li>主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会向主机A以单播的方式发送一个带有自己MAC地址的响应分组。</li><li>主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。</li><li>如果主机A和主机B不在同一个局域网内，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。（主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中存的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。）</li></ol><p><em><strong>IP地址 &amp; MAC地址</strong></em></p><p>网络层实现的是主机之间的通信，而链路层实现的是链路之间的通信，所以从下图可以看出，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变。</p><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p>ICMP（Intent Control Message Protocol）互联网控制报文协议：用于TCP/IP网络中发送控制消息，提供IP包废弃的各种问题反馈。</p><p>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。</p><p><img src="/img/2021/ICMP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.jpg" alt="ICMP报文结构"></p><p>ICMP有两种报文格式：查询报文、差错报文。</p><p><em><strong>查询报文</strong></em></p><p>发送端主动发起请求，并且获取到应答。</p><p>典型的应用就是PING。</p><p>ping是ICMP(网际控制报文协议)中的一个重要应用，ICMP是网络层的协议。ping的作用是测试两个主机的连通性。</p><p>ping的工作过程：</p><ol><li>向目的主机发送多个ICMP回送请求报文</li><li>根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。</li></ol><p>ping执行后都发生了什么？</p><ol><li>ping 命令执行的时候，源主机首先会构建一个 ICMP 回送请求消息数据包。</li><li>ICMP 数据包内包含多个字段，最重要的是两个：第一个是类型，对于回送请求消息而言该字段为 8；另外一个是序号，主要用于区分连续 ping 的时候发出的多个数据包，每发出一个请求数据包，序号会自动加 1。</li><li>ICMP报文段作为IP报文的一部分，加上源ip地址和目的ip地址，拼接成ip数据包；</li><li>ip数据包通过ARP协议添加MAC头部，并转发到目的主机（中间可能涉及路由跳转）；</li><li>目的主机按MAC地址、IP数据包逐层解析；</li><li>响应阶段，目的主机会构建一个 ICMP 回送响应消息数据包，回送响应数据包的类型字段为 0，序号为接收到的请求数据包中的序号，然后再发送出去给源主机。</li></ol><p><em><strong>差错报文</strong></em></p><ol><li><p>终点不可达</p><p> A、网络不可达 — 代码为 0，<br> B、主机不可达 — 代码为 1.<br> C、协议不可达 — 代码为 2.<br> D、端口不可达 — 代码为 3.<br> E、需要分段 - 代码为 4.（ 必须把数据分段才能去到终点</p></li><li><p>源站抑制</p><p> 发送端发送大量数据时，可能会导致网络( 路由器 )过载，此时过载处可以向发送端发送源抑制的消息，让他降低发送速度。</p></li><li><p>时间超时</p><p> 网络包超过设置的在网络中的生存时间，还没有达到。</p></li><li><p>路由重定向</p><p> 定义数据包的路由规则。因为大部分的时候，路由规则是通过相关协议算法生成的，有些时候重新定义过之后，会让这个数据包绕的更远。</p></li></ol><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>DHCP(Dynamic Host Configuration Protocol) 动态主机配置协议，用于给主机动态分配ip地址。</p><p>DHCP是应用层协议，基于UDP。</p><h2 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h2><p>NAT（Network Address Translation）网络地址转换，是内网和外网ip转换的协议。它的作用在于：1、整个内网只需要一个全球IP就可以全球互连，而内网IP是可重用的，因此可以节省IP资源的消耗；2、内网只用于LAN，不用于WAN，可以隐藏内部网络结构，提高网络安全性。</p><p>NAT协议通过NAT路由器实现的，NAT要通过NAT转换表，实现源ip地址或目的ip地址的转换。NAT转换表存放着{本地IP地址 : 端口}到{全球IP地址 : 端口}的映射。</p><p>内网ip网段：</p><ol><li>A类：10.0.0.0～10.255.255.255</li><li>B类：172.16.0.0～172.31.255.255</li><li>C类：192.168.0.0～192.168.255.255</li></ol><h2 id="CIDR协议"><a href="#CIDR协议" class="headerlink" title="CIDR协议"></a>CIDR协议</h2><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://juejin.cn/post/6844903662838349838">https://juejin.cn/post/6844903662838349838</a></li><li><a href="https://www.cnblogs.com/xiaolincoding/p/12571184.html">https://www.cnblogs.com/xiaolincoding/p/12571184.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-IO</title>
    <link href="/2021/08/12/tech/JavaCE/Java-IO/"/>
    <url>/2021/08/12/tech/JavaCE/Java-IO/</url>
    
    <content type="html"><![CDATA[<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><em><strong>序列化</strong></em>是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。</p><p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口。</p><p>把一个Java对象变为byte[]数组，需要使用<code>ObjectOutputStream</code>，从一个字节流读取Java对象用<code>ObjectInputStream</code>。</p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 泛型</title>
    <link href="/2021/08/12/tech/JavaCE/Java-%E6%B3%9B%E5%9E%8B/"/>
    <url>/2021/08/12/tech/JavaCE/Java-%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h2><p>泛型是jdk5引入的新特性，本质是参数化类型，提供了类型安全检测机制，实现了一次编写模板，多次复用。</p><p>以List为例，List的底层实现是Object[]，传不同的数据类型，要进行强制转换，这会导致容易产生类型转换错误等。如果对不同类型都编写一套模板显然太复杂，这时候泛型就可以解决以上问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T e)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>❗️❗️泛型<T>不是一种基本类型，不能通过<code>getClass()</code>方法获取Class类型。</p><h2 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h2><p>以String类为例，只需要将<code>String</code>处换成<code>T</code>就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String first;<br>    <span class="hljs-keyword">private</span> String last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(String first, String last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 静态方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T last;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span><span class="hljs-params">(T first, T last)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.first = first;<br>        <span class="hljs-keyword">this</span>.last = last;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><br>    <span class="hljs-comment">// 可以编译通过:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K&gt; <span class="hljs-function">Pair&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(K first, K last)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pair&lt;K&gt;(first, last);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型的Java实现（擦拭法）"><a href="#泛型的Java实现（擦拭法）" class="headerlink" title="泛型的Java实现（擦拭法）"></a>泛型的Java实现（擦拭法）</h2><p>Java语言的泛型实现方式是<strong>擦拭法（Type Erasure）</strong>。</p><blockquote><p>擦拭法是指，JVM完全屏蔽泛型，所有的类型转换工作都是编译器做的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// coding</span><br>Pair&lt;String&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>String first = p.getFirst();<br>String last = p.getLast();<br><br><span class="hljs-comment">// jvm</span><br>Pair p = <span class="hljs-keyword">new</span> Pair(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>String first = (String) p.getFirst();<br>String last = (String) p.getLast();<br></code></pre></td></tr></table></figure><p>擦拭法决定了泛型<T>：</p><ol><li>不能是基本类型，例如：int；</li><li>不能获取带泛型类型的Class，例如：Pair<String>.class；</li><li>不能判断带泛型类型的类型，例如：x instanceof Pair<String>；</li><li>不能实例化T类型，例如：new T()。</li></ol><h2 id="extends-amp-super通配符"><a href="#extends-amp-super通配符" class="headerlink" title="extends &amp; super通配符"></a>extends &amp; super通配符</h2><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>❗️❗️向上转型是谁转？是外层的类型转，而不是&lt;&gt;里的类型转！</p><p>对于<code>ArrayList&lt;String&gt;</code>来说，向上转型的结果就是<code>List&lt;String&gt;</code>。</p><p>但是对于<code>ArrayList&lt;Integer&gt;</code>，<code>ArrayList&lt;Number&gt;</code>并不是其向上转型的结果！</p><p>如果想对<code>&lt;&gt;</code>里面的内容进行向上或向下类型转换，要怎么做？ 向上转-&gt;extends，向下转-&gt;super</p><h3 id="extends-上界通配符"><a href="#extends-上界通配符" class="headerlink" title="extends 上界通配符"></a>extends 上界通配符</h3><? extends Number>通配符的一个重要限制：方法参数签名setFirst(? extends Number)无法传递任何Number的子类型给setFirst(? extends Number)使用<? extends Number>通配符表示：1. 使用extends通配符表示可以读，不能写；2. 使用类似< T extends Number>定义泛型类时表示：泛型类型限定为Number以及Number的子类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// extends的作用是限制set，只get</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumOfList</span><span class="hljs-params">(List&lt;? extends Integer&gt; list)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>        Integer n = list.get(i);<br>        sum = sum + n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>### super 下界通配符使用<? super Integer>通配符表示：1. 允许调用set(? super Integer)方法传入Integer的引用；2. 不允许调用get()方法获得Integer的引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            T t = src.get(i);<br>            dest.add(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>`Collections.copy`的作用是把一个List的每个元素依次添加到另一个List中。它的第一个参数是`List<? super T>`，表示目标List，第二个参数`List<? extends T>`，表示要复制的List。我们可以简单地用for循环实现复制。在for循环中，我们可以看到，对于类型`<? extends T>`的变量src，我们可以安全地获取类型T的引用，而对于类型`<? super T>`的变量dest，我们可以安全地传入T的引用。这个`copy()`方法的定义就完美地展示了extends和super的意图：`copy()`方法内部不会读取dest，因为不能调用`dest.get()`来获取T的引用；`copy()`方法内部也不会修改src，因为不能调用`src.add(T)`。### ? 无边界通配符 <?><p>通配符既没有extends，也没有super，因此：</p><ol><li>不允许调用set(T)方法并传入引用（null除外）；</li><li>不允许调用T get()方法并获取T引用（只能获取Object引用）。</li></ol><p>无限定通配符&lt;?&gt;很少使用，可以用<T>替换，同时它是所有<T>类型的超类。</p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Javax新特性</title>
    <link href="/2021/08/11/tech/JavaCE/Javax%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2021/08/11/tech/JavaCE/Javax%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><em><strong>函数式编程</strong></em></p><p>Java8之前用的都是静态方法或实例方法，Java8新增了函数方法，即把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。</p><p>lambda表达式是函数式编程，lambda表达式的类型必须是函数式接口，被<code>@FunctionalInterface</code>注解修饰。<a href="https://blog.csdn.net/weixin_29131533/article/details/113082119">参考地址</a></p><blockquote><p>函数式编程是将函数(一段操作)作为一个基本单位进行传递。以前的Java中参数只能是具体的变量，函数式编程打破这一规范，可以将整个方法作为一个参数传递。</p></blockquote><p><em><strong>lambda表达式语法</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; &#123;&#125;()；(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;；<span class="hljs-comment">//小括号里无参数则留空()，有一个参数括号可以省略，多个参数用逗号隔开</span><br></code></pre></td></tr></table></figure><p><em><strong>FunctionalInterface（函数式接口）</strong></em></p><p>有且仅有一个抽象方法的接口。比如：<code>Comparator</code>、<code>Callable</code>、<code>Runnable</code> 等。</p><blockquote><p>虽然Comparator接口有很多方法，但只有一个抽象方法int compare(T o1, T o2)，其他的方法都是default方法或static方法。另外注意到boolean equals(Object obj)是Object定义的方法，不算在接口方法内。因此，Comparator也是一个FunctionalInterface。</p></blockquote><p><em><strong>方法引用</strong></em></p><p>方法引用：使用操作符 “ ::” 将方法名和对象或类的名字分隔开来。主要有：对象::实例方法 类::静态方法 类::构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String[] array = <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Lemon&quot;</span> &#125;;<br>        Arrays.sort(array, Main::cmp); <span class="hljs-comment">// 类::静态方法</span><br>        System.out.println(String.join(<span class="hljs-string">&quot;, &quot;</span>, array));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s1.compareTo(s2);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; names = List.of(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Tim&quot;</span>);<br>        List&lt;Person&gt; persons = names.stream().map(Person::<span class="hljs-keyword">new</span>).collect(Collectors.toList()); <span class="hljs-comment">// 类::构造方法</span><br>        System.out.println(persons);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person:&quot;</span> + <span class="hljs-keyword">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数；</li><li>lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获；</li><li>lambda表达式只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.</span><br>list.forEach((String s) -&gt; System.out.println(<span class="hljs-string">&quot;*&quot;</span> + s + <span class="hljs-string">&quot;*&quot;</span>));<br><span class="hljs-comment">// 3.</span><br>List&lt;Integer&gt; primes = Arrays.asList(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;);<br><span class="hljs-keyword">int</span> factor = <span class="hljs-number">2</span>;<br>primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;); <span class="hljs-comment">// run</span><br>primes.forEach(element -&gt; &#123; factor++; &#125;); <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><h2 id="Steam"><a href="#Steam" class="headerlink" title="Steam"></a>Steam</h2><h3 id="Steam-的特点"><a href="#Steam-的特点" class="headerlink" title="Steam 的特点"></a>Steam 的特点</h3><table><thead><tr><th align="left"></th><th align="left">java.io</th><th>java.util.stream</th></tr></thead><tbody><tr><td align="left">存储</td><td align="left">顺序读写的<code>byte</code>或<code>char</code></td><td>顺序输出的任意Java对象实例</td></tr><tr><td align="left">用途</td><td align="left">序列化至文件或网络</td><td>内存计算／业务逻辑</td></tr></tbody></table><table><thead><tr><th align="left"></th><th align="left">java.util.List</th><th>java.util.stream</th></tr></thead><tbody><tr><td align="left">元素</td><td align="left">已分配并存储在内存</td><td>可能未分配，实时计算</td></tr><tr><td align="left">用途</td><td align="left">操作一组已存在的Java对象</td><td>惰性计算</td></tr></tbody></table><blockquote><p> 惰性计算：一个<code>Stream</code>转换为另一个<code>Stream</code>时，实际上只存储了转换规则，并没有任何计算发生。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> result = createNaturalStream() <span class="hljs-comment">// 创建Stream</span><br>             .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">// 任意个转换</span><br>             .map(n -&gt; n * n) <span class="hljs-comment">// 任意个转换</span><br>             .limit(<span class="hljs-number">100</span>) <span class="hljs-comment">// 任意个转换</span><br>             .sum(); <span class="hljs-comment">// 最终计算结果</span><br></code></pre></td></tr></table></figure><h3 id="Steam-的创建"><a href="#Steam-的创建" class="headerlink" title="Steam 的创建"></a>Steam 的创建</h3><p><em><strong>Stream.of()</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br>        <span class="hljs-comment">// forEach()方法相当于内部循环调用，</span><br>        <span class="hljs-comment">// 可传入符合Consumer接口的void accept(T t)的方法引用：</span><br>        stream.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>基于数组或Collection</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;String&gt; stream1 = Arrays.stream(<span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span> &#125;);<br>        Stream&lt;String&gt; stream2 = List.of(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>).stream();<br>        stream1.forEach(System.out::println);<br>        stream2.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>基于Supplier</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Integer&gt; natual = Stream.generate(<span class="hljs-keyword">new</span> NatualSupplier());<br>        <span class="hljs-comment">// 注意：无限序列必须先变成有限序列再打印:</span><br>        natual.limit(<span class="hljs-number">20</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NatualSupplier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        n++;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><blockquote><p>Map就是把一个Stream转换为另一个Stream。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; s = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);<br></code></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><blockquote><p>reduce是一个聚合方法，它可以把一个Stream的所有元素按照聚合函数聚合成一个结果，即一个 Java对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// acc 是上一层计算的结果，0是acc的初始化值</span><br>        <span class="hljs-keyword">int</span> sum = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>).reduce(<span class="hljs-number">0</span>, (acc, n) -&gt; acc + n);<br>        System.out.println(sum); <span class="hljs-comment">// 45</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><blockquote><p>所谓filter()操作，就是对一个Stream的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的Stream。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)<br>                .filter(n -&gt; n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>                .forEach(System.out::println); <span class="hljs-comment">// 1 3 5 7 9</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出集合"><a href="#输出集合" class="headerlink" title="输出集合"></a>输出集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输出为List</span><br>Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br>List&lt;String&gt; list = stream.filter(s -&gt; s != <span class="hljs-keyword">null</span> &amp;&amp; !s.isBlank()).collect(Collectors.toList());<br>System.out.println(list);<br><br><span class="hljs-comment">// 输出为Map</span><br>Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;APPL:Apple&quot;</span>, <span class="hljs-string">&quot;MSFT:Microsoft&quot;</span>);<br>Map&lt;String, String&gt; map = stream<br>        .collect(Collectors.toMap(<br>                <span class="hljs-comment">// 把元素s映射为key:</span><br>                s -&gt; s.substring(<span class="hljs-number">0</span>, s.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>)),<br>                <span class="hljs-comment">// 把元素s映射为value:</span><br>                s -&gt; s.substring(s.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>) + <span class="hljs-number">1</span>)));<br>System.out.println(map);<br><br><span class="hljs-comment">// 输出为数组</span><br>List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br>String[] array = list.stream().toArray(String[]::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>秋招面试问题整理</title>
    <link href="/2021/08/10/work/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2021/08/10/work/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="华为数通提前批"><a href="#华为数通提前批" class="headerlink" title="华为数通提前批"></a>华为数通提前批</h1><h2 id="一面（2021-08-09-15-00-16-30）"><a href="#一面（2021-08-09-15-00-16-30）" class="headerlink" title="一面（2021-08-09 15:00 - 16:30）"></a>一面（2021-08-09 15:00 - 16:30）</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>面向对象有哪些特性？分别在java里是如何体现的，举例说明？</li><li>你在开发过程中用的Java的哪个版本？Java8有哪些新特性？在实践中你是如何运用的？</li><li>Map容器，输入c:1,a:2,b:3，按输入顺序输出，用什么类型的Map？（LinkedHashMap）</li><li>HashMap是线程安全的吗？Java是如何保证线程安全的？synchronized的工作原理？（AQS的工作原理没问）</li><li>HashMap的key是唯一的吗？Java如何比较两个key是否唯一？</li><li>以排序为例，如何用泛型重写？</li><li>定义一个泛型的步骤是怎样的？</li><li>为什么要用泛型？</li><li>用过反射吗？怎么用的？</li><li>Spring 是怎么实现AOP的？</li></ol><h3 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h3><ol><li>前后端分离的项目中，前后端都分别是部署在哪的？</li><li>前端（Vue框架）是如何给后端发送数据的？</li><li>后端部署远程服务的时候，用的jar包还是source code？maven对这两种方式是如何部署的？</li></ol><h3 id="手撕代码"><a href="#手撕代码" class="headerlink" title="手撕代码"></a>手撕代码</h3><p> <em><strong>题目</strong></em></p><p> 两个岛屿间的最短路径</p><p> 是lc中的岛屿数量问题的变形，该题中限制一个二维矩阵中有且只有两个岛屿，试返回两个岛屿之间的最短路径？</p><p> <em><strong>面试记录</strong></em></p><p> 考虑到返回的最小值的两个岛可能来自同一片岛屿，所以一上来要对每个岛所属的岛屿类型进行明确；</p><p> step1. 对二维矩阵进行遍历，用dfs算法为同一个岛屿上的岛进行类型标记；</p><p> step2. 再对二维矩阵进行遍历，如果当前格子是一个岛，分别对其上下左右进行dfs，如果旁边的格子也是岛，说明它们来自同一片岛，不进入dfs，如果不是岛，则进入dfs；</p><p> step3. dfs函数中，先对i, j做边界校验；然后对当前各自做校验，如果当前格子是一个岛，判断岛的类型，并与最初的岛的类型做比较，不同的话，更新最小值。如果当前格子不是一个岛，再对它的上下左右进行dfs。</p><h3 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h3><p> 一面总体感觉，面试官更侧重对Java基础和工程经验的考察。然后第一部分准备的不够充分，第二部分是目前的短板，需要后续准备中分别补齐。</p><p> 问的内容比较全面，但在深度上不是很深，只要对相关知识点，做下准备，能把问的问题接住就行，不需要过多的展开。</p><h2 id="二面（2021-08-09-16-30-18-00）"><a href="#二面（2021-08-09-16-30-18-00）" class="headerlink" title="二面（2021-08-09 16:30 - 18:00）"></a>二面（2021-08-09 16:30 - 18:00）</h2><h3 id="实习项目"><a href="#实习项目" class="headerlink" title="实习项目"></a>实习项目</h3><ol><li>数据封装的时候，可选字段是如何处理的？有没有校验机制？</li><li>用过哪几种线程池，在实际开发中，什么场景下使用的？</li><li>数据库中一张表很大的时候，是如何处理的？</li></ol><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>Spring 的IoC 和 AOP？</li><li>Spring容器初始化时是如何装载Bean的？Application Contest|Bean Factory（Bean的生命周期）?</li><li>JVM Java堆的内存是如何划分的？（新生代 老年代）</li><li>JVM 新生代和老年代的比例一般是多少？</li><li>JVM 调优经验？</li></ol><h3 id="手撕代码-1"><a href="#手撕代码-1" class="headerlink" title="手撕代码"></a>手撕代码</h3><p> <em><strong>题目</strong></em></p><p> <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p><p> <em><strong>面试记录</strong></em></p><p> 这道题之前做过，思路上还是很快就知道解法的。但是好久没刷了，在实现的时候遇到了巨大的阻碍。好在面试官给了积极的提示，但是在最初给出提示之后，后来在我实现卡住的时候，也没有继续提示。</p><p> 当时心态很爆炸，想直接放弃的。但一想从面试官给提示的感觉来看，他还是希望我能做出来的，如果放弃了，很可能因为这一点把我pass掉。</p><p> 这个时候我静下心重新捋了下过程，根据dfs的入参，和递归调用的特性，把整个代码写出来了。</p><h3 id="反思总结-1"><a href="#反思总结-1" class="headerlink" title="反思总结"></a>反思总结</h3><p> 手撕代码环节面试官给出了一个非常宝贵的建议：一定要养成面向接口编程的好习惯。一个问题拿来，先对问题进行步骤拆解，具体实现的时候，一定要分清代码层次。</p><p> 以该题为例，写dfs()的时候，在传参确定前序中序数组的左右边界的时候花费了很长时间，并且写的代码耦合度高，如果后期维护排查出问题，不利于修改。因此一个好的做法是，再新建一个工具函数专门用来解决左右边界的确定，这样如果因为左右边界出错，只需要修改工具函数即可。</p><p> 通过这道题和面试官的交流，我认为考察角度有：1. 根据提示，是否有能力把问题独立解决出来，而不是因为这道题之前做过，现在忘了，就不能当作一个新的问题解决；2. 编程习惯考察，代码耦合程度是否较低，写出来的代码是否利于后期维护和排查问题；3. 对于面向接口编程，结构化编程的理解和应用。</p><h2 id="三面（2021-08-10-16-00-16-45）"><a href="#三面（2021-08-10-16-00-16-45）" class="headerlink" title="三面（2021-08-10 16:00 - 16:45）"></a>三面（2021-08-10 16:00 - 16:45）</h2><p><em><strong>主管综面</strong></em></p><ol><li>实习期间认为有哪些成长？</li><li>你经历的最大的问题和挑战是什么？</li><li>从内心上是如何感受和看待这些困难的？</li><li>工作岗位分布在北京、南京、武汉、东莞，你的意向是什么？</li></ol><p><em><strong>反问环节</strong></em></p><ol><li>团队主要的工作职责？（做供应链产品开发）</li><li>团队的组织架构大致是怎样的，一个小组多少人？</li><li>上下班双休加班情况（周三鼓励健身、周五鼓励早下班，其他工作日弹性制（区间一小时），满足8小时就可，上班时间看城市，晚上九点有班车）</li><li>有哪些定期的学习分享（mentor制，半年试用期，有一个答辩。平时会有技术栈专题的技术分享交流，团队有专门的架构师，负责产品升级迭代）</li><li>半年试用期答辩的后果和影响？（淘汰制，5% - 10%，主要淘汰不适应华为工作环境的人）</li><li>升职加薪周期（基本两年升一级，优秀的一年一级，非常优秀的一年两级）</li><li>户口问题（看北京给的指标，每年也都不一样，需要进一步和hr沟通；工作以后排队拿户口，但过程比较复杂）</li></ol>]]></content>
    
    
    <categories>
      
      <category>工作沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring IoC &amp; AOP</title>
    <link href="/2021/08/09/tech/JavaSE/Spring-IoC-AOP/"/>
    <url>/2021/08/09/tech/JavaSE/Spring-IoC-AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><h2 id="IoC-amp-DI"><a href="#IoC-amp-DI" class="headerlink" title="IoC &amp; DI"></a>IoC &amp; DI</h2><p>IoC：控制反转（Inversion of Control）容器，是一种设计思想。它意味着将对象交给容器控制，而不是开发者在对象内部控制。</p><blockquote><p>谁控制谁？IoC容器来控制对象。<br>控制什么？控制了外部资源获取（不只是对象包括比如文件等）<br>为什么是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转。<br>什么被反转了？依赖对象的获取被反转了。</p></blockquote><p>DI：依赖注入（Dependency Injection），组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。</p><p>IoC和DI其实是同一个概念的不同角度描述。</p><p><img src="/img/2021/%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8EIoC%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94.png" alt="传统获取对象的方式与IoC方式对比"></p><h2 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h2><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>项目梳理-论坛社区 &amp; 商城秒杀</title>
    <link href="/2021/08/09/proj/%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86-%E8%AE%BA%E5%9D%9B%E7%A4%BE%E5%8C%BA%20&amp;%20%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80/"/>
    <url>/2021/08/09/proj/%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86-%E8%AE%BA%E5%9D%9B%E7%A4%BE%E5%8C%BA%20&amp;%20%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="论坛社区"><a href="#论坛社区" class="headerlink" title="论坛社区"></a>论坛社区</h1><h1 id="商城秒杀"><a href="#商城秒杀" class="headerlink" title="商城秒杀"></a>商城秒杀</h1><h2 id="需求点梳理"><a href="#需求点梳理" class="headerlink" title="需求点梳理"></a>需求点梳理</h2><h3 id="项目简介-amp-重点模块梳理"><a href="#项目简介-amp-重点模块梳理" class="headerlink" title="项目简介 &amp; 重点模块梳理"></a>项目简介 &amp; 重点模块梳理</h3><p>该项目是一个高并发场景下的商品秒杀活动。</p><p>除了一些边缘模块外，项目核心内容有两个：分别是下单秒杀前的削峰限流，和下单后保证用事务异步更新销量和扣减库存。</p><p><em><strong>削峰限流</strong></em></p><p>削峰限流主要是在用户下单前通过验证、限流等策略大都缓冲、平滑流量的目的。具体实现流程和用到的技术为：</p><ol><li>通过增加验证码来平滑访问流量；</li><li>通过限制大闸，颁发令牌进行削峰（考虑到商品库存100，而秒杀用户量为10w的场景，只需颁发1000个令牌即可）；</li><li>通过引入限流器（采用令牌桶算法），限制单机TPS，防止服务器挂掉；</li><li>通过引入线程池进行缓冲，再由线程池管理线程进行生产者发送消息。</li></ol><p><img src="/img/2021/%E5%89%8A%E5%B3%B0%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88.png" alt="削峰限流方案"></p><p><em><strong>更新销量</strong></em></p><p>由于更新销量不影响用户秒杀操作，所以可以放到MQ里异步更新。否则直接操作数据库要加锁，影响性能。</p><p><em><strong>扣减库存</strong></em></p><p>由于秒杀是在高并发场景下进行的，在较短时间间隔有大量用户对同一商品资源进行互斥访问，数据库加锁的方式吞吐量太低，因此考虑先用Redis缓存库存，再最终将库存信息通过MQ异步写入数据库中。</p><h3 id="超卖-amp-少卖"><a href="#超卖-amp-少卖" class="headerlink" title="超卖 &amp; 少卖"></a>超卖 &amp; 少卖</h3><p><em><strong>超卖</strong></em>：超卖是说用户下单量超过商品的库存量。在真实场景中，对用户下单并未完全达成同步，导致少扣库存了，这将导致用户体验不佳，在实际中很少采用。</p><p><em><strong>少卖</strong></em>：少卖是说最终用户的付款量少于商品的库存。在实际中，用户可能下单后又退款了，这对收益不会有很严重的影响，但是不会有超卖的用户体验不佳的问题，在实际中大多采用少卖。</p><p>少卖的解决方案：</p><ol><li><p>一个想到的解决方案是利用RocketMq的延时消费机制，为队列设置一个延时时间，用户下单的时候进入队列，在规定付款时间之后进行消费，消费时，可以通过检查订单状态（已付款和未付款自动取消订单）来确定是否进行消费。</p></li><li><p>如果用redis来解决的话，将提交的订单按创建时间写入到一个队列里，然后设定时间间隔轮询队头对时间做差，如果超过付款时间出队，检查订单付款状态，如果没付款，自动回补库存，如果付款，将消息封装到MQ进行消费。</p></li></ol><h3 id="问题点梳理"><a href="#问题点梳理" class="headerlink" title="问题点梳理"></a>问题点梳理</h3><p><em><strong>Mq第二阶段check的时候为什么要存流水，查订单不行吗？</strong></em></p><p>订单在本地事物生成的时候可能会有延时，当订单生成成功时，可能还没来得及写到数据库里，这时check的时候并不能说明本地事务是失败的。</p><p>用流水check的好处在于，在生产者发送消息之前先产生了一个流水存在数据库里，这样check的时候肯定能查到这条数据，同时，本地事务包含了流水的更新，通过查状态值可以判断本地事务是否已经提交。</p><h2 id="技术点梳理"><a href="#技术点梳理" class="headerlink" title="技术点梳理"></a>技术点梳理</h2><p>RocketMQ两阶段提交的过程概述</p><p>1.事务消息发送及提交：</p><ul><li>发送消息（half消息）。</li><li>服务端响应消息写入结果。</li><li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</li><li>根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</li></ul><p>2.补偿流程：</p><ul><li>对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</li><li>Producer收到回查消息，检查回查消息对应的本地事务的状态</li><li>根据本地事务状态，重新Commit或者Rollback</li></ul><p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p><p><img src="/img/2021/ROCKETMQ%E4%BA%8B%E5%8A%A1%E5%9E%8B%E6%B6%88%E6%81%AF.png" alt="ROCKETMQ事务型消息"></p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM梳理</title>
    <link href="/2021/08/07/tech/JavaCE/JVM%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/07/tech/JavaCE/JVM%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM包含四个部分：Class loader(类装载)、Execution engine(执行引擎)；Runtime data area(运行时数据区)、Native Interface(本地接口)。</p><ul><li>Class loader(类装载)：装载class文件到method area。</li><li>Execution engine（执行引擎）：将字节码命令解释给操作系统。</li><li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li><li>Runtime data area(运行时数据区域)：JVM的内存，存数据。</li></ul><p><em><strong>JVM执行过程</strong></em></p><ol><li>编译器把Java代码转成字节码，类加载器把字节码加载到内存（**<u>运行时数据区</u>**的方法区）中；</li><li>通过解析器**<u>执行引擎</u>**，将字节码翻译成OS底层指令，交由CPU执行；</li><li>整个过程中需要调用其他语言的**<u>本地库接口</u>**来实现程序功能。</li></ol><p><img src="/img/2021/jvm%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="jvm结构图"></p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>类的生命周期：加载、连接（验证、准备、解析）初始化。</p><p>###加载</p><p>加载过程加载的是.class 文件。</p><p><em><strong>加载过程</strong></em></p><ol><li>通过一个类的全限定名来获取其定义的二进制字节流；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ol><p><em><strong>加载方式</strong></em></p><ol><li>隐式加载：通过写程序new一个对象</li><li>显示加载：通过反射，class.forname()方法等</li></ol><p><img src="/img/2021/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p><p>这一步用<strong>类加载器</strong>来实现。</p><p><em><strong>连接</strong></em></p><ul><li><em><strong>验证</strong></em>：检查加载的 class 文件的正确性；</li><li><em><strong>准备</strong></em>：给类中的静态变量分配内存空间；</li><li><em><strong>解析</strong></em>：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li></ul><p><em><strong>初始化</strong></em></p><p>对静态变量和静态代码块执行初始化工作。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。</p><ol><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ol><p><img src="/img/2021/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="类加载器的层次"></p><h3 id="类加载机制-1"><a href="#类加载机制-1" class="headerlink" title="类加载机制"></a>类加载机制</h3><p><em><strong>双亲委派模型</strong></em></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。 </p><p>双亲委派模型不是一种强制性约束，也就是你不这么做也不会报错怎样的，它是一种JAVA设计者推荐使用类加载器的方式。Java历史上，有三次没有使用双亲委派模型的案例。</p><p><em><strong>双亲委派模型的代码实现</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name)<span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-comment">// 首先判断该类型是否已经被加载</span><br>            Class c = findLoadedClass(name);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                         <span class="hljs-comment">//如果存在父类加载器，就委派给父类加载器加载</span><br>                        c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span><br>                        c = findBootstrapClass0(name);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                 <span class="hljs-comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span><br>                    c = findClass(name);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (resolve) &#123;<br>                resolveClass(c);<br>            &#125;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br><br></code></pre></td></tr></table></figure><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>逻辑结构：什么时候回收？能回收什么？用什么回收？怎么回收的？</p><h3 id="垃圾回收原理机制"><a href="#垃圾回收原理机制" class="headerlink" title="垃圾回收原理机制"></a>垃圾回收原理机制</h3><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p><p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p><h3 id="判断一个对象是否可以被回收"><a href="#判断一个对象是否可以被回收" class="headerlink" title="判断一个对象是否可以被回收"></a>判断一个对象是否可以被回收</h3><p>两种策略：计数器算法和可达性分析算法</p><p><em><strong>计数器算法</strong></em></p><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 </p><p>该算法的缺陷是：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p><p><em><strong>可达性分析算法</strong></em></p><p>通过 GC Roots 作为起始点进行搜索，能够遍历到的对象都是存活的，遍历不到的对象可被回收。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p><em><strong>强引用</strong></em></p><p>发生 gc 的时候不会被回收。不会被gc回收。</p><p><em><strong>软引用</strong></em></p><p>有用但不是必须的对象，在发生内存溢出之前会被回收。（按内存走的）</p><p><em><strong>弱引用</strong></em></p><p>有用但不是必须的对象，在下一次GC时会被回收。（按gc周期走的）</p><p><em><strong>虚引用</strong></em></p><p>无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><em><strong>标记清除算法</strong></em></p><p>标记无用对象，然后进行清除回收。</p><p>缺点：标记无用对象，然后进行清除回收。</p><p><em><strong>标记复制算法</strong></em></p><p>每次移动存货对象到另一半区，然后清理可回收对象。主要用于回收新生代对象。</p><p>缺点：内存空间使用效率低</p><p><em><strong>标记整理算法</strong></em></p><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><em><strong>分代收集算法</strong></em></p><p>将内存进行切块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用: 复制算法 老年代使用: 标记 - 清除 或者 标记 - 整理 算法。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><em><strong>CMS收集器</strong></em></p><p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</p><p>执行过程：</p><ol><li>初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 </li><li>并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 </li><li>重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 </li><li>并发清除: 不需要停顿。</li></ol><p>缺点：：</p><ol><li>吞吐量低（主要体现在第二阶段）</li><li>无法处理浮动垃圾：浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。</li><li>标记 - 清除算法导致的空间碎片</li></ol><p><em><strong>G1收集器</strong></em></p><p>G1 可以直接对新生代和老年代一起回收。G1基于“标记 - 整理”算法实现。</p><p>G1收集器引入 Region 的概念，通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p>执行过程：</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ol><li>对象优先在 Eden 分配</li><li>大对象直接进入老年代</li><li>长期存活的对象进入老年代</li><li></li></ol><h3 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h3><p>Minor GC: 发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 </p><p>Full GC: 发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。 </p><p><em><strong>Minor Gc 的触发条件</strong></em></p><p>当 Eden 区的空间耗尽时 Java 虚拟机便会触发一次 Minor GC。</p><p><em><strong>Full Gc的触发条件</strong></em></p><ol><li>调用 System.gc()</li><li>老年代空间不足</li></ol><p><em><strong>减少Full Gc次数的措施</strong></em></p><ol><li>增加方法区的空间; </li><li>增加老年代的空间; </li><li>减少新生代的空间; </li><li>禁止使用System.gc()方法; （会产生STW）</li><li>使用标记-整理算法,尽量保持较大的连续内存空间; </li><li>排查代码中无用的大对象。</li></ol><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka梳理</title>
    <link href="/2021/08/07/tech/middleware/Kafka%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/07/tech/middleware/Kafka%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p><em><strong>一般什么时候用消息队列</strong></em></p><p>消息队列一般主要解决应用耦合、异步消息、流量削锋等问题。</p><p><em><strong>消息队列的通信方式</strong></em></p><p>消息队列（Message Queue）是一种进程间通信或同一进程的不同线程间的通信方式。</p><p><em><strong>消息中间件选型</strong></em></p><table><thead><tr><th align="left">特性</th><th align="left">ActiveMQ</th><th align="left">RabbitMQ</th><th align="left">RocketMQ</th><th align="left">Kafka</th><th align="left">redis/db</th></tr></thead><tbody><tr><td align="left"><strong>单机吞吐量</strong></td><td align="left">万级，吞吐量比RocketMQ和Kafka要低不止一个数量级</td><td align="left">万级，吞吐量比RocketMQ和Kafka要低不止一个数量级</td><td align="left">十万级，RocketMQ也是可以支撑高吞吐的一种MQ</td><td align="left">百万级别，Kafka最大优点就是吞吐量大，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td><td align="left"></td></tr><tr><td align="left"><strong>优势</strong></td><td align="left">非常成熟，功能强大，在业内大量公司和项目中都有应用</td><td align="left">erlang语言开发，性能极好、延时很低，吞吐量万级、MQ功能完备，管理界面非常好，社区活跃；互联网公司使用较多</td><td align="left">接口简单易用，阿里出品有保障，吞吐量大，分布式扩展方便、社区比较活跃，支持大规模的Topic、支持复杂的业务场景，可以基于源码进行定制开发</td><td align="left">超高吞吐量，ms级的时延，极高的可用性和可靠性，分布式扩展方便</td><td align="left"></td></tr><tr><td align="left"><strong>可用性</strong></td><td align="left">高，基于主从架构实现可用性</td><td align="left">高，基于主从架构实现可用性</td><td align="left">非常高，分布式架构</td><td align="left">非常高，Kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td><td align="left"></td></tr><tr><td align="left"><strong>功能支持</strong></td><td align="left">MQ领域的功能及其完备</td><td align="left">基于erlang开发，所以并发性能极强，性能极好，延时低</td><td align="left">MQ功能较为完备，分布式扩展性好</td><td align="left">功能较为简单，主要支持加单MQ功能</td><td align="left"></td></tr><tr><td align="left">支持协议</td><td align="left">STOMP</td><td align="left">AMQP，XMPP, SMTP,STOMP</td><td align="left">基于TCP/IP自定义的协议</td><td align="left">基于TCP/IP自定义的协议</td><td align="left"></td></tr><tr><td align="left"><strong>消息可靠性</strong></td><td align="left">有较低的概率丢失数据</td><td align="left">-</td><td align="left">经过参数优化配置，可以做到零丢失</td><td align="left">经过参数配置，消息可以做到零丢失</td><td align="left"></td></tr><tr><td align="left"><strong>时效性</strong></td><td align="left">ms级</td><td align="left">微秒级，这是rabbitmq的一大特点，延迟是最低的</td><td align="left">ms级</td><td align="left">延迟在ms级以内</td><td align="left"></td></tr><tr><td align="left"><strong>劣势</strong></td><td align="left">偶尔有较低概率丢失消息，社区活跃度不高</td><td align="left">吞吐量较低，erlang语音开发不容易进行定制开发，集群动态扩展麻烦</td><td align="left">接口不是按照标准JMS规范走的，有的系统迁移要修改大量的代码，技术有被抛弃的风险</td><td align="left">有可能进行消息的重复消费</td><td align="left"></td></tr><tr><td align="left"><strong>应用</strong></td><td align="left">主要用于解耦和异步，较少用在大规模吞吐的场景中</td><td align="left">都有使用</td><td align="left">用于大规模吞吐、复杂业务中</td><td align="left">在大数据的实时计算和日志采集中被大规模使用，是业界的标准</td><td align="left"></td></tr><tr><td align="left">开发语言</td><td align="left">java</td><td align="left">Erlang</td><td align="left">java</td><td align="left">Scala/Java</td><td align="left"></td></tr><tr><td align="left"><strong>Topic数量对吞吐量的影响</strong></td><td align="left">-</td><td align="left">-</td><td align="left">Topic可以达到几百、几千个的级别，吞吐量会有小幅度的下降。这是RocketMQ的一大优势，可在同等数量机器下支撑大量的Topic</td><td align="left">Topic从几十个到几百个的时候，吞吐量会大幅下降。所以在同等机器数量下，Kafka尽量保证Topic数量不要过多。如果支撑大规模Topic需要增加更多的机器</td><td align="left"></td></tr></tbody></table><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p><em><strong>Kafka都有哪些特性？</strong></em> </p><table><thead><tr><th>分布式</th><th>高性能</th><th>持久性和扩展性</th></tr></thead><tbody><tr><td>多分区</td><td>高吞吐</td><td>数据可持久化</td></tr><tr><td>多副本</td><td>低延迟</td><td>容错性</td></tr><tr><td>多订阅者</td><td>高并发</td><td>支持水平扩展</td></tr><tr><td>基于ZooKeeper调度</td><td>时间复杂度O(1)</td><td>消息自动平衡</td></tr></tbody></table><p><em><strong>Kafka的使用场景</strong></em></p><ul><li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、HBase、Solr等。</li><li>消息系统：解耦和生产者和消费者、缓存消息等。</li><li>实时计算：比如spark streaming和 Flink等流式处理</li><li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li><li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li></ul><p><em><strong>Kafka为什么速度快？</strong></em></p><ol><li><p>顺序写磁盘</p></li><li><p>使用了零拷贝技术</p></li><li><p>分区机制（以Partition为单元顺序写）</p></li></ol><p><em><strong>ZooKeeper是如何管理Kafka的</strong></em></p><p>Kafka 集群中有一个 broker 会被选举为 Controller，负责管理集群 broker 的上下线，所有topic的分区副本分配和leader选举等工作。 Controller的管理工作都是依赖于 Zookeeper的。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>Kafka是基于发布者-订阅者模式的消息队列组件。</p><p><em><strong>消费者组</strong></em></p><p>Kafka按消费者组来消费消息，每个消息只能被Consumer Group中的一个Consumer消费，不同Consumer可以消费同一消息。</p><p><em><strong>消息状态</strong></em></p><p>在Kafka中，消息是否被消费的状态保存在Consumer中，Broker不会关心消息是否被消费或被谁消费，Consumer会记录一个offset值（指向partition中下一条将要被消费的消息位置），如果offset被错误设置可能导致同一条消息被多次消费或者消息丢失。</p><blockquote><p>如此可能会导致的问题：重复消费，消息丢失。</p></blockquote><p><em><strong>消息持久化</strong></em></p><p>Kafka会把消息持久化到本地文件系统中，并且具有极高的性能。<!--依赖的什么思想得说明一下--></p><p><em><strong>批量发送</strong></em></p><p>Kafka支持以消息集合为单位进行批量发送，以提高效率。</p><p><em><strong>Push &amp; Pull</strong></em></p><p>Kafka采用的是拉模式。</p><p><em><strong>分区机制</strong></em></p><p>Kafka的Broker端支持消息分区，Producer可以决定把消息发到哪个Partition，在一个Partition中消息的顺序就是Producer发送消息的顺序，一个Topic中的Partition数是可配置的，Partition是Kafka高吞吐量的重要保证。</p><p><img src="/img/2021/Kafka%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%AE%80%E5%9B%BE.jpg" alt="Kafka工作流程简图"></p><h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p><img src="/img/2021/Kafka%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.jpg" alt="Kafka拓扑结构"></p><p><em><strong>Topic &amp; Partition &amp; Offset</strong></em></p><p>Topic在逻辑上可以被认为是一个Queue，Kafka中每条消息都必须指定一个Topic，一个Topic中的消息可以分布在集群中的多个Broker中，Consumer根据订阅的Topic到对应的Broker上去拉取消息。为了提升整个集群的吞吐量，物理上一个Topic可以分成多个Partition，每个Partition在磁盘上对应一个文件夹，该文件夹下存放了这个Partition的所有消息文件和索引文件。假设有topic1和topic2两个Topic，且分别有13个和19个分区，则整个集群会生成32个文件夹。</p><p>“RECORD”部分就是Kafka的消息格式，一条完整的消息包含RECORD、offset以及message size。其中offset用来标识它在Partition中的偏移量，这个offset是逻辑值，而非实际物理偏移值，message size表示消息的大小。</p><blockquote><p>这里要注意，因为Kafka读取消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高Kafka性能无关。</p><p>同时，因为offet由Consumer控制，所以Kafka Broker是无状态的，它不需要标记消息是否被消费过，也不需要通过Broker去保证同一个Consumer Group只有一个Consumer能消费某一条消息，因此也就不需要锁机制，从而保证了Kafka的高吞吐率</p></blockquote><p><img src="/img/2021/%E6%B6%88%E6%81%AF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpg" alt="消息文件格式"></p><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>Producer发送消息到Broker时，会根据Paritition机制选择将消息存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就实现了负载均衡。如果一个Topic对应一个文件，那这个文件所在的机器I/O将会成为这个Topic的性能瓶颈，而有了Partition后，不同的消息可以并行写入不同的Partition中，极大的提高了吞吐率。</p><p>所谓的Partition机制也就是Poducer消息partitioning策略，具体有以下几种策略：</p><p><em><strong>轮询策略</strong></em></p><p>轮询策略是Kafka Java客户端生产者的默认策略，轮询策略的负载均衡表现非常优秀，总能保证消息最大限度地被平均分配到所有分区上，默认情况下它是最合理的分区策略。</p><p><em><strong>随机策略</strong></em></p><p>随机策略默认从Partition列表中随机选择一个。</p><p><em><strong>按消息键保序策略</strong></em></p><p>Kafka允许为每条消息定义消息键，简称为Key（Key可以是一个有明确业务含义的字符串：客户代码、部门编号、业务ID、用来表征消息的元数据等）。一旦消息被定义了Key，可以保证同一个Key的所有消息都进入到相同的分区里，由于每个分区下的消息处理都是顺序的，所以这个策略被称为按消息键保序策略。</p><h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><p>Producer在生产消息的时候就涉及消息发送策略，而涉及到消息消费策略是发生在：1. 同一个Consumer Group内新增消费者；2. 消费者离开当前所属的Group； 3. 订阅的主题新增Partition。</p><p><em><strong>Range策略</strong></em></p><p>对于一个topic，对分区进行排序，然后range平均分配给Consumer Group，余的几个partitions交给前面几个Consumer Group消费。</p><p>这样带来的问题是，如果topic很多，总是前几个Consumer Group 额外消费。</p><p><em><strong>RoundRobin策略</strong></em></p><p>把所有topic的partition排序之后轮询分配给Consumer Group，这样带来的好处是负载均衡。但这种策略要保证两个前提：1. 一个消费者组消费的topic得是相同的；2. 每个topic的实例个数也是相同的</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>Kafka的高可用是说，在一个或多个Broker宕机后，其他Broker及所有Partition都能继续提供服务，且存储的消息不丢失。</p><h3 id="消息备份机制"><a href="#消息备份机制" class="headerlink" title="消息备份机制"></a>消息备份机制</h3><p><em><strong>消息备份</strong></em></p><p>Kafka的一个高可用特性体现在允许Partition存在多个副本（Replica）。</p><p>生产者直接将消息发送给Partition的leader，然后follower周期性地向leader请求同步数据。</p><p>Kafka在分配leader和follower的时候，要让leadr平均分配在不同的broker上，同一个partition的leader和follower不能在同一个broker上。</p><p><img src="/img/2021/Kafka%E6%B6%88%E6%81%AF%E5%A4%87%E4%BB%BD.jpg" alt="Kafka消息备份"></p><p><em><strong>ISR</strong></em></p><p>ISR(In-Sync Replicas)指的是一个Partition中与Leader“保持同步”的Replica列表(实际存储的是副本所在Broker的BrokerId)，这里的保持同步不是指与Leader数据保持完全一致，只需在replica.lag.time.max.ms（默认值为500）时间内与Leader保持有效连接。</p><p><em><strong>Acks</strong></em></p><p>生产者发送消息中包含acks字段，该字段代表Leader应答生产者前Leader收到的应答数。</p><ol><li>ack = 0：生产者无需等待服务端的任何确认，消息被添加到生产者套接字缓冲区后就视为已发送，因此acks=0不能保证服务端已收到消息，使用场景较少；</li><li>ack = 1：Leader将消息写入本地日志后无需等待Follower的消息确认就做出应答。如果Leader在应答消息后立即宕机且其他Follower均未完成消息的复制，则该条消息将丢失；</li><li>ack = all：Leader将等待ISR中的所有副本确认后再做出应答，因此只要ISR中任何一个副本还存活着，这条应答过的消息就不会丢失。acks=all是可用性最高的选择，但等待Follower应答引入了额外的响应时间。Leader需要等待ISR中所有副本做出应答，此时响应时间取决于ISR中最慢的那台机器。</li></ol><p><em><strong>LEO &amp; HW</strong></em></p><p>Kafka Replicas 中有两个重要的概念。</p><p><strong><u>LEO(log end offset)</u></strong> ：即日志末端偏移，指向了副本日志中下一条消息的位移值(即下一条消息的写入位置)</p><p>**<u>HW(high watermark)</u>**，即已同步消息标识，因其类似于木桶效应中短板决定水位高度，故取名高水位线</p><ol><li>消费者仅可消费各分区Leader高水位线以下的消息；</li><li>Leader的HW值由ISR中的所有备份的LEO最小值决定(Follower在发送FetchRequest时会在PartitionFetchInfo中会携带Follower的LEO)</li><li>对于任何一个副本对象而言其HW值不会大于LEO值</li></ol><p><img src="/img/2021/Kafka-HW&LEO.jpg" alt="Kafka-HW&amp;LEO"></p><h3 id="数据一致性的保障"><a href="#数据一致性的保障" class="headerlink" title="数据一致性的保障"></a>数据一致性的保障</h3><p>follower 故障：follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后， follower 会读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重新加入 ISR 了。<br>leader 故障：leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性， 其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader同步数据。<br>注意： 这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p><em><strong>Controller</strong></em></p><p>Kafka需要在集群所有Broker中选出一个Controller负责各Partition的<strong>Leader选举</strong>以及<strong>Replica的重新分配</strong>。</p><p>Kafka使用ZooKeeper存储Broker、Topic等状态数据，Kafka集群中的Controller和Broker会在ZooKeeper指定节点上注册Watcher(事件监听器)，以便在特定事件触发时，由ZooKeeper将事件通知到对应Broker。</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="批量发送消息"><a href="#批量发送消息" class="headerlink" title="批量发送消息"></a>批量发送消息</h3><p><em><strong>Partition</strong></em></p><p>Kafka的消息是一个一个的键值对，键可以设置为默认的null。键有两个用途，可以作为消息的附加信息，也可以用来决定该消息被写入到哪个Partition。</p><p>Kafka通过将Topic划分成多个Partition，Producer将消息分发到多个本地Partition的消息队列中，每个Partition消息队列中的消息会写入到不同的Leader节点。消息经过路由策略，被分发到不同的Partition对应的本地队列，然后再批量发送到Partition对应的Leader节点。</p><p><img src="/img/2021/Kafka%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.jpg" alt="Kafka批量发送消息"></p><p><em><strong>消息路由</strong></em></p><p>Round Robin：Producer将消息均衡地分配到各Partition本地队列上，是最常用的分区策略。</p><p>散列：Kafka对消息的key进行散列，根据散列值将消息路由到特定的Partition上，键相同的消息总是被路由到相同的Partition上。</p><p>自定义分区策略：Kafka支持自定义分区策略，可以将某一系列的消息映射到相同的Partition。</p><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><ol><li>Kafka采用顺序IO读写磁盘；</li><li>通过索引文件提高对磁盘的查询效率；</li></ol><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>数据通过DMA拷贝到内核态Buffer后，直接通过DMA拷贝到NIC Buffer，无需CPU拷贝，这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件-网络发送由一个sendfile调用完成，整个过程只有两次上下文切换，没有cpu数据拷贝，因此大大提高了性能。</p><p>Linux 2.4+内核通过sendfile系统调用，提供了零拷贝。</p><p>Kafka的数据传输通过TransportLayer来完成，其子类PlaintextTransportLayer通过Java NIO的FileChannel的transferTo()和transferFrom()方法实现零拷贝。transferTo()和transferFrom()并不保证一定能使用零拷贝，实际上是否能使用零拷贝与操作系统相关，如果操作系统提供sendfile这样的零拷贝系统调用，则这两个方法会通过这样的系统调用充分利用零拷贝的优势，否则并不能通过这两个方法本身实现零拷贝。</p><p><img src="/img/2021/%E9%9B%B6%E6%8B%B7%E8%B4%9D1.jpg" alt="cpu四次拷贝"></p><p><img src="/img/2021/%E9%9B%B6%E6%8B%B7%E8%B4%9D2.jpg" alt="零拷贝"></p><h2 id="一些常见问题的解决方案"><a href="#一些常见问题的解决方案" class="headerlink" title="一些常见问题的解决方案"></a>一些常见问题的解决方案</h2><h3 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h3><p><em><strong>producer丢消息</strong></em></p><ol><li>在发送过程中发生网络抖动，导致消息没有发送到broker；</li><li>消息本身不合规（消息太大）导致broker拒收。</li></ol><p>解决方案：发送端增加重试机制。</p><p><em><strong>broker丢消息</strong></em></p><ol start="3"><li>follower没来得及完全同步leader的数据，leader下线了，重新选举的follower信息不完全。</li></ol><p>解决方案：</p><ul><li>通过设置，保证每个partition 的副本至少要2个以上；</li><li>通过设置，保证leader至少与一个follower 正确同步数据；</li><li>ack = all，所有副本同步完之后，才认为是写入成功。</li></ul><p><em><strong>consumer丢消息</strong></em></p><ol start="4"><li>consumer自动提交了offset，让broker认为该offset已经被消费，但在处理消息时机器宕机了，导致这条消息没有真正被处理。</li></ol><p>解决方案：关闭自动更新offset，等到数据被处理后再手动跟新offset。</p><h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p>重复消费的原因在于：已经消费了数据，但是offset没来得及提交。</p><ol><li>强行kill线程，导致消费后的数据，offset没有提交（消费系统宕机、重启等）</li><li>设置offset为自动提交，关闭kafka时，如果在close之前，调用 consumer.unsubscribe() 则有可能部分offset没提交，下次重启会重复消费。</li><li>消费后的数据，当offset还没有提交时，partition就断开连接。比如，通常会遇到消费的数据，处理很耗时，导致超过了Kafka的session timeout时间（0.10.x版本默认是30秒），那么就会reblance重平衡，此时有一定几率offset没提交，会导致重平衡后重复消费。</li><li>当消费者重新分配partition的时候，可能出现从头开始消费的情况，导致重发问题。</li><li>当消费者消费的速度很慢的时候，可能在一个session周期内还未完成，导致心跳机制检测报告出问题。</li><li>并发很大，可能在规定的时间（session.time.out默认30s）内没有消费完，就会可能导致reblance重平衡，导致一部分offset自动提交失败，然后重平衡后重复消费</li></ol><p>解决方案：</p><ol><li>提高消费者处理速度，或增加timeout值；</li><li>引入消息去重机制：生产端生产消息时，加入唯一id，消费端保存最近消费记录，消费的时候通过redis查询去重再消费；</li></ol><h3 id="数据积压"><a href="#数据积压" class="headerlink" title="数据积压"></a>数据积压</h3><p>数据积压导致来不及消费怎么办？</p><p>解决方案：</p><ol><li>先修复 consumer的问题,确保其恢复消费速度,然后将现有 consumer都停掉。</li><li>新建一个 topic, partition是原来的10倍,临时建立好原先10倍的 queue数量</li><li>然后写一个临时的分发数据的 consumer程序,这个程序部署上去消费积压的数据,消费之 后不做耗时的处理,直接均匀轮询写入临时建立好的10倍数量的 queue。</li><li>接着临时征用10倍的机器来部署 consumer,每一批 consumer消费一个临时 queue的数 据。这种做法相当于是临时将 queue资源和 consumer资源扩大10倍,以正常的10倍速度 来消费数据。</li><li>等快速消费完积压数据之后,得恢复原先部署的架构,重新用原先的 consumer机器来消费消息。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加密算法梳理</title>
    <link href="/2021/08/05/tech/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/05/tech/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>对称加密指加密和解密使用同一密钥。</p><p>对称加密过程：采用单秘钥加密，发送方将发送数据分割成固定大小的块，经过秘钥和加密算法加密后发送。接收方收到报文后，结合解密算法使用相同的密钥解密得出原始数据。N个用户需要N*(N-1)/2个不同的密钥。</p><p>优点：效率高，算法简单，系统开销小，适合加密大量数据。</p><p>缺点：安全性差（密钥泄露），扩展性差（通信双方要协商密钥，密钥生成过多不易于管理）。</p><p>常见的对称加密算法：DES、AES、sm4</p><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>非对称加密指的是加密和解密使用不同的密钥，一把公开的公钥，一把私有的私钥。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。</p><p>N个用户，需要2N个密钥。</p><p>非对称加密过程：甲使用乙的公钥并结合相应的非对称算法将明文加密发送给乙，乙结合自己的私钥和非对称算法解密得到明文。</p><p>优点：更安全</p><p>缺点：算法复杂度高，加密之后报文冗长，适合对少量数据加密，增加了网络传输成本。</p><p>RSA算法 sm2算法</p><table><thead><tr><th></th><th>SM2</th><th>RSA</th></tr></thead><tbody><tr><td>算法结构</td><td>椭圆曲线</td><td>可逆模幂运算</td></tr><tr><td>计算复杂度</td><td>指数级</td><td>亚指数级</td></tr><tr><td>存储空间</td><td>192-256bit</td><td>2048-4096bit</td></tr><tr><td>秘钥生成速度</td><td>比RSA快百倍以上</td><td>慢</td></tr><tr><td>加解密速度</td><td>较快</td><td>一般</td></tr></tbody></table><h2 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h2><p>单向加密算法只能对数据加密，不能解密。特点为定长输出，雪崩效应（少量消息位的变化会引起信息摘要的许多位的变化）。</p><p>单向加密常用于验证数据完整性、数字摘要、数字签名等。</p><p>加密过程：发送方对明文进行加密发送，接收方对同样的明文进行加密，比对。</p><p>常见的单向加密算法：MD5、sm3</p><h2 id="CA认证"><a href="#CA认证" class="headerlink" title="CA认证"></a>CA认证</h2>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis梳理</title>
    <link href="/2021/08/05/tech/middleware/Redis%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/05/tech/middleware/Redis%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis基本数据结构有：String、List、Hash、Set、SortedSet</p><h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>操作复杂度：在SortedSet中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为<strong>logN</strong>。</p><p>SortedSet底层采用字典+跳跃表两种数据结构，来保存有序集元素。字典是通过哈希表来实现的。</p><p><img src="/img/2021/zset%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="zset数据结构"></p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis支持RDB持久化、AOF持久化、RDB-AOF混合持久化这三种持久化方式。</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p><em><strong>概要</strong></em></p><ol><li>RDB持久化是Redis默认的持久化方式；</li><li>工作原理是周期性地以快照的形式将数据持久化到硬盘中；</li><li>通过BGSAVE命令操作。 <!--bgsave怎么用再看一下--></li></ol><p><em><strong>持久化过程</strong></em></p><ol><li><code>bgsave</code>命令让父进程fork一个子进程（进行一个判断，如果父进程已经有了一个子进程就直接返回）；</li><li>父进程fork完了之后处理其他任务，同时，子进程将父进程内存中的数据写到.rdb文件持久化到硬盘中；（os通过CopyOnWrite解决数据更新引发的冲突）</li><li>子进程持久化完了之后，通知父进程更新.rdb文件。</li></ol><p><img src="/img/2021/RDB%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="RDB持久化过程"></p><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p><em><strong>概要</strong></em></p><ol><li>AOF持久化以独立日志的方式，记录每次写入的命令；</li><li>AOF持久化的实时性更好，但存在大量的冗余命令，需要通过重写机制压缩日志，恢复速度慢。</li></ol><p><em><strong>持久化过程</strong></em></p><ol><li>命令写入后，通过append到一个buffer中保证实时性，再同步到一个旧AOF文件中；</li><li>重写过程和RDB持久化过程类似，只是最后父进程写到一个buffer里，同步到一个新AOF文件中；</li><li>最后用新的AOF文件把旧的AOF文件替换掉，重启服务时再把新文件load进来。</li></ol><p><img src="/img/2021/AOF%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="AOF持久化过程"></p><h3 id="RDB-AOF混合持久化"><a href="#RDB-AOF混合持久化" class="headerlink" title="RDB-AOF混合持久化"></a>RDB-AOF混合持久化</h3><p>混合持久化的过程为：在AOF重写时，先执行<code>bgsave</code>生成RDB，再将后处理的命令追加到rdb结尾。</p><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>Redis的主从复制是为了提升分布式系统的可用性和读写性能的。Redis通过SLAVEOF命令或slaveof配置让一个server复制另一个server的数据集和状态。Redis采用异步复制机制。</p><p>主从复制的优点：</p><ol><li>master可以关闭持久化机制，减少IO性能损耗；</li><li>slave能提高读请求处理效率；</li><li>容灾性比较好</li></ol><blockquote><p>主从复制和集群概念上的区别：主从复制是一个master和若干个slave，一个master挂了可以从slave推选新的master，slave可以用提供故障恢复、分担读流量、备份数据；集群是数据量较大时，数据根据key根据哈希计算出slot在多个分片中进行分区（partition），客户端对key的请求会被转发到持有那个key的分片上。分片由一个master和若干个slave组成，他们之间又通过主从复制机制来同步数据。可以理解为集群是主从复制和分区的集合。</p></blockquote><h3 id="主从复制的使用"><a href="#主从复制的使用" class="headerlink" title="主从复制的使用"></a>主从复制的使用</h3><p>主从复制的开启，完全是在 slave 发起的，不需要我们在 master 做任何事情。slave 开启主从复制，有三种方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 配置文件，在从服务器的配置文件中加入：</span><br>slaveof &lt;masterip&gt; &lt;masterport&gt;<br><br><span class="hljs-meta">#</span><span class="bash">启动命令，Redis server 启动命令后加入：</span><br>--slaveof &lt;masterip&gt; &lt;masterport&gt;<br><br><span class="hljs-meta">#</span><span class="bash"> 客户端命令 Redis server 启动后，直接通过客户端执行命令：</span><br>slaveof &lt;masterip&gt; &lt;masterport&gt;，则该 Redis 实例成为 slave。<br></code></pre></td></tr></table></figure><h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3><p>主从复制过程可分为三个阶段：复制初始化、数据同步和命令传播。</p><p><em><strong>初始化阶段</strong></em></p><ol><li>执行完slaveof命令后，slave根据master地址发起socket连接，master收到socket连接之后将连接信息保存，连接建立；</li><li>slave向master发送PING命令，结果如果返回PONG则说明master可用，否则说明master处理其他任务在阻塞中，slave断开连接并重试；</li></ol><p><em><strong>数据同步阶段</strong></em></p><ol><li>master和slave相互确认连接信息后，slave向master发送psync命令；</li><li>主库收到该命令后判断是进行增量同步还是全量同步，然后根据策略进行数据的同步；</li><li>当master有新的写操作时候，此时进入复制第三阶段。</li></ol><p><em><strong>命令传播阶段</strong></em></p><ol><li>数据同步之后，master和slave通过心跳机制检测彼此是否挂了，每隔10smaster向slave发送PING命令判断slave是否在线，slave每隔1s发送replconf ack命令。</li><li>slave发送的命令除了判断master是否在线外，还汇报了自己的复制偏移量，让master根据当前同步情况发布未同步数据的命令。</li></ol><p><em><strong>全量复制</strong></em></p><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。</p><p>发生全量复制的时候，master会在后台启动一个线程，把同步数据生成一份RDB文件，同时将新收到客户端的写命令缓存到内存中，RDB文件生成完之后发送给slave，等slave同步完RDB文件之后，再把写命令发给slave进行同步。过程中如果发生网络故障，会自动重连，master只会复制给slave部分缺少的数据。</p><p><em><strong>增量复制</strong></em></p><p>增量复制发生在正常工作时master发生的写操作同步到slave的过程。增量复制的过程为：master每执行一个写命令就向slave发送相同的写命令，slave接受并执行。</p><h2 id="Redis集群模式"><a href="#Redis集群模式" class="headerlink" title="Redis集群模式"></a>Redis集群模式</h2><h3 id="集群模式原理"><a href="#集群模式原理" class="headerlink" title="集群模式原理"></a>集群模式原理</h3><p>大规模数据存储系统都会面临的一个问题就是如何横向拓展。当你的数据集越来越大，一主多从的模式已经无法支撑这么大量的数据存储，于是你首先考虑将多个主从模式结合在一起对外提供服务。</p><p>Redis采用的是一种去中心化的集群模式。集群通过分片进行数据共享，分片内采用一主多从的形式进行副本复制，并提供复制和故障恢复功能。</p><blockquote><p>主从复制相当于一棵树，集群相当于是一个森林。</p></blockquote><p><em><strong>Redis集群模式原理</strong></em></p><p>以下图为例，一主一从构成一个分片，之间通过异步进行复制，一个机房的master挂掉，会推选另一个机房的slave为master，继续提供服务。每个master负责一部分的slot，客户端通过key做映射取模得到对应的slot，连接到对应的分片，写请求一律走master， 读请求根据路由选择规则找到对应的分片节点。</p><p><img src="/img/2021/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.jpg" alt="Redis集群模式"></p><h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>跟大多数分布式系统一样，Redis Cluster 的节点间通过持续的 heart beat 来保持信息同步，不过 Redis Cluster 节点信息同步是内部实现的，并不依赖第三方组件如 Zookeeper。集群中的节点持续交换 PING、PONG 数据，消息协议使用 Gossip，这两种数据包的数据结构一样，之间通过 type 字段进行区分。</p><p>Redis通过<strong>哨兵机制</strong>保证高可用。</p><p><em><strong>哨兵机制的工作原理</strong></em></p><ol><li>Redis Sentinel（哨兵）是一个分布式架构，它包含若干个哨兵节点和数据节点。</li><li>每个哨兵节点会对数据节点和其余的哨兵节点进行监控，当发现节点不可达时，会对节点做下线标识。</li><li>如果被标识的是主节点，它就会与其他的哨兵节点进行协商，当多数哨兵节点都认为主节点不可达时，它们便会选举出一个哨兵节点来完成自动故障转移的工作，同时还会将这个变化实时地通知给应用方。</li></ol><p><em><strong>通信过程</strong></em></p><p>Redis集群中的每个节点会定期向其他节点发送PING，如果超过规定时间（node_timeout）没有收到PONG，就会标记为疑似下线状态（PFAIL）。在PING的时候，会广播其他节点当前节点知道的其他节点的信息（包括疑似挂了的节点），当其他节点收到这些疑似挂了的节点之后，会做失效报告（failure report）。如果当前节点已经PFAIL了某个节点，并且大部分节点认为PFAIL的节点PFAIL了，那么当前节点就改PFAIL为FAIL并广播出去。</p><h3 id="故障迁移"><a href="#故障迁移" class="headerlink" title="故障迁移"></a>故障迁移</h3><p>Redis引入了一个<em>epoch</em>的概念。在Redis集群中主要有两种epoch：<em>curentEpoch</em> 和 <em>configEpoch</em>。</p><p><em><strong>currentEpoch</strong></em></p><p>这是一个集群状态相关的概念，可以当做记录集群状态变更的递增版本号。每个集群节点，都会通过 server.cluster-&gt;currentEpoch 记录当前的 currentEpoch。</p><p>集群节点创建时，不管是 master 还是 slave，都置 currentEpoch 为 0。当前节点接收到来自其他节点的包时，如果发送者的 currentEpoch（消息头部会包含发送者的 currentEpoch）大于当前节点的currentEpoch，那么当前节点会更新 currentEpoch 为发送者的 currentEpoch。因此，集群中所有节点的 currentEpoch 最终会达成一致，相当于对集群状态的认知达成了一致。</p><p><em><strong>currentEpoch的作用</strong></em></p><p>currentEpoch 作用在于，当集群的状态发生改变，某个节点为了执行一些动作需要寻求其他节点的同意时，就会增加 currentEpoch 的值。目前 currentEpoch 只用于 slave 的故障转移流程，这就跟哨兵中的sentinel.current_epoch 作用是一模一样的。当 slave A 发现其所属的 master 下线时，就会试图发起故障转移流程。首先就是增加 currentEpoch 的值，这个增加后的 currentEpoch 是所有集群节点中最大的。然后slave A 向所有节点发起拉票请求，请求其他 master 投票给自己，使自己能成为新的 master。其他节点收到包后，发现发送者的 currentEpoch 比自己的 currentEpoch 大，就会更新自己的 currentEpoch，并在尚未投票的情况下，投票给 slave A，表示同意使其成为新的 master。</p><p><em><strong>configEpoch</strong></em></p><p>这是一个集群节点配置相关的概念，每个集群节点都有自己独一无二的 configepoch。所谓的节点配置，实际上是指节点所负责的槽位信息。</p><p> 每一个 master 在向其他节点发送包时，都会附带其 configEpoch 信息，以及一份表示它所负责的 slots 信息。而 slave 向其他节点发送包时，其包中的 configEpoch 和负责槽位信息，是其 master 的 configEpoch 和负责的 slot 信息。节点收到包之后，就会根据包中的 configEpoch 和负责的 slots 信息，记录到相应节点属性中。</p><p><em><strong>configEpoch的作用</strong></em></p><p>configEpoch 主要用于解决不同的节点的配置发生冲突的情况。举个例子就明白了：节点A 宣称负责 slot 1，其向外发送的包中，包含了自己的 configEpoch 和负责的 slots 信息。节点 C 收到 A 发来的包后，发现自己当前没有记录 slot 1 的负责节点（也就是 server.cluster-&gt;slots[1] 为 NULL），就会将 A 置为 slot 1 的负责节点（server.cluster-&gt;slots[1] = A），并记录节点 A 的 configEpoch。后来，节点 C 又收到了 B 发来的包，它也宣称负责 slot 1，此时，如何判断 slot 1 到底由谁负责呢？</p><p>这就是 configEpoch 起作用的时候了，C 在 B 发来的包中，发现它的 configEpoch，要比 A 的大，说明 B 是更新的配置。因此，就将 slot 1 的负责节点设置为 B（server.cluster-&gt;slots[1] = B）。在 slave 发起选举，获得足够多的选票之后，成功当选时，也就是 slave 试图替代其已经下线的旧 master，成为新的 master 时，会增加它自己的 configEpoch，使其成为当前所有集群节点的 configEpoch 中的最大值。这样，该 slave 成为 master 后，就会向所有节点发送广播包，强制其他节点更新相关 slots 的负责节点为自己。</p><blockquote><p>slave在发现从属master下线后，通过增加currentEpoch计数，向其他节点拉起投票，其他节点在currentEpoch更新机制下会投票给slave，从而选举其成为master。</p></blockquote><h2 id="Redis淘汰策略"><a href="#Redis淘汰策略" class="headerlink" title="Redis淘汰策略"></a>Redis淘汰策略</h2><p>当写入数据将导致超出maxmemory限制时，Redis会采用maxmemory-policy所指定的策略进行数据淘汰。</p><p>按照「数据范围」分为volatile淘汰和allkeys淘汰，按照「淘汰算法」分为随机淘汰、LRU淘汰、LFU淘汰。</p><p>LRU：按最近最少使用原则淘汰。（未被淘汰的key可能是不常使用但刚刚使用的key）</p><p>LFU：先按照使用次数淘汰，使用次数相同的key再使用LRU淘汰。（Redis4.0支持）</p><p><img src="/img/2021/Redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.png" alt="Redis淘汰策略"></p><h2 id="Redis过期策略"><a href="#Redis过期策略" class="headerlink" title="Redis过期策略"></a>Redis过期策略</h2><p>Redis支持两种过期策略：定期删除和惰性删除。</p><p><em><strong>定期删除</strong></em></p><p>Redis会将设置了过期时间的key放到一个独立的字典中，并对该字典进行每秒10次的过期扫描。<br>过期扫描不会遍历字典中所有的key，而是采用了一种简单的贪心策略。该策略的删除逻辑如下：</p><ol><li>从过期字典中随机选择20个key；</li><li>删除这20个key中已过期的key；</li><li>如果已过期key的比例超过25%，则重复步骤1。</li></ol><p><em><strong>惰性删除</strong></em></p><p>客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。</p><h3 id="缓存穿透、缓存击穿、缓存雪崩"><a href="#缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩"></a>缓存穿透、缓存击穿、缓存雪崩</h3><p><em><strong>缓存穿透</strong></em></p><p>客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。</p><p>解决方案：</p><ol><li>缓存空对象：存储层未命中后，仍然将空值存入缓存层，客户端再次访问数据时，缓存层会直接返回空值。</li><li>布隆过滤器：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若请求的数据不存在则直接返回空值。</li></ol><p><em><strong>布隆过滤器</strong></em></p><p>布隆过滤器可以用很低的代价，估算出数据是否真实存在。</p><p>布隆过滤器的核心包括两部分：</p><ol><li>一个大型的位数组；</li><li>若干个不一样的哈希函数，每个哈希函数都能将哈希值算的比较均匀。</li></ol><p>布隆过滤器的工作原理：</p><ol><li>添加key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置，并将位数组中这个位置的值设置为1。</li><li>询问key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置。然后对比这些哈希函数在位数组中对应位置的数值：<ul><li>如果这几个位置中，有一个位置的值是0，就说明这个布隆过滤器中，不存在这个key。</li><li>如果这几个位置中，所有位置的值都是1，就说明这个布隆过滤器中，极有可能存在这个key。之所以不是百分之百确定，是因为也可能是其他的key运算导致该位置为1。</li></ul></li></ol><p><em><strong>缓存击穿</strong></em></p><p>一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。</p><p>解决方案：</p><ol><li>永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。</li><li>加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。</li></ol><p><em><strong>缓存雪崩</strong></em></p><p>在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成<strong>数据库宕机</strong>。可能是<strong>缓存中有大量数据同时过期</strong>，也可能是<strong>Redis节点发生故障</strong>，导致大量请求无法得到处理。</p><p>解决方案：</p><ol><li>避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。</li><li>启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息/空值/错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是直接返回。</li><li>构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。</li></ol><h2 id="Redis性能分析"><a href="#Redis性能分析" class="headerlink" title="Redis性能分析"></a>Redis性能分析</h2><p><em><strong>Redis性能高的原因</strong></em></p><ol><li>Redis是单线程的，可以避免线程切换的性能损耗；</li><li>Redis大部分操作是在内存中完成的；</li><li>Redis采用了IO多路复用机制，使其在IO操作中能并发处理大量的请求，实现高吞吐；</li><li>Redis使用了高效的数据结构（如：在zset中使用跳表）</li><li>Redis是C语言编写的，执行效率高</li></ol><p><em><strong>关于单线程的解释</strong></em></p><p>Redis在键值对操作时，是单线程操作。涉及持久化、异步、集群数据同步等操作时，需要依赖其他线程来执行。Redis的底层其实并不完全是单线程的。</p><p><em><strong>IO多路复用</strong></em> <!-- 留着开一个IO多路复用的专题来写--></p><h2 id="TODO："><a href="#TODO：" class="headerlink" title="TODO："></a>TODO：</h2><ul><li>IO多路复用</li><li>关于跳表结构操作细节的掌握</li><li>redis的API的使用</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>美团实习需求梳理</title>
    <link href="/2021/08/05/proj/%E7%BE%8E%E5%9B%A2%E5%AE%9E%E4%B9%A0%E9%9C%80%E6%B1%82%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/05/proj/%E7%BE%8E%E5%9B%A2%E5%AE%9E%E4%B9%A0%E9%9C%80%E6%B1%82%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="充电宝微信客诉"><a href="#充电宝微信客诉" class="headerlink" title="充电宝微信客诉"></a>充电宝微信客诉</h1><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>用户在使用充电宝业务时，通过微信发起诉讼，微信侧要求美团侧在24小时内进行回复响应，否则默认给用户退款。美团侧客诉服务之前都是通过太平洋系统调取微信侧工单线下回访解决客诉问题的，此方案大量消耗人工资源，此需求核心价值在于为及时响应微信侧请求，减少经济损失，形成线上自动化的回复处理。</p><h2 id="产品方案"><a href="#产品方案" class="headerlink" title="产品方案"></a>产品方案</h2><p>由于需求紧急，产品方案排了两期。一期方案为网管侧直接对微信侧做同步响应，回复消息写死。<!-- 二期方案后续补上 --></p><p><img src="/img/2021/%E5%BE%AE%E4%BF%A1%E5%AE%A2%E8%AF%89%E4%B8%80%E6%9C%9F%E4%BA%A7%E5%93%81%E6%96%B9%E6%A1%88.jpg" alt="微信客诉一期产品方案"></p><p><img src="/img/2021/%E5%BE%AE%E4%BF%A1%E5%AE%A2%E8%AF%89%E4%BA%8C%E6%9C%9F%E4%BA%A7%E5%93%81%E6%96%B9%E6%A1%88.jpg" alt="微信客诉二期产品方案"></p><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><h3 id="一期技术方案"><a href="#一期技术方案" class="headerlink" title="一期技术方案"></a>一期技术方案</h3><p>首先，要创建回调地址，在上线前告诉微信侧请求美团网关侧的回调地址。</p><p>其次，要写一个controller，实现微信侧「通知回调」接口，处理微信侧的回调请求。</p><p>在这个处理controller里，要实现微信侧提供的「提交回复」接口。</p><!--微信客诉一期技术方案图重新画 --><h3 id="一期技术实现"><a href="#一期技术实现" class="headerlink" title="一期技术实现"></a>一期技术实现</h3><h4 id="创建回调地址"><a href="#创建回调地址" class="headerlink" title="创建回调地址"></a>创建回调地址</h4><p><a href="https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter10_2_2.shtml">参考文档</a></p><p>在当时我的实现思路是，在controller新增了一个创建回调地址的方法，然后拿postman去请求这个controller，然后利用这个controller请求微信侧的「创建回调地址」接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/newCallbackUrl&quot;, method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">newCallbackUrl</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    String requestUrl = <span class="hljs-string">&quot;https://api.mch.weixin.qq.com/v3/merchant-service/complaint-notifications&quot;</span>;<br>    String callbackUrl = <span class="hljs-string">&quot;https://paygate-staging-yf.pay.st.meituan.com/paygate/notify/complaint/app&quot;</span>;<br>    Short payType = PayType.PAY_TYPE_WXPAYSCORE_APP; <br>    WxConfig wxConfig = WxConfig.wxConfigMap.get(payType + <span class="hljs-string">&quot;&quot;</span>); <br>    <br>    Map&lt;String, String&gt; requestMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    requestMap.put(<span class="hljs-string">&quot;url&quot;</span>, callbackUrl);<br>    String requestMsg = JSON.toJSONString(requestMap);<br>    <span class="hljs-keyword">long</span> timestamp = WxPayUtil.getCurrentTimestamp();<br>    String nonce = WxPayUtil.generateNonceStr();<br>    String signature = SignUtil.signRSA(requestMsg, HttpRequestTypeEnum.POST, requestUrl, timestamp, nonce, wxConfig.getPrivateKey());<br>    HttpResponseModel responseModel = HttpUtils.httpPost(requestUrl, requestMsg, wxConfig.getPlatformCertificateNo(), WxPayScoreServiceImpl.getAuthorization(wxConfig, signature, timestamp, nonce), <span class="hljs-keyword">new</span> HashMap&lt;&gt;(), <span class="hljs-keyword">null</span>);<br>    <br>    Map&lt;String, String&gt; header = responseModel.getHttpHeader();<br>    String ret = JSON.toJSONString(header);<br>    String responseData = responseModel.getResponseData();<br>    ret += (<span class="hljs-string">&quot;\n&quot;</span> + responseData);<br>    System.out.println(responseData);<br>    response.setStatus(<span class="hljs-number">200</span>);<br>    response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>    response.getWriter().write(responseData);<br>    response.getWriter().flush();<br>    response.getWriter().close();<br>    <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="业务线处理函数"><a href="#业务线处理函数" class="headerlink" title="业务线处理函数"></a>业务线处理函数</h4><p>微信提供了若干种支付方式：JSAPI、APP、H5、Native、小程序等。由于充电宝业务只接入了Native和小程序两个接口。所以在处理的时候，要分别进行响应处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/app/complaint&quot;, method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">app</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    response.setStatus(<span class="hljs-number">500</span>);<br>    Short payType = PayType.PAY_TYPE_WXPAYSCORE_APP;<br>    doProcess(payType, request, response);<span class="hljs-comment">//APP</span><br>&#125;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/applets/complaint&quot;, method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applets</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    response.setStatus(<span class="hljs-number">500</span>);<br>    Short payType = PayType.PAY_TYPE_WXPAYSCORE_APPLETS;<br>    doProcess(payType, request, response);<span class="hljs-comment">//小程序</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="处理函数"><a href="#处理函数" class="headerlink" title="处理函数"></a>处理函数</h4><p>整个处理部分包含了三个部分：</p><ol><li>加签</li><li>响应回调请求</li><li>调用回复接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doProcess</span><span class="hljs-params">(Short payType, HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    WxConfig wxConfig = WxConfig.wxConfigMap.get(payType + <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        String reqContext = WxUtil.parseReqByte(request);<br>        Map&lt;String, Object&gt; reqMap = <span class="hljs-keyword">new</span> Gson().fromJson(reqContext, HashMap.class);<br>        log.info(<span class="hljs-string">&quot;WxPayComplaint request payType:&#123;&#125;, data:&#123;&#125;&quot;</span>, payType, reqMap);<br>        <span class="hljs-keyword">if</span> (reqMap == <span class="hljs-keyword">null</span> || reqMap.size() &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        Map&lt;String, String&gt; reqWxResource = (Map&lt;String, String&gt;) reqMap.get(<span class="hljs-string">&quot;resource&quot;</span>);<br>        String notifyContext = WxPayUtil.decryptToString(wxConfig.getApiKey(), String.valueOf(reqWxResource.get(<span class="hljs-string">&quot;associated_data&quot;</span>)),<br>                String.valueOf(reqWxResource.get(<span class="hljs-string">&quot;nonce&quot;</span>)), String.valueOf(reqWxResource.get(<span class="hljs-string">&quot;ciphertext&quot;</span>)));<br>        Map&lt;String, String&gt; notifyContextMap = WxUtil.jsonStrToMap(notifyContext);<br>        String msgId = String.valueOf(reqMap.get(<span class="hljs-string">&quot;id&quot;</span>));<br>        String complaintID = notifyContextMap.get(<span class="hljs-string">&quot;complaint_id&quot;</span>);<br>        String complainedMchId = wxConfig.getMchId();<br>        String actionType = notifyContextMap.get(<span class="hljs-string">&quot;action_type&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;msgId:&#123;&#125;,complaintId:&#123;&#125;,actionType:&#123;&#125;&quot;</span>, msgId, complaintID, actionType);<br>        <br>        response.setStatus(<span class="hljs-number">200</span>);<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>, <span class="hljs-string">&quot;No-cache&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);<br>        response.setDateHeader(<span class="hljs-string">&quot;Expires&quot;</span>, <span class="hljs-number">0</span>);<br>        Map&lt;String, String&gt; responseMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        responseMap.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;SUCCESS&quot;</span>);<br>        responseMap.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;成功&quot;</span>);<br>        response.getWriter().write(<span class="hljs-keyword">new</span> Gson().toJson(responseMap));<br>        response.getWriter().flush();<br>        response.getWriter().close();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;CREATE_COMPLAINT&quot;</span>.equals(actionType) || <span class="hljs-string">&quot;CONTINUE_COMPLAINT&quot;</span>.equals(actionType)) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (submitResponse(complaintID, complainedMchId, wxConfig)) <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;wxComplaint response notify error: &#123;&#125;&quot;</span>, ExceptionUtils.getStackTrace(e));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="回复接口实现"><a href="#回复接口实现" class="headerlink" title="回复接口实现"></a>回复接口实现</h4><p><a href="https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter10_2_14.shtml">参考文档</a></p><p>根据微信侧提供的接口文档，必传参数包括商户id和回复内容，这里的商户id是从微信侧回调报文中获取的，回复内容是写死的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">submitResponse</span><span class="hljs-params">(String complaintID, String complainedMchid, WxConfig wxConfig)</span> <span class="hljs-keyword">throws</span> SendException </span>&#123;<br>    String responseContent = <span class="hljs-string">&quot;您的反馈已经收到，我们将尽快联系您处理。&quot;</span>;<br>    String suffixUrl = String.format(WxConstants.COMPLAINTS_RESPONSE_URI_SUFFIX, complaintID);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">long</span> timestamp = WxPayUtil.getCurrentTimestamp();<br>        Map&lt;String, String&gt; requestMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        requestMap.put(<span class="hljs-string">&quot;complainted_mchid&quot;</span>, complainedMchid);<br>        requestMap.put(<span class="hljs-string">&quot;response_content&quot;</span>, responseContent);<br>        String requestMsg = <span class="hljs-keyword">new</span> Gson().toJson(requestMap);<br>        String nonce = WxPayUtil.generateNonceStr();<br>        String signature = SignUtil.signRSA(requestMsg, HttpRequestTypeEnum.POST, suffixUrl, timestamp, nonce, wxConfig.getPrivateKey());<br>        <span class="hljs-comment">// 打印 发送的报文</span><br>        HttpResponseModel responseModel = HttpUtils.httpPost(WxPayUtil.url + suffixUrl, requestMsg, wxConfig.getPlatformCertificateNo(),<br>                WxPayScoreServiceImpl.getAuthorization(wxConfig, signature, timestamp, nonce), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (responseModel != <span class="hljs-keyword">null</span> &amp;&amp; responseModel.getHttpStatusCode() == <span class="hljs-number">204</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;submitResponse success&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;submitResponse error&quot;</span>);<br>            <span class="hljs-keyword">if</span> (responseModel != <span class="hljs-keyword">null</span>) &#123;<br>                log.info(<span class="hljs-string">&quot;submitResponse return: \n httpStatusCode:&#123;&#125;, httpHeader: &#123;&#125;, responseData: &#123;&#125;&quot;</span>,<br>                        responseModel.getHttpStatusCode(), <span class="hljs-keyword">new</span> Gson().toJson(responseModel.getHttpHeader()), responseModel.getResponseData());<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;submit response error:&#123;&#125;&quot;</span>, ExceptionUtils.getStackTrace(e));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="签名方式"><a href="#签名方式" class="headerlink" title="签名方式"></a>签名方式</h3><p>微信侧约定的签名方式是RSA加密。</p><p>整个给微信侧签名过程是怎样的？<br>参考：<a href="https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_0.shtml">签名方案</a>、<a href="https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_0.shtml">验签方案</a></p><h1 id="单车接入支付宝代扣"><a href="#单车接入支付宝代扣" class="headerlink" title="单车接入支付宝代扣"></a>单车接入支付宝代扣</h1><h2 id="项目背景-1"><a href="#项目背景-1" class="headerlink" title="项目背景"></a>项目背景</h2><p>微信侧要下线单车场景自动续费做产品升级，考虑到用户量较大，美团临时新增支付宝代扣功能。</p><h2 id="产品方案-1"><a href="#产品方案-1" class="headerlink" title="产品方案"></a>产品方案</h2><p>之前美团已经将打车业务接入到支付宝代扣能力建设中，根据和支付宝侧沟通，单车场景接入只需要在签约接口新增子商户字段，此行为不影响其他支付退款接口。</p><p><img src="/img/2021/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BB%A3%E6%89%A3%E7%AD%BE%E7%BA%A6%E6%B5%81%E7%A8%8B%EF%BC%88%E5%85%A8%E9%93%BE%E8%B7%AF%EF%BC%89.jpg" alt="支付宝代扣签约流程（全链路）"></p><h2 id="技术方案-1"><a href="#技术方案-1" class="headerlink" title="技术方案"></a>技术方案</h2><p>通过thrift文件声明一个子商户对象，其中包含若干字段。通过thrift文件生成工具导出为java文件，给上游提供SDK。</p><p>在开发过程中，涉及签约接口的部分，要将新添加的字段封装到reqMap中，为请求下游数据封装做铺垫。</p><h3 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h3><h4 id="为什么要用RPC框架？"><a href="#为什么要用RPC框架？" class="headerlink" title="为什么要用RPC框架？"></a>为什么要用RPC框架？</h4><p>对于RPC的解释：</p><blockquote><p>RPC为远程调用服务，调用远端的服务的就像直接在本地调用，本质上来说是一种c/s服务。</p></blockquote><p>在c/s架构服务中，分布式系统采用http通信和采用RPC框架通信的对比分析：</p><ol><li>从网络资源消耗角度来说，如果业务量庞大，需要反复握手，会有额外的网络开销，RPC框架可以选择合适的通信协议，减少网络开销；</li><li>从代码开发角度来说，网络通信代码相对冗余，RPC可以类似本地调用一样，写起来简单方便；</li><li>RPC框架一般会有服务注册中心模块，通过该模块，可以实现服务的负载和故障迁移。</li></ol><h4 id="thrift的优势有哪些？"><a href="#thrift的优势有哪些？" class="headerlink" title="thrift的优势有哪些？"></a>thrift的优势有哪些？</h4><ol><li>提供了多种数据序列化方式,常用的binary、json数据序列化格式；</li><li>支持代码自动生成:可以根据thrift文件定义协议,然后自动生成客户端代码；</li><li>支持跨语言调用，公司内部使用多种语言，如java、php等，RPC框架可以考虑使用thrift。</li></ol><h1 id="DCEP"><a href="#DCEP" class="headerlink" title="DCEP"></a>DCEP</h1><h2 id="接口组织结构"><a href="#接口组织结构" class="headerlink" title="接口组织结构"></a>接口组织结构</h2><h3 id="基础服务接口"><a href="#基础服务接口" class="headerlink" title="基础服务接口"></a>基础服务接口</h3><p>基础服务接口包含支付、支付查询、退款、退款查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.meituan.pay.paygw.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IBaseService</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">pay</span><span class="hljs-params">(Map&lt;String, String&gt; reqMap)</span></span>;<br>    <br>    <span class="hljs-function">String <span class="hljs-title">payQuery</span><span class="hljs-params">(Map&lt;String, String&gt; reqMap)</span></span>;<br>    <br>    <span class="hljs-function">String <span class="hljs-title">refund</span><span class="hljs-params">(Map&lt;String, String&gt; reqMap)</span></span>;<br>    <br>    <span class="hljs-function">String <span class="hljs-title">refundQuery</span><span class="hljs-params">(Map&lt;String, String&gt; reqMap)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dcep通道当前扩展的子接口"><a href="#dcep通道当前扩展的子接口" class="headerlink" title="dcep通道当前扩展的子接口"></a>dcep通道当前扩展的子接口</h3><p>dcep扩展的子接口有：开通白名单、发红包、钱包开立状态查询、发红包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.meituan.pay.paygw.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAllowListService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IBaseService</span></span>&#123;<br>    <br>    <span class="hljs-function">AllowListRespVo <span class="hljs-title">supportAllowList</span><span class="hljs-params">(AllowListReqVo allowListReqVo, AllowListRespVo allowListRespVo)</span></span>;<br>    <br>    <span class="hljs-function">RedPctRespVo <span class="hljs-title">supportRedPct</span><span class="hljs-params">(RedPctReqVo redPctReqVo, RedPctRespVo respVo)</span></span>;<br>    <br>    <span class="hljs-function">WalletStateQueryRespVo <span class="hljs-title">walletStateQuery</span><span class="hljs-params">(WalletStateQueryReqVo walletStateQueryReqVo, WalletStateQueryRespVo respVo)</span></span>;<br>    <br>    <span class="hljs-function">RedPctQueryRespVo <span class="hljs-title">redPctQuery</span><span class="hljs-params">(RedPctQueryReqVo redPctQueryReqVo, RedPctQueryRespVo respVo)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="具体开发流程"><a href="#具体开发流程" class="headerlink" title="具体开发流程"></a>具体开发流程</h2><p>接口具体实现方法主要有三个步骤：</p><ol><li>组装上游参数</li><li>给下游发送请求并解析响应</li><li>构建响应信息返回给上游</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs java">  <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建红包余额返回参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> respStr</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> respVo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> payType</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RedPctQueryRespVo <span class="hljs-title">buildRedPctQueryRes</span><span class="hljs-params">(String respStr, RedPctQueryRespVo respVo, String payType)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TokenRedPctQueryResp resp = dcepPsbcConfig.parsePsbcCommonRtn(respStr, TokenRedPctQueryResp.class, payType);<br>        <span class="hljs-keyword">if</span> (resp == <span class="hljs-keyword">null</span> || resp.getHead() == <span class="hljs-keyword">null</span> || resp.getBody() ==<span class="hljs-keyword">null</span>)  &#123;<br>            log.error(<span class="hljs-string">&quot;buildRedPctQueryRes error resp is null&quot;</span>);<br>            respVo.response.setErrorCode(ErrorCodeConfig.PAYGATE_COMMON_ERR);<br>            <span class="hljs-keyword">return</span> respVo;<br>        &#125;<br>        logHandler.logBankInter(<span class="hljs-string">&quot;dcep psbc buildRedPctQueryRes response:&quot;</span> + JacksonUtil.toJson(resp));<br>        <br>        String respCode = resp.getBody().getRespCode();<br>        String respMsg = resp.getBody().getRespMsg();<br>        String outNo = resp.getBody().getBusiMainId();<br>        <span class="hljs-keyword">if</span> (BANK_RESP_OK.equalsIgnoreCase(respCode)) &#123;<br>            respVo.setOutNo(outNo);<br>            List&lt;PsbcRedPctActInfo&gt; redPctActInfoList = resp.getBody().getRedpctActInfoList();<br>            List&lt;Object&gt; objectList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (PsbcRedPctActInfo item : redPctActInfoList) &#123;<br>                RedPctActInfo redPctActInfo = <span class="hljs-keyword">new</span> RedPctActInfo();<br>                redPctActInfo.setRedPctActNo(item.getRedpctActNo());<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;#.##&quot;</span>.equals(item.getRedpctActBal()) &amp;&amp; StringUtils.isNotBlank(item.getRedpctActBal())) &#123;<br>                    redPctActInfo.setRedPctActBal(AmountUtils.y2fLong(item.getRedpctActBal()) + <span class="hljs-string">&quot;&quot;</span>);<br>                &#125;<br>                redPctActInfo.setRedPctActCode(item.getRedpctActCode());<br>                redPctActInfo.setRedPctActMsg(item.getRedpctActMsg());<br>                objectList.add(redPctActInfo);<br>            &#125;<br>            List&lt;RedPctActInfo&gt; redpctActInfoList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (Object item: objectList) &#123;<br>                redpctActInfoList.add((RedPctActInfo) item);<br>            &#125;<br>            respVo.setRedPctActInfoList(redpctActInfoList);<br>            respVo.response.setSuccess(<span class="hljs-keyword">true</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            respVo.response.setSuccess(<span class="hljs-keyword">false</span>);<br>            String gwRtnCode = <span class="hljs-keyword">this</span>.bankCodeToGwRtnCode(respCode, RedPctQueryRespVo.class);<br>            respVo.response.setErrorCode(gwRtnCode);<br>            respVo.response.setErrorMsg(respMsg);<br>            respVo.response.setThirdErrorCode(respCode);<br>            respVo.response.setThirdErrorMsg(respMsg);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;buildRedPctQueryRes error: &#123;&#125;&quot;</span>, ExceptionUtils.getStackTrace(e));<br>        respVo.response.setErrorCode(ErrorCodeConfig.PAYGATE_COMMON_ERR);<br>    &#125;<br>    <span class="hljs-keyword">return</span> respVo;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 构建红包余额请求参数</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> PreSendException</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, String&gt; <span class="hljs-title">buildRedPctQueryParams</span><span class="hljs-params">(RedPctQueryReqVo redPctQueryReqVo)</span> <span class="hljs-keyword">throws</span> PreSendException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 组装参数</span><br>        TokenRedPctQueryReq req = <span class="hljs-keyword">new</span> TokenRedPctQueryReq();<br>        TokenRedPctQueryReq.Head head = req.<span class="hljs-function">new <span class="hljs-title">Head</span><span class="hljs-params">()</span></span>;<br>        head.setPartnerTxSriNo(fmt.format(<span class="hljs-keyword">new</span> Date())+LeafIdGenUtil.getIdByDigit(Config.LEAF_ID,<span class="hljs-number">10</span>));<br>        head.setMethod(dcepPsbcConfig.RED_PCT_QUERY_METHOD);<br>        head.setVersion(dcepPsbcConfig.VERSION);<br>        head.setMerchantId(MtConfigUtils.getMccVal(dcepPsbcConfig.MERCHANT_ID));<br>        head.setAppID(MtConfigUtils.getMccVal(dcepPsbcConfig.APP_ID));<br>        head.setReqTime(fmt.format(<span class="hljs-keyword">new</span> Date()));<br>        head.setAccessType(dcepPsbcConfig.ACCESS_TYPE);<br>        head.setReserve(<span class="hljs-string">&quot;&quot;</span>);<br>        req.setHead(head);<br><br>        TokenRedPctQueryReq.Body body = req.n<span class="hljs-function">ew <span class="hljs-title">Body</span><span class="hljs-params">()</span></span>;<br>        body.setBusiMainId(redPctQueryReqVo.getOutNo());<br>        body.setReqTransTime(fmt.format(<span class="hljs-keyword">new</span> Date()));<br>        body.setPhone(redPctQueryReqVo.getUserCellphone());<br>        List&lt;RedPctActInfo&gt; redPctActInfoList = redPctQueryReqVo.getRedPctActInfoList();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == redPctActInfoList || redPctActInfoList.isEmpty() || StringUtils.isBlank(redPctActInfoList.get(<span class="hljs-number">0</span>).getRedPctActNo())) &#123;<br>            log.error(<span class="hljs-string">&quot;RedPctActNo can&#x27;t be empty&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PreSendException(ErrorCodeConfig.ILLEGAL_ARGUMENT);<br>        &#125;<br>        List&lt;String&gt; redpctActList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (RedPctActInfo item: redPctActInfoList) &#123;<br>            redpctActList.add(item.getRedPctActNo());<br>        &#125;<br>        body.setRedpctActList(redpctActList);<br>        body.setWltId(MtConfigUtils.getMccVal(DcepPsbcConfig.WltId));<br>        req.setBody(body);<br><br>        <span class="hljs-keyword">return</span> dcepPsbcConfig.assemblePsbcCommonReq(req, redPctQueryReqVo.getPayType()+<span class="hljs-string">&quot;&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (PreSendException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;buildWalletStateQueryParams error :&#123;&#125;&quot;</span>, ExceptionUtils.getStackTrace(e));<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PreSendException(ErrorCodeConfig.ILLEGAL_ARGUMENT);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">doPostWithContentType</span><span class="hljs-params">(String urlStr, String reqContent, <span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> socketTimeout, String encoding)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    StringBuilder resStr = <span class="hljs-keyword">new</span> StringBuilder();<br>    BufferedReader in = <span class="hljs-keyword">null</span>;<br>    HttpURLConnection connection = <span class="hljs-keyword">null</span>;<br>    HttpsURLConnection connections = <span class="hljs-keyword">null</span>;<br>    OutputStream out = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> isOnline = CommonConfig.isOnline();<br><br>    <span class="hljs-comment">//设置信任所有站点证书</span><br>    trustAllHosts();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        URL url = <span class="hljs-keyword">new</span> URL(urlStr);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;https&quot;</span>.equals(urlStr.substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)))&#123;<br>            <span class="hljs-comment">//https</span><br>            connections = (HttpsURLConnection) url.openConnection();<br>            connections.setConnectTimeout(connectTimeout);<br>            connections.setReadTimeout(socketTimeout);<br>            connections.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>            connections.setDoOutput(<span class="hljs-keyword">true</span>);<br>            connections.setRequestProperty(<span class="hljs-string">&quot;accept&quot;</span>, <span class="hljs-string">&quot;*/*&quot;</span>);<br>            connections.setRequestProperty(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>            connections.setRequestProperty(<span class="hljs-string">&quot;Content-Length&quot;</span>, reqContent.length()+<span class="hljs-string">&quot;&quot;</span>);<br>            <span class="hljs-comment">//服务端站点证书与域名不匹配时需要设置不校验域名</span><br>            connections.setHostnameVerifier(<span class="hljs-keyword">new</span> MyHostnameVerifier());<br><br>            logger.info(<span class="hljs-string">&quot;https connecting...&quot;</span>);<br>            connections.connect();<br>            logger.info(<span class="hljs-string">&quot;https connected!&quot;</span>);<br><br>            out = connections.getOutputStream();<br>            out.write(reqContent.getBytes(encoding));<br><br>            String httpCode = Integer.toString(connections.getResponseCode());<br>            logger.info(<span class="hljs-string">&quot;httpCode:&#123;&#125;&quot;</span>,httpCode);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;200&quot;</span>.equals(httpCode)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;HTTPS通信失败:&quot;</span> + httpCode);<br>            &#125;<br>            <span class="hljs-comment">//</span><br>            in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(connections.getInputStream(), encoding));<br>            String line;<br>            <span class="hljs-keyword">while</span>((line = in.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                resStr.append(line).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//http</span><br>            connection = (HttpURLConnection) url.openConnection();<br>            connection.setConnectTimeout(connectTimeout);<br>            connection.setReadTimeout(socketTimeout);<br>            connection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>            connection.setDoOutput(<span class="hljs-keyword">true</span>);<br>            connection.setRequestProperty(<span class="hljs-string">&quot;accept&quot;</span>, <span class="hljs-string">&quot;*/*&quot;</span>);<br>            connection.setRequestProperty(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>            connection.setRequestProperty(<span class="hljs-string">&quot;Content-Length&quot;</span>, reqContent.length()+<span class="hljs-string">&quot;&quot;</span>);<br><br>            logger.info(<span class="hljs-string">&quot;http connecting...&quot;</span>);<br>            connection.connect();<br>            logger.info(<span class="hljs-string">&quot;http connected!&quot;</span>);<br><br>            out = connection.getOutputStream();<br>            out.write(reqContent.getBytes(encoding));<br><br>            String httpCode = Integer.toString(connection.getResponseCode());<br>            logger.info(<span class="hljs-string">&quot;httpCode:&#123;&#125;&quot;</span>,httpCode);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;200&quot;</span>.equals(httpCode)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;HTTP通信失败:&quot;</span> + httpCode);<br>            &#125;<br>            <span class="hljs-comment">//</span><br>            in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(connection.getInputStream(), encoding));<br>            String line;<br>            <span class="hljs-keyword">while</span>((line = in.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                resStr.append(line).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(out != <span class="hljs-keyword">null</span>) &#123;<br>                out.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(connection != <span class="hljs-keyword">null</span>) &#123;<br>                connection.disconnect();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(connections != <span class="hljs-keyword">null</span>) &#123;<br>                connections.disconnect();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(in != <span class="hljs-keyword">null</span>) &#123;<br>                in.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            out = <span class="hljs-keyword">null</span>;<br>            in = <span class="hljs-keyword">null</span>;<br>            connection = <span class="hljs-keyword">null</span>;<br>            logger.error(<span class="hljs-string">&quot;exception while sendByHttps/Http:&quot;</span> + e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resStr.toString();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 构建红包余额返回参数</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> respStr</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> respVo</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> payType</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RedPctQueryRespVo <span class="hljs-title">buildRedPctQueryRes</span><span class="hljs-params">(String respStr, RedPctQueryRespVo respVo, String payType)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TokenRedPctQueryResp resp = dcepPsbcConfig.parsePsbcCommonRtn(respStr, TokenRedPctQueryResp.class, payType);<br>        <span class="hljs-keyword">if</span> (resp == <span class="hljs-keyword">null</span> || resp.getHead() == <span class="hljs-keyword">null</span> || resp.getBody() ==<span class="hljs-keyword">null</span>)  &#123;<br>            log.error(<span class="hljs-string">&quot;buildRedPctQueryRes error resp is null&quot;</span>);<br>            respVo.response.setErrorCode(ErrorCodeConfig.PAYGATE_COMMON_ERR);<br>            <span class="hljs-keyword">return</span> respVo;<br>        &#125;<br>        logHandler.logBankInter(<span class="hljs-string">&quot;dcep psbc buildRedPctQueryRes response:&quot;</span> + JacksonUtil.toJson(resp));<br><br>        String respCode = resp.getBody().getRespCode();<br>        String respMsg = resp.getBody().getRespMsg();<br>        String outNo = resp.getBody().getBusiMainId();<br>        <span class="hljs-keyword">if</span> (BANK_RESP_OK.equalsIgnoreCase(respCode)) &#123;<br>            respVo.setOutNo(outNo);<br>            List&lt;PsbcRedPctActInfo&gt; redPctActInfoList = resp.getBody().getRedpctActInfoList();<br>            List&lt;Object&gt; objectList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (PsbcRedPctActInfo item : redPctActInfoList) &#123;<br>                RedPctActInfo redPctActInfo = <span class="hljs-keyword">new</span> RedPctActInfo();<br>                redPctActInfo.setRedPctActNo(item.getRedpctActNo());<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;#.##&quot;</span>.equals(item.getRedpctActBal()) &amp;&amp; StringUtils.isNotBlank(item.getRedpctActBal())) &#123;<br>                    redPctActInfo.setRedPctActBal(AmountUtils.y2fLong(item.getRedpctActBal()) + <span class="hljs-string">&quot;&quot;</span>);<br>                &#125;<br>                redPctActInfo.setRedPctActCode(item.getRedpctActCode());<br>                redPctActInfo.setRedPctActMsg(item.getRedpctActMsg());<br>                objectList.add(redPctActInfo);<br>            &#125;<br>            List&lt;RedPctActInfo&gt; redpctActInfoList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (Object item: objectList) &#123;<br>                redpctActInfoList.add((RedPctActInfo) item);<br>            &#125;<br>            respVo.setRedPctActInfoList(redpctActInfoList);<br>            respVo.response.setSuccess(<span class="hljs-keyword">true</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            respVo.response.setSuccess(<span class="hljs-keyword">false</span>);<br>            String gwRtnCode = <span class="hljs-keyword">this</span>.bankCodeToGwRtnCode(respCode, RedPctQueryRespVo.class);<br>            respVo.response.setErrorCode(gwRtnCode);<br>            respVo.response.setErrorMsg(respMsg);<br>            respVo.response.setThirdErrorCode(respCode);<br>            respVo.response.setThirdErrorMsg(respMsg);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;buildRedPctQueryRes error: &#123;&#125;&quot;</span>, ExceptionUtils.getStackTrace(e));<br>        respVo.response.setErrorCode(ErrorCodeConfig.PAYGATE_COMMON_ERR);<br>    &#125;<br>    <span class="hljs-keyword">return</span> respVo;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="DCEP全链路梳理"><a href="#DCEP全链路梳理" class="headerlink" title="DCEP全链路梳理"></a>DCEP全链路梳理</h2><h3 id="网关接口调用关系"><a href="#网关接口调用关系" class="headerlink" title="网关接口调用关系"></a>网关接口调用关系</h3><p><img src="/img/2021/dcep%E7%BB%91%E5%AE%9A%E8%A7%A3%E7%BB%91%E6%B5%81%E7%A8%8B.jpg" alt="dcep绑定解绑流程"></p><p><img src="/img/2021/dcep%E6%94%AF%E4%BB%98%E9%80%80%E6%AC%BE%E6%B5%81%E7%A8%8B.jpg" alt="dcep支付退款流程"></p><p><img src="/img/2021/dcep%E8%B4%A6%E5%8D%95%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="dcep账单处理流程"></p><h1 id="网关新平台建设"><a href="#网关新平台建设" class="headerlink" title="网关新平台建设"></a>网关新平台建设</h1><h2 id="需求点"><a href="#需求点" class="headerlink" title="需求点"></a>需求点</h2><ol><li>工具类：JSON格式校验，拼接JSON</li><li>分页查询</li><li>页面迁移</li></ol><h2 id="前后端交互流程"><a href="#前后端交互流程" class="headerlink" title="前后端交互流程"></a>前后端交互流程</h2><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><p>MySQL读写分离，索引，最左匹配原则。</p><h3 id="Spring-MVC原理"><a href="#Spring-MVC原理" class="headerlink" title="Spring MVC原理"></a>Spring MVC原理</h3><p>从Spring MVC原理出发，解释页面迁移的过程。</p><h1 id="技术细节梳理"><a href="#技术细节梳理" class="headerlink" title="技术细节梳理"></a>技术细节梳理</h1><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><h3 id="dcep"><a href="#dcep" class="headerlink" title="dcep"></a>dcep</h3><ol><li>生成sm4key并对明文用sm4key对称加密</li><li>使用sm2对sm4key和publickey进行加密得到加密的sm4key</li><li>将加密请求报文和加密sm4key拼装成传输报文，再用私钥进行加密</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-线程池</title>
    <link href="/2021/08/01/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2021/08/01/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><h3 id="线程池是干什么的？"><a href="#线程池是干什么的？" class="headerlink" title="线程池是干什么的？"></a>线程池是干什么的？</h3><p>线程池的本质是<strong>对任务和线程进行解耦和管理</strong>，减少在线程创建、销毁、调度等过程中的开销。</p><ol><li>每次new Thread新建对象性能差。 </li><li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 </li><li>缺乏更多功能，如定时执行、定期执行、线程中断。</li></ol><p>相比new Thread，线程池的好处在于：</p><ol><li>重用存在的线程，减少对象创建、消亡的开销，性能佳。 </li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 </li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="对于继承关系的解释"><a href="#对于继承关系的解释" class="headerlink" title="对于继承关系的解释"></a>对于继承关系的解释</h3><ol><li>顶层接口``Executor`提供了一种思想：将任务提交和任务执行进行解耦。</li><li><code>ExecutorService</code>接口增加了一些能力：<ul><li>扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法</li><li>提供了管控线程池的方法，比如停止线程池的运行</li></ul></li><li><code>AbstractExecutorService</code>将执行流程进行串联，保证下层的实现只需关注一个执行任务的方法即可。</li><li><code>ThreadPoolExecutor</code>实现最复杂的运行部分，一方面维护自身的生命周期，另一方面同时管理线程和任务。</li></ol><p><img src="/img/2021/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="线程池接口继承关系"></p><h3 id="线程池的运行机制"><a href="#线程池的运行机制" class="headerlink" title="线程池的运行机制"></a>线程池的运行机制</h3><p>线程池内部是一个生产者消费者模型，将线程和任务解耦。线程池的运行包含两个部分：任务管理、线程管理。任务管理扮演生产者角色，线程管理扮演消费者角色。当任务提交后，后续流转为：1、直接申请线程执行该任务；2、缓冲到队列中等待线程执行；3、拒绝该任务。</p><p><img src="/img/2021/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="线程池的运行流程"></p><h2 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h2><p>线程池内线程的运行状态（runState）和线程数量（workerCount）由一个变量进行管理，高3位保存runState，低29位保存workCount。</p><p>运行状态：</p><ul><li>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务；</li><li>SHUTDOWN：关闭状态，不再接受新提交的任务，但可以处理阻塞队列中的任务</li><li>STOP：不接受新任务，也不处理阻塞队列中的任务</li><li>TIDYING：所有任务都已经终止，workerCount=0</li><li>TERMINATED：在terminated()方法执行完进入该状态</li></ul><p><img src="/img/2021/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程池生命周期"></p><h2 id="对任务的管理"><a href="#对任务的管理" class="headerlink" title="对任务的管理"></a>对任务的管理</h2><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>通过阻塞队列对任务进行管理。线程池对任务的管理的本质在于通过队列进行缓冲。</p><p><img src="/img/2021/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="线程池阻塞队列"></p><h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>任务执行有两种情况，一种是新创建线程执行任务，另一种是从阻塞队列中拿任务执行。前者用于初始化线程的时候，小于corePoolSize和workCount &lt; maximumPoolSize &amp;&amp; BlockQueue队满的时候。一般都是发生在第二种case。</p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><ol><li>丢弃任务并抛出异常</li><li>丢弃任务但不抛异常</li><li>丢弃队列最前面的任务，然后把新任务加到阻塞队列中</li><li>将任务交给main线程处理</li></ol><h2 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h2><p>worker线程继承AQS，但并非ReentrantLock，原因在于使用不可重入反应线程当前执行状态。 </p><h3 id="worker线程的构造方法"><a href="#worker线程的构造方法" class="headerlink" title="worker线程的构造方法"></a>worker线程的构造方法</h3><p>worker线程通过firstTask进行构造，firstTask可以有也可以没有，非空对应核心线程创建，空对应非核心线程创建。</p><h3 id="线程增加"><a href="#线程增加" class="headerlink" title="线程增加"></a>线程增加</h3><p>通过addWorker方法实现，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程。该方法只是新增一个线程，返回成功结果。</p><!--上个阶段是指？--><h3 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h3><p>线程回收是通过jvm的。</p><p>jvm的回收策略涉及对被回收对象的引用，而线程池做的就是保持对工作线程的引用。</p><p>worker被创建之后，分为核心线程和非核心线程。前者可以无限等待任务，后者需要限时获取任务。</p><p>worker获取不到任务的时候，就会消除对线程的引用，等待被回收。</p><blockquote><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p></blockquote><h3 id="worker线程执行任务过程"><a href="#worker线程执行任务过程" class="headerlink" title="worker线程执行任务过程"></a>worker线程执行任务过程</h3><p>通过runWorker方法执行任务，具体过程为，</p><ol><li>while循环不断通过getTast获取任务</li><li></li></ol><h2 id="Java的几种线程池"><a href="#Java的几种线程池" class="headerlink" title="Java的几种线程池"></a>Java的几种线程池</h2><p>type:</p><ol><li>newCachedThreadPool</li><li>newFixedThreadPool</li><li>newScheduledThreadPool</li><li>newSingleThreadExecutor</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="入参解释"><a href="#入参解释" class="headerlink" title="入参解释"></a>入参解释</h3><ol><li>corePoolSize</li><li>maximumPoolSize</li><li>keepAliveTime：空闲线程存活时间</li><li>unit: 空闲线程存活时间单位</li><li>workQueue：工作队列<ul><li>ArrayBlockQueue</li><li>LinkedBlokingQueue</li><li>SynchronousQueue</li><li>PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂</li><li>handler：拒绝策略</li></ol><p>核心知识点：AQS、BlockingQueue</p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-volatile关键字</title>
    <link href="/2021/08/01/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/08/01/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h2><p>volatile能保证可见性和有序性，以及单次读写的原子性。</p><p>volatile是修饰变量的。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="可见性的实现原理"><a href="#可见性的实现原理" class="headerlink" title="可见性的实现原理"></a>可见性的实现原理</h3><p>volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现。</p><blockquote><p>内存屏障，又称内存栅栏，是一个 CPU 指令（lock前缀指令）。</p></blockquote><p>如果对声明了 volatile 的变量进行<strong>写操作</strong>，JVM 就会向处理器发送一条 <strong>lock 前缀</strong>的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li></ul><p>不同cpu缓存一致性的保证：</p><p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p><img src="/img/2021/volatile%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E7%90%86.png" alt="volatile可见性原理"></p><h3 id="有序性的实现原理"><a href="#有序性的实现原理" class="headerlink" title="有序性的实现原理"></a>有序性的实现原理</h3><p>volatile变量的有序性是基于Happens-Before原则实现的。</p><blockquote><p> volatile变量的写happens before volatile变量的读。</p></blockquote><p>利用JMM 提供的内存屏障阻止重排序</p><table><thead><tr><th><strong>内存屏障</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-synchronized关键字</title>
    <link href="/2021/08/01/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%20ReentrantLock/"/>
    <url>/2021/08/01/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%20ReentrantLock/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-synchronized关键字</title>
    <link href="/2021/08/01/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/08/01/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h2><p>synchronized可以锁对象，也可以锁一个类。</p><h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3><p>对象锁包括方法锁（默认锁对象为this，当前实例对象）和同步代码块锁（用户指定锁对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence); <span class="hljs-comment">// 两个线程抢同一个对象资源</span><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">我是线程Thread-0</span><br><span class="hljs-comment">Thread-0结束</span><br><span class="hljs-comment">我是线程Thread-1</span><br><span class="hljs-comment">Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//指定锁的对象，然后接一个同步代码块，</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br>    <span class="hljs-comment">// 创建2把锁</span><br>    Object block1 = <span class="hljs-keyword">new</span> Object();<br>    Object block2 = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span><br>        <span class="hljs-keyword">synchronized</span> (block1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (block2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*输出：</span><br><span class="hljs-comment">block1锁,我是线程Thread-0</span><br><span class="hljs-comment">block1锁,Thread-0结束</span><br><span class="hljs-comment">block2锁,我是线程Thread-0　　// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把</span><br><span class="hljs-comment">block1锁,我是线程Thread-1</span><br><span class="hljs-comment">block2锁,Thread-0结束</span><br><span class="hljs-comment">block1锁,Thread-1结束</span><br><span class="hljs-comment">block2锁,我是线程Thread-1</span><br><span class="hljs-comment">block2锁,Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//锁方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        method();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h3><p>锁静态方法或直接锁类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence1 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence2 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        method();<br>    &#125;<br><br>    <span class="hljs-comment">// synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence1);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence2);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">我是线程Thread-0</span><br><span class="hljs-comment">Thread-0结束</span><br><span class="hljs-comment">我是线程Thread-1</span><br><span class="hljs-comment">Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 锁类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence1 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence2 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 所有线程需要的锁都是同一把</span><br>        <span class="hljs-keyword">synchronized</span>(SynchronizedObjectLock.class)&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence1);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence2);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*输出：</span><br><span class="hljs-comment">我是线程Thread-0</span><br><span class="hljs-comment">Thread-0结束</span><br><span class="hljs-comment">我是线程Thread-1</span><br><span class="hljs-comment">Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="synchronized的原理"><a href="#synchronized的原理" class="headerlink" title="synchronized的原理"></a>synchronized的原理</h2><h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p>synchronized的底层是使用操作系统的mutex lock实现的。</p><!--mutex lock是什么？--><blockquote><p>锁的内存语义是指：1、当线程释放锁时，JMM会把线程对应的本地内存中的共享变量刷到主存中；2、当线程获取锁时，JMM把线程的本地内存置为无效，从而使moter监视的临界区代码需要到主寸读取共享变量。</p></blockquote><p>可见性的保证：一个共享变量执行lock操作会清空工作内存中改变量的值，使用前从主存load该变量的值。一个共享变量执行unlock操作前，把该变量的值write到主存中。</p><p>原子性的保证：持有同一个锁的两个同步代码块只能串行执行。</p><h3 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h3><p>结合synchronized的使用，这一部分涉及两个问题，一个是java如何实现代码块的同步的，另一个是synchronized如何实现线程对对象锁的持有和释放的。</p><p>第一个问题：</p><p>代码块和方法同步的实现原理：在JVM层面，是通过进入和退出monitor对象来实现的。通过在代码块开始和结束的地方加入monitorentor 和 monitorexit指令进行标识，当执行到monitorentor的时候，如果该对象没有被锁定或者该线程之前就具有该对象的锁，则锁计数器+1，当执行到monitorexit时，要对锁计数器-1，当锁计数器为0时，该线程释放对该对象的锁。</p><p>第二个问题：</p><p>synchronized用的锁存在对象头里。这个锁——监视器锁（Monitor）本质是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。</p><blockquote><p> 互斥锁的作用在于：用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。</p></blockquote><p>互斥锁的工作方式：</p><p><img src="/img/2021/mutex%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.jpeg" alt="mutex工作方式"></p><p>线程A获取对象的锁后，线程B如果再申请对象的锁，会进行自旋，直到A释放锁对象，B才能获取对象锁。</p><p>该过程涉及线程的阻塞和唤醒，在os层面对象用户态到核心态的转换，开销很大。因此在java1.6，对锁进行了优化。</p><h3 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h3><p>锁信息在java对象头的MarkWord里。</p><p><img src="/img/2021/java%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpeg" alt="java对象头"></p><h2 id="JVM锁优化"><a href="#JVM锁优化" class="headerlink" title="JVM锁优化"></a>JVM锁优化</h2><p>当程序初次进入synchronized代码块的时候，对象头里的锁状态由<strong>无锁</strong>转换为偏向锁。<strong>偏向锁</strong>表现为同一线程可重入（Mark Word里存有线程ID）。</p><p>当存在锁竞争时，偏向锁升级为<strong>自旋锁</strong>（轻量级锁）。</p><blockquote><p>偏向锁相对自旋锁只有一次CAS操作，效率极高。而自旋锁存在“忙等”，涉及多次CAS操作。</p></blockquote><p>当锁竞争严重时（自旋次数超过阈值），自旋锁将再次升级为<strong>重量级锁</strong>。</p><p><img src="/img/2021/%E9%94%81%E5%8D%87%E7%BA%A7.png" alt="锁升级"></p><p>在整个获得锁和释放锁的过程中，通过CAS操作修改对象头里的锁标志位。</p><blockquote><p>CAS是一种能够实现变量同步无锁算法。该算法涉及三个操作数，需要读写的内存值V。进行比较的值A（工作内存对主存V的拷贝副本），和要写入的新值B。当且仅当V = A时，CAS用B来更新V，否则不执行任何操作。</p><p>CAS存在的问题：ABA问题、自旋忙等、只能保证一个共享变量的原子操作。</p></blockquote><p><strong>锁粗化</strong>：当JVM检测到连续几条加锁和释放锁的操作，会对锁进行粗话，在更大范围内进行加锁和释放锁。</p><p><strong>锁消除</strong>：代码层面要求同步，但数据层面不涉及竞争，会删除不必要的加锁操作。</p><h2 id="synchronized与Lock"><a href="#synchronized与Lock" class="headerlink" title="synchronized与Lock"></a>synchronized与Lock</h2><p>synchronized和Lock的区别：</p><table><thead><tr><th></th><th>synchronized</th><th>Lock</th></tr></thead><tbody><tr><td>实现层面</td><td>Java关键字，在JVM层面实现加锁和解锁。</td><td>Lock时一个接口，在代码层面实现的加锁和解锁。</td></tr><tr><td>作用范围</td><td>代码块、方法上</td><td>代码块</td></tr><tr><td>释放锁的时机</td><td>异常时自动释放锁</td><td>需要在finally显示释放锁，不会自动释放</td></tr><tr><td>持有锁时间</td><td>线程拿不到锁一直自旋等待</td><td>可以设置超时时间</td></tr><tr><td>获取锁判断</td><td>不知道是否获取锁</td><td>可以通过tryLock进行判断</td></tr><tr><td>公平性</td><td>非公平</td><td>公平 / 非公平</td></tr><tr><td>中断</td><td>不可中断</td><td>可中断</td></tr></tbody></table><p>synchronized和ReentrantLock的对比：</p><table><thead><tr><th></th><th>synchronized</th><th>ReentrantLock</th></tr></thead><tbody><tr><td>锁实现机制</td><td>monitor机制（mutex lock）</td><td>依赖AQS</td></tr><tr><td>锁释放</td><td>自动释放</td><td>显示释放</td></tr><tr><td>锁类型</td><td>非公平锁</td><td>公平 / 非公平</td></tr><tr><td>条件队列</td><td>关联一个条件队列</td><td>关联多个条件队列</td></tr><tr><td>可重入性</td><td>可重入</td><td>可重入</td></tr><tr><td>灵活性</td><td>差</td><td>支持响应中断、超时、尝试获取锁</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程</title>
    <link href="/2021/07/31/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/07/31/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="并发三要素"><a href="#并发三要素" class="headerlink" title="并发三要素"></a>并发三要素</h2><p>Java并发的三要素：可见性、原子性、有序性。线程不安全即这三个性质有至少一个被破坏了。</p><p>这三个要素分别是什么意思？分别由什么来保障的？即这个东西没有保障才导致的现成安全问题。</p><p>接下来，我们先来介绍这三个要素是什么，然后说明是什么最终导致了这三个要素的破坏，进而使线程不安全。最后，再来说Java是如何保证线程安全的。</p><p>可见性：一个线程对共享变量的修改，别的线程立即可见。</p><blockquote><p>立即可见是说，不同的线程对应不同的cpu去使用共享变量去做运算，而共享变量是放在主存里的，所有线程对共享变量进行操作改变其值，都要写回主存，让其他线程可见。<br>这意味着，如果一个线程对共享变量的修改没有及时写回主存，让其他线程看到，而其他线程用了共享变量的旧值做了运算，就违背了可见性。</p></blockquote><p>在计算机中，可见性的破坏是由什么导致的呢？<br>答案是cpu缓存！<br>以下面代码为例，对于多线程编程，如果thread1使用的是cpu1，thread2使用的是cpu2，当thread1执行<code>i=10</code>时，计算机做的是把i的初始值先加载到cpu1的高速缓存中，然后再赋值为10，再写回主存。而如果thread2把i的值加载到它的高速缓存发生在cpu1把<code>i=10</code>写回主存之前，那j的值就还是0.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程1执行的代码</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>i = <span class="hljs-number">10</span>;<br> <br><span class="hljs-comment">//线程2执行的代码</span><br>j = i;<br></code></pre></td></tr></table></figure><p>原子性：一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>以经典的转账问题为例：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。如果只进行了第一个步骤，而因为某些原因，没有执行第二个步骤，就破坏了原子性。</p><p>有序性：程序执行的顺序按照代码的先后顺序执行。<br>但是计算机为了提高执行性能，编译器和处理器会对指令进行重排序。这就间接导致内存可见性的问题。</p><blockquote><p>重排序分为编译器优化重排序、指令级并行重排序、内存系统重排序，第一个属于编译器重排序，后两个属于处理器重排序。</p></blockquote><p>Java是如何解决并发问题的？<br>通过Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。<br>具体的方法有：volatile、synchronized 和 final 三个关键字，Happens-Before 规则。<br>接下来具体来说分别是如何保证三要素的。</p><p>原子性的保证：是通过synchronized和Lock来保证原子性的。（synchronized和Lock能够保证任一时刻只有一个线程执行该代码块）<br>原子操作：读取、赋值（必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">x = <span class="hljs-number">10</span>;        <span class="hljs-comment">//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span><br>y = x;         <span class="hljs-comment">//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span><br>x++;           <span class="hljs-comment">//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span><br>x = x + <span class="hljs-number">1</span>;     <span class="hljs-comment">//语句4： 同语句3</span><br></code></pre></td></tr></table></figure><p>可见性的保证：volatile关键字（当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。）<br>通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><p>有序性的保证：volatile只能保证一部分的有序性。而synchronized和Lock可以完全保证有序性。JMM层面是通过Happens-Before规则保证有序性的。<br>❓❓❓Happens-Before和前几种方法有什么关系，它具体是怎么实现的？</p><p>共享变量按照安全强度分为五个安全级别：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。<br>不可变：如String类这种被final修饰过的数据类型。<br>绝对线程安全：不管运行时环境如何，调用者都不需要任何额外的同步措施。<br>相对线程安全：对象调用的时候不作同步措施，但在程序连续执行调用的顺序上，要通过同步手段（加锁）保证调用的正确性。<br>线程兼容：对象本身并非线程安全的，在调用的时候就要通过同步手段保证线程安全。</p><blockquote><p>线程安全的类：绝大多数平常使用的类，比如HashMap、StringBuilder等。<br>线程不安全的类：JUC包下的类，如NonCurrentHashMap，<br>线程对立： 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。（在代码中很少出现，略）</p></blockquote><p>线程安全的实现方法：<br>互斥同步：synchronized 和 ReentrantLock。</p><h2 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h2><p><img src="/img/2021/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程生命周期"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> DemoThread());<br></code></pre></td></tr></table></figure><p>创建线程基本就用这个方法。只是传参的时候，要传一个Runnable Target，用Thread创建线程，也是要重写Runnable接口的run方法。</p><blockquote><p>Thread和Runnable的关系：Thread类是Runnable接口的实现类。</p></blockquote><p>当然也可以自定义一个线程类，直接implements Runnable接口，@Override run方法。</p><h3 id="线程生命周期中的方法调用"><a href="#线程生命周期中的方法调用" class="headerlink" title="线程生命周期中的方法调用"></a>线程生命周期中的方法调用</h3><p>参考：<a href="https://www.cnblogs.com/paddix/p/5381958.html">https://www.cnblogs.com/paddix/p/5381958.html</a></p><p>wait、notify、sleep、yield、join</p><blockquote><p>wait和notify是Object的方法，sleep、yield、join是Thread类方法。</p></blockquote><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>wait是将当前运行的线程挂起（进入阻塞状态），知道notify来唤醒该线程。</p><p>wait方法是通过monitor对象来实现的。</p><p>wait方法的使用要放在同步范围内，即：在synchronized修饰的代码块内</p><h4 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify/notifyAll"></a>notify/notifyAll</h4><p>notify表示持有对象锁的线程准备释放对象锁权限。</p><blockquote><p>调用wait方法后，线程会释放对monitor对象的所有权；</p><p>一个通过wait方法阻塞的线程，必须同时满足以下两个条件才能被唤醒：</p><ol><li>需要超时唤醒或调用了notify/notifyAll方法</li><li>线程唤醒后竞争到锁（monitor）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWait</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;START-------&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            wait(<span class="hljs-number">0</span>); <span class="hljs-comment">// wait使用</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;END-------&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span>  Test test = <span class="hljs-keyword">new</span> Test();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    test.testWait();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (test) &#123;<br>            test.notify(); <span class="hljs-comment">// notify使用</span><br>        &#125;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        System.out.println(<span class="hljs-string">&quot;分割线------------&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (test) &#123;<br>            test.notifyAll(); <span class="hljs-comment">// notifyAll使用</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>sleep方法和wait方法功能类似，但是调用起来更简单。这是说，<strong>wait方法依赖于同步，而sleep方法可以直接调用</strong>。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>yield是暂停当前线程（将Running状态改为Runnable状态），以便其他线程有机会执行。</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join是父线程等待子线程执行完再执行，将异步执行的线程合并为同步执行。</p><p>join是通过wait方法将线程阻塞，如果join的线程还在执行，就把当前线程阻塞起来，直到join的线程执行完成，再执行当前线程。</p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-AQS</title>
    <link href="/2021/07/14/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-AQS/"/>
    <url>/2021/07/14/tech/JavaCE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-AQS/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="AQS（抽象队列同步器）"><a href="#AQS（抽象队列同步器）" class="headerlink" title="AQS（抽象队列同步器）"></a>AQS（抽象队列同步器）</h3><p>抽象队列同步器（AbstractQueuedSynchronizer）是一种构建锁和同步器的框架，如：ReentrantLock、Semaphore、ReentrantReadWriteLock、SynchronousQueue</p><h3 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h3><p>AQS的核心思想是：如果被请求的共享资源空闲，线程设为有效，共享资源设为锁定状态；如果被请求的共享资源被占用，需要一套线程阻塞等待以及被唤醒时锁分配的机制。</p><h3 id="AQS数据结构"><a href="#AQS数据结构" class="headerlink" title="AQS数据结构"></a>AQS数据结构</h3><p>AQS底层的数据结构是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。具体实现为：用双向链表实现的同步队列和用单向链表实现的条件队列。</p><p>同步队列是必须的，条件队列不是必须的，但当存在多个条件时，条件队列可以为多个。</p><h3 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h3><p>AQS有两种共享方式</p><ul><li>独占（Exclusive）：只有一个线程能执行，如ReentrantLock。独占锁又分为公平锁和非公平锁。<ul><li>公平锁：线程按照在队列中的顺序，先到先得锁；</li><li>非公平锁：无视队列顺序，谁抢到就是谁的。</li></ul></li><li>共享（share）：多个线程可同时执行，如ReadWriteLock、Semaphore</li></ul><blockquote><p>在实现上，非公平比公平只是多加了一个CAS操作的条件判断。</p></blockquote><h3 id="AQS底层设计模式"><a href="#AQS底层设计模式" class="headerlink" title="AQS底层设计模式"></a>AQS底层设计模式</h3><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-comment">// 模式，分为共享与独占</span><br>    <span class="hljs-comment">// 共享模式</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br>    <span class="hljs-comment">// 独占模式</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;        <br>    <span class="hljs-comment">// 结点状态</span><br>    <span class="hljs-comment">// CANCELLED，值为1，表示当前的线程被取消</span><br>    <span class="hljs-comment">// SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark</span><br>    <span class="hljs-comment">// CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中</span><br>    <span class="hljs-comment">// PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行</span><br>    <span class="hljs-comment">// 值为0，表示当前节点在sync队列中，等待着获取锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;        <br><br>    <span class="hljs-comment">// 结点状态</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;        <br>    <span class="hljs-comment">// 前驱结点</span><br>    <span class="hljs-keyword">volatile</span> Node prev;    <br>    <span class="hljs-comment">// 后继结点</span><br>    <span class="hljs-keyword">volatile</span> Node next;        <br>    <span class="hljs-comment">// 结点所对应的线程</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;        <br>    <span class="hljs-comment">// 下一个等待者</span><br>    Node nextWaiter;<br>    <br>    <span class="hljs-comment">// 结点是否在共享模式下等待</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取前驱结点，若前驱结点为空，抛出异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>        <span class="hljs-comment">// 保存前驱结点</span><br>        Node p = prev; <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 前驱结点为空，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 前驱结点不为空，返回</span><br>            <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 无参构造方法</span><br>    Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>        Node(Thread thread, Node mode) &#123;    <span class="hljs-comment">// Used by addWaiter</span><br>        <span class="hljs-keyword">this</span>.nextWaiter = mode;<br>        <span class="hljs-keyword">this</span>.thread = thread;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span><br>        <span class="hljs-keyword">this</span>.waitStatus = waitStatus;<br>        <span class="hljs-keyword">this</span>.thread = thread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ConditionObject类"><a href="#ConditionObject类" class="headerlink" title="ConditionObject类"></a>ConditionObject类</h3><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><h3 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h3><h3 id="核心方法——acquire方法"><a href="#核心方法——acquire方法" class="headerlink" title="核心方法——acquire方法"></a>核心方法——acquire方法</h3><p>该方法以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>首先，线程获取对象状态，看是否可以获得该对象的锁。</p><p>然后将线程封装成一个结点放到同步队列，不断尝试获取资源。</p><h3 id="核心方法——release方法"><a href="#核心方法——release方法" class="headerlink" title="核心方法——release方法"></a>核心方法——release方法</h3><p>以独占模式释放对象。</p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>情绪海洋</title>
    <link href="/2021/06/25/life/%E6%83%85%E7%BB%AA%E6%B5%B7%E6%B4%8B/"/>
    <url>/2021/06/25/life/%E6%83%85%E7%BB%AA%E6%B5%B7%E6%B4%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="情绪海洋"><a href="#情绪海洋" class="headerlink" title="情绪海洋"></a>情绪海洋</h1><h2 id="活着"><a href="#活着" class="headerlink" title="活着"></a>活着</h2><p>人怎么才算活着？</p><p>有点意义地讲，但又不上升到多高的价值，你是怎么觉得的？</p><p>最近看到一句话，引起了我的注意。</p><blockquote><p>“到目前为止，我仍很激动地活着。” —— 卢川纯</p></blockquote><p>我不知道对她来说，如果不能激动地活着，是否就意味着已经死去。我也不清楚，她是否认为，当她决定要激动地活着的时候，她才算真正开始活着。</p><p>激动在每个人的定义和理解的方式都可能是不同的，或者干脆把激动换成别的什么词，也不是不可以。</p><p>但我想无论你把它换成什么其他的词，在这个语义下，都逃不出情绪这个概念。</p><p>是的，我是说，人只有带着情绪的时候，才算是在活着。</p><h2 id="妖魔化的情绪"><a href="#妖魔化的情绪" class="headerlink" title="妖魔化的情绪"></a>妖魔化的情绪</h2><p>情绪是有主动和被动之分的，生命也是有主动选择地活着和被动牵引地活着。</p><p>事情本身不会有太明确的分割线，但直觉地判断是：</p><p>愤怒是主动的情绪，抱怨就是被动的情绪；<br>满足是主动的情绪，欲望就是被动的情绪；<br>快乐是主动的情绪，爽就是被动的情绪；</p><p>诸如此类……</p><p>不过在现在，情绪好像不是什么好的词。</p><p>正能量大行其道，情绪化就带有了贬义色彩。于是市面上出现了很多正能量满满的情绪管理类书籍。</p><p>这些书只是“术”的层面，还没到“道”的层面。</p><p>最烂的鸡汤文，直接告诉你不要这样，不要那样。讲了那么多白水文，还不如告诉读者直接把情绪发泄到最开始定义和传教“道德”的人身上。</p><p>稍微动了点脑子的作者，旨在告诉读者如何做一个聪明人，他来给你计算利益得失，让原本就愚钝的你在似乎的大彻大悟之后继续聪明不起来。</p><p>真正的情绪管理，不是去情绪化，而是尽可能由内而外地将被动的情绪转化为积极的情绪。毕竟这样修为出来的人，才是真实可爱的。</p><h2 id="情绪海洋-1"><a href="#情绪海洋-1" class="headerlink" title="情绪海洋"></a>情绪海洋</h2><p>一个偶然的灵感让我模拟了这样一个概念：</p><p>在我们的内心有一片情绪海洋，在没有外界往里注入刺激的时候，这片海洋对外表现出的是相对平和的无情绪化特质。</p><p>一个负能量的人内心的情绪海洋可能只是一湾小溪，外界稍一刺激，它表面下的泥土就开始翻土，它对外就开始表现的浑浊。</p><p>一个正能量的人内心的情绪海洋才真的是一片海洋，外界往里注入什么酸性碱性的溶液，都能在极短暂的时间内被中和，外界那些小事根本掀不起这片海洋的什么风浪来。</p><p>正能量人内心的海洋始终平静吗？</p><p>正能量人内心的情绪海洋总是暗涌，只有小溪那浅薄的表层才是真的平静。</p><p>因为小溪清晰与浑浊的太另我们清晰可见了，事实上，它里面什么都没有，涓涓细流，有什么？又容的下什么呢？</p><p>海洋虽然看起来让我们觉得平静，但在它的海平面之下却总是在涌动之中。因为它装载的泥泞实在太多了，可爱的海豚在里面，臭鱼烂虾也在里面，正是因为他内心的鲸鱼在不断地吞食这些鱼虾，他的海洋才能在日光的照射下如你所见的这般蔚蓝。</p><p>人们总是在向往着自由，却在追求自由的路上，发现痛苦才是人生的本质。</p><p>人们不想表现负面情绪，却在不断地自我和解中发现，只有消化掉大量的痛苦，才能呈现出表面的平和。</p><p>空是最高级的修行，无才是真正的没有穷尽。</p><p>人世间不允许你生来那般纯澈，死亦不能带你回归最初的本原。理想主义者只能高举他们手中的完美的旗帜，朝着太阳与大地的方向不断前行。</p>]]></content>
    
    
    <categories>
      
      <category>生活沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“毕业后我们会成为自己讨厌的样子吗？”｜B站——小苏对话罗翔</title>
    <link href="/2021/06/20/thought/%E2%80%9C%E6%AF%95%E4%B8%9A%E5%90%8E%E6%88%91%E4%BB%AC%E4%BC%9A%E6%88%90%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%AE%A8%E5%8E%8C%E7%9A%84%E6%A0%B7%E5%AD%90%E5%90%97%EF%BC%9F%E2%80%9D%EF%BD%9CB%E7%AB%99%E2%80%94%E2%80%94%E5%B0%8F%E8%8B%8F%E5%AF%B9%E8%AF%9D%E7%BD%97%E7%BF%94/"/>
    <url>/2021/06/20/thought/%E2%80%9C%E6%AF%95%E4%B8%9A%E5%90%8E%E6%88%91%E4%BB%AC%E4%BC%9A%E6%88%90%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%AE%A8%E5%8E%8C%E7%9A%84%E6%A0%B7%E5%AD%90%E5%90%97%EF%BC%9F%E2%80%9D%EF%BD%9CB%E7%AB%99%E2%80%94%E2%80%94%E5%B0%8F%E8%8B%8F%E5%AF%B9%E8%AF%9D%E7%BD%97%E7%BF%94/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1y64y167Sf">🔗 地址</a></p><ol><li><p>学生们进入社会需要具备的基本特质是：谦卑和尊重 </p><ul><li>人的本性就是骄傲和傲慢，人总是以自我为中心，这是人不快乐的根源。</li><li>一个真正谦卑（humble）的人才能发挥作为人最大的能力。</li></ul></li><li><p>一个人会被讨厌的特质是：傲慢和分裂</p><ul><li>我们无比的厌恶他人的傲慢，但我们却无比的放纵自己的傲慢。</li><li>我们随波逐流是因为我们的价值观是分裂的。</li><li>一个分裂的王国无法抵御仇敌，一个分裂的人生无法尊严的面对生命。</li><li>“一个开放的社会就像一张开放的嘴，在合起来的时候，一定要咬住某种坚实的东西。”    —— 切斯特顿</li></ul></li><li><p>讨厌自己的哪些特质：</p><ul><li>虚荣；虚伪；虚无</li><li>一个虚荣的人表现为虚伪，一个彻底虚伪的人的价值观是虚无主义，而虚无主义在逻辑上是不自洽的，虚无会让人痛苦，而且找不到人生的意义。</li></ul></li><li><p>圆滑算成熟吗？怎么看待成熟与天真的关系？</p><ul><li>我们的内心始终有刚硬的东西，这是我们无比坚守的东西，但是尊重别人，是一种同理心，我们需要学会把这种刚硬的东西磨的稍微圆润一点。</li></ul></li><li><p>校园和社会最大的改变？毕业生如何快速调整自己适应社会？</p><ul><li>大学是university，是要追求一种共向（unity）的价值观，同时要体现对多元（diversity）的尊重。</li><li>从学校步入社会，是理想与现实的碰撞。</li><li>美好是存在的，但正是因为美好的存在，我们才能容忍不美好的现实。因为如果你所生活的一切都是万般的美好，你也就感受不到美好了。</li></ul></li><li><p>考研的重要性大吗？</p><ul><li>人生唯一确定的事实就是不确定的人生。</li><li>人生就是在不断的后悔自己没有做另一个选择，因为无论如何选择，都没有想象中的那么美好。</li><li>这样一种不充分的存在，让我们不可能获得一种完美理性的选择，我们要接受这种有瑕疵的选择。</li><li>我们这一生中最大的智慧就是在一个不确定的世界中如何寻找到一种相对的确定性。</li><li>如果没有这种智慧，选择永远都是选项而已，我们还是要困扰在每天的焦虑之中。</li><li>只有枯死的叶子才会随波逐流，只有活着的东西才会与之抗争。心死为忙，在忙乱中我们忘记了自己还活着。</li></ul></li><li><p>如何看待终身学习与去能力化的工作之间的矛盾？</p><ul><li>人生中比拼的绝大多数不是高能，而是基础能力。最基础的能力是我们这个时代所最匮乏的。</li></ul></li><li><p>哲学家尼布尔曾说：“请赐予我胸怀，让我接受无法改变的事情。请赐予我勇气，让我去改变能够改变的事情。请赐予我智慧，让我分辨它们两者的不同。”</p><ul><li>古希腊哲学家艾比克泰德：“对于可控的事情我们要保持谨慎，对于不可控的事情我们要保持乐观。”</li></ul></li><li><p>如何看待很多人过的越来越功利？</p><ul><li>很多人都想过一个体面的一生，但问题在于，当你那些欲望满足的时候，你真的能够快乐吗？</li></ul></li><li><p>有多少可以自由支配的时间？</p><ul><li>我们终将毁灭于我们所热爱的东西。</li><li>那些看起来很爽的东西都是瞬间的满足，而人类所有真实的快乐，一定是恒久的努力。</li></ul></li><li><p>我们如何面对“我们活成了自己讨厌的样子”？</p><ul><li>我们时常活的忙乱，而又不知在忙什么。所以问题就在于，你的持守是什么？</li><li>当你有你的坚持，你也许就能回答这个问题。换言之，当你感觉活成了自己所厌恶的样子，你就要反躬己身问自己的坚守是什么？你心中的GOOD是什么？</li></ul></li><li><p>如何理解“勇敢”？</p><ul><li>合乎中道的勇敢。在明确心中持守和坚定的前提下，能够勇敢的为之前进。</li><li>心中知道什么是对的，但始终无法勇敢的坚守自己认为是对的东西。</li></ul></li><li><p>反问：什么是“良善”？如何过良善的一生？</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>苦尽甘来</title>
    <link href="/2021/06/19/life/%E8%8B%A6%E5%B0%BD%E7%94%98%E6%9D%A5/"/>
    <url>/2021/06/19/life/%E8%8B%A6%E5%B0%BD%E7%94%98%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="苦尽甘来"><a href="#苦尽甘来" class="headerlink" title="苦尽甘来"></a>苦尽甘来</h1><h2 id="甜水"><a href="#甜水" class="headerlink" title="甜水"></a>甜水</h2><p>一杯水在什么情况下是甜的？</p><p>往里加糖！</p><p>还有呢？</p><h2 id="竹芒"><a href="#竹芒" class="headerlink" title="竹芒"></a>竹芒</h2><p>这是来到高乐雅第三次喝竹芒得到的启发。</p><p>第一次遇见竹芒，很是惊喜，很早就关注了这款耶加雪菲，没想到在这处神奇之地可以遇见。</p><p>看到了店员姐姐手冲的全过程，还有旁边座位的妹子，我们一起聊了聊咖啡。第一次对这款咖啡味道的记忆是模糊的。</p><p>第二次来这里喝这款竹芒的时候，店员姐姐给我准备了两个杯子，一杯加冰加柠檬，一杯只加冰。这让我体验了四种不同酸度层次的口味。</p><p>这次来喝，还是准备了两个杯子。不过是一杯加冰，一杯是白水。</p><p>巧妙的事情发生了，在我一饮而尽一杯加冰的竹芒后，紧接着我喝了一口白水，那种强烈的回甘甜感十分明显。</p><p>这让我想起了今年生日前的几天，刚拿到实习的offer，在所里一楼的咖啡间，和姐姐讨了几颗余甘子和一杯冰美式。</p><p>从吃下余甘子的苦，到喝冰咖啡回甘的甜，那种苦尽甘来的体验使我印象深刻。</p><p><img src="/img/2021/%E8%8B%A6%E5%B0%BD%E7%94%98%E6%9D%A5-0.JPG" alt="余甘子-教父-竹芒"></p><h2 id="容易的快乐"><a href="#容易的快乐" class="headerlink" title="容易的快乐"></a>容易的快乐</h2><p>本杰明·富兰克林说，“唯有痛苦才能给人带来教益。”</p><p>可是教益不足以支撑我们接下来所有的生活。生活除了痛苦，还应该有快乐。</p><p>但快乐的获取方式不只一种，就如同这杯能够产生甜感的白水。</p><p>往水里直接加糖，自然喝起来会很甜。但这甜是刺激的，是迷幻的，我们喝的已不再是那杯原来的白水了，而是糖水。</p><p>我们如何才能持续不断地获取这份甜感？也许唯有不断地往水里加糖了。可是，我们手里的蔗糖始终有限。</p><p>但是如果我们喝了一杯口感浓烈回甘强劲的咖啡呢？白水还是那杯白水，但经由我们自身的感受，它却是甜的。</p><p>而且最重要的是，使我们产生甜感的，仍然是那杯白水。而我们生活里遇见最多的，也是白水。</p><p>痛苦，平淡，快乐。这像是以平淡为基点建立的生命的中轴线。在绝大多数时间的平淡里，我们时而痛苦，时而快乐。</p><p>且不说逃避痛苦是否是对的，单就一味追求平淡之外的快乐本身就存在问题。</p><p>毕竟，凡是容易的，能给神经快速带来刺激的快乐，都是短暂的、易逝的；凡是与自律相关的，通过不断地投入所带来的快乐与满足，也必将是长足的。</p><h2 id="短暂的治愈"><a href="#短暂的治愈" class="headerlink" title="短暂的治愈"></a>短暂的治愈</h2><p>并不是说拒绝娱乐，吃苦享乐就更高级，事实上快乐本身没有等级之分。</p><p>既然我们的本性是趋想快乐的，那何不如可持续地放大这种快乐？</p><p>我现在每天上下班加起来要走100公里的路程，路途本身并不会带来什么快乐，无论我如何渲染自己的这份辛苦与坚持。</p><p>但一天之中我真正的快乐是什么呢？应该是与奔波苦苦斗争之后，每天在安静不被打扰的时光里的阅读与思考。</p><p>不置身资本牢笼的学生不会体会生活的艰辛，更不会体会生活的快乐。</p><p>还是那杯白水，无论你赋予它怎样甜的意义，它始终是那杯没有味道的白水。但是你喝下一杯苦的咖啡，再去喝这杯白水，味蕾的甜感不会欺骗你。</p><p>治愈的意义也莫过于此，一天的路途上要花去四个小时，重复无聊的工作还要再花去八九个小时，但是却可以通过睡前阅读的那一个小时，得到彻底的缓解。</p><p>生活不需要长足的治愈，但是绝不能缺乏日常疲惫和重复过后的治愈本身。</p><p>所以你有没有发现，越是容易喝到的甜水（加了糖的），想再次喝到它越困难。越是尝够了苦头，喝那容易喝到的白水，获得的甜感越是容易。</p><p>要记取，每天都要为你的内心争取一段独属你的治愈时光。</p><h2 id="资本的牢笼"><a href="#资本的牢笼" class="headerlink" title="资本的牢笼"></a>资本的牢笼</h2><p>现在几乎全世界的人都已认清了资本的丑相，并且还在拥抱它。</p><p>是的，我现在想说说拥抱资本的问题。</p><p>同样是在吃，有的人吃巧克力的吃相让人觉得他在吃屎，有的人吃屎让人觉得他在吃巧克力。</p><p>拥抱资本也是一样。</p><p>人们已经足够认识资本的丑陋了，但当你拿着被资本剥削后的酬劳换取同样是资本用来安抚你的“催眠药”，你的愤怒又高级到了哪里？吃相又好看到了哪里？</p><p>你应该在自己的脑子里列一份资本的善恶清单，去享受你所处时代下资本的馈赠吧，前提是警惕资本背后的“伪善”。</p><p>要知道，人的一生大多时间都是重复而无聊的。不要再抱怨资本主义下工作生活的无聊了，生活还在忍受你的重复呢！</p><p>要活的有知觉起来，要热爱你螺丝钉一般的事业。你的工作不比西西弗斯滚落的那块石头更加无聊。</p><p>你还没有为你无聊的生活赋予意义，就着急咒责赏赐你饭碗的资本，你的善良又高贵在了哪里？</p><p>事实上，给了你你想要的闲适的生活又能怎样？给了你花不完的金钱又能怎样？你真的确定就能把这样的生活过的不无聊吗？</p><p>那些整天端着铁饭碗的人们把闲适的生活过得有意思到了哪里？那些一掷千金的富豪们在发泄性欲的时候又比小动物们有意思到了哪里？</p><p>不怕给你资本，就怕给了你资本，你自己不中用啊！</p><p>不怕每天是在搬砖，就怕你真的每天都只是在搬砖。</p><p>你能否在搬砖的过程中积累些更高级的技能？</p><p>你能否在繁杂的业务里梳理出更有价值的需求，看到更有前景和可能的契机？</p><p>你已经被资本裹挟一天了，为什么到了晚上睡觉的时候，还在拿着手机，继续被资本裹挟？</p><p>你不该奢望那么长的治愈时光，眼下最短暂最可以把握的机会都已被你错过。</p>]]></content>
    
    
    <categories>
      
      <category>生活沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven｜基础学习</title>
    <link href="/2021/06/14/tech/develop/Maven%EF%BD%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/06/14/tech/develop/Maven%EF%BD%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Maven是什么？"><a href="#Maven是什么？" class="headerlink" title="Maven是什么？"></a>Maven是什么？</h3><p>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。</p><h3 id="约定的目录结构"><a href="#约定的目录结构" class="headerlink" title="约定的目录结构"></a>约定的目录结构</h3><table><thead><tr><th>目录</th><th>功能</th></tr></thead><tbody><tr><td>${basedir}</td><td>存放pom.xml和所有的子目录</td></tr><tr><td>${basedir}/src/main/java</td><td>项目的java源代码</td></tr><tr><td>${basedir}/src/main/resources</td><td>项目的资源，比如说property文件，springmvc.xml</td></tr><tr><td>${basedir}/src/test/java</td><td>项目的测试类，比如说Junit代码</td></tr><tr><td>${basedir}/src/test/resources</td><td>测试用的资源</td></tr><tr><td>${basedir}/src/main/webapp/WEB-INF</td><td>web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</td></tr><tr><td>${basedir}/target</td><td>打包输出目录</td></tr><tr><td>${basedir}/target/classes</td><td>编译输出目录</td></tr><tr><td>${basedir}/target/test-classes</td><td>测试编译输出目录</td></tr><tr><td>Test.java</td><td>Maven只会自动运行符合该命名规则的测试类</td></tr><tr><td>~/.m2/repository</td><td>Maven默认的本地仓库目录位置</td></tr></tbody></table><h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。</p><p>POM 中可以指定以下配置：</p><ul><li>项目依赖</li><li>插件</li><li>执行目标</li><li>项目构建 profile</li><li>项目版本</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><h2 id="POM文件的结构"><a href="#POM文件的结构" class="headerlink" title="POM文件的结构"></a>POM文件的结构</h2><h3 id="1、模型版本"><a href="#1、模型版本" class="headerlink" title="1、模型版本"></a>1、模型版本</h3><p>在Maven2和Maven3中，只支持4.0.0版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、基本配置"><a href="#2、基本配置" class="headerlink" title="2、基本配置"></a>2、基本配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3、Build配置"><a href="#3、Build配置" class="headerlink" title="3、Build配置"></a>3、Build配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">reporting</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">reporting</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4、环境配置"><a href="#4、环境配置" class="headerlink" title="4、环境配置"></a>4、环境配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">issueManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">issueManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ciManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">ciManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mailingLists</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">mailingLists</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scm</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">scm</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prerequisites</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">prerequisites</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5、其他配置"><a href="#5、其他配置" class="headerlink" title="5、其他配置"></a>5、其他配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">inceptionYear</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">inceptionYear</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">licenses</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">licenses</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">organization</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">organization</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">developers</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">developers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contributors</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">contributors</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>关于具体的解释可以参考<a href="https://zakariyya.github.io/2019/01/03/backEnd-maven-maven%E6%A0%87%E7%AD%BE%E5%AD%97%E5%85%B8/">这里</a></p></blockquote><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p><a href="http://maven.apache.org/download.cgi">下载地址</a></p><p>下载后解压到<code>/usr/local</code>目录下，并更改<code>base_dir</code>的name为<code>maven</code>。</p><p>将以下内容添加到<code>./bash_profile</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">MAVEN_HOME=/usr/<span class="hljs-built_in">local</span>/maven<br>PATH=<span class="hljs-variable">$MAVEN_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> MAVEN_HOME<br><span class="hljs-built_in">export</span> PATH<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Bean 生命周期</title>
    <link href="/2021/06/14/tech/JavaSE/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2021/06/14/tech/JavaSE/Spring-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>Spring 只管理单例模式Bean的完整生命周期。</p><p><code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解在Bean创建和销毁阶段调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationBean</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(AnnotationBean.class);<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;AnnotationBean start&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;AnnotationBean destroy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《少有人走的路》｜读书笔记</title>
    <link href="/2021/06/13/thought/%E3%80%8A%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E3%80%8B%EF%BD%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/13/thought/%E3%80%8A%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E3%80%8B%EF%BD%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>“人生苦难重重。”这句话告诉我们苦难是人生的常态。</p>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《查拉图斯特拉如是说》｜章节概要</title>
    <link href="/2021/06/06/thought/%E3%80%8A%E6%9F%A5%E6%8B%89%E5%9B%BE%E6%96%AF%E7%89%B9%E6%8B%89%E5%A6%82%E6%98%AF%E8%AF%B4%E3%80%8B%EF%BD%9C%E7%AB%A0%E8%8A%82%E6%A6%82%E8%A6%81/"/>
    <url>/2021/06/06/thought/%E3%80%8A%E6%9F%A5%E6%8B%89%E5%9B%BE%E6%96%AF%E7%89%B9%E6%8B%89%E5%A6%82%E6%98%AF%E8%AF%B4%E3%80%8B%EF%BD%9C%E7%AB%A0%E8%8A%82%E6%A6%82%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1、序言"><a href="#1、序言" class="headerlink" title="1、序言"></a>1、序言</h3><p>查拉下山，和老圣人一番对话。</p><p>上帝死后，老圣人依然信仰上帝，仇视人类，看山不是山。查拉出山入世，要给人类带去一件礼物，看山还是山。这种心态上的转变，或许是阅读这本书我想要获得的。毕竟，再阴郁的内心，也会觉得那句”啊！太阳”充满了光热。   </p><p>查拉入世，想给人们带去的这样礼物，便是”超人”，但当查拉借以”超人”，引出完全与之对立的<a href="http://www.ideamass.com.cn/contents/727/5041.html">“末人”</a><br>时，人们却说：”查拉，把末人还给我们吧，我们用超人和你交换末人。”</p><p>查拉陪伴在人们所讥笑的小丑演员的尸体旁，意识到创造者不该与这些尸身为伴，创造者的伙伴只能是其他创造者。查拉必须去寻找他们，告诉他们通往超人之路的阶梯。</p><blockquote><p>做一只空杯，是这只杯子最热切的希望。</p><p>如果你想要施舍他们一些东西，就单纯地去施舍，而且是在他们乞求你的情况下。即便是要送出宝物，也要留神怎样被接受才是。</p><p>人身上总有一种伟大的特质，这种特质在于人不是目的，而只是一座桥梁。人的身上，有着一种落寞，人本身，就是一种动物朝着超人的过渡，而这，也正是人的可爱之处。我爱那些作为过渡者的人们，因为他们沉溺在没落中，从来都不懂得生活。</p><p>创造者的伙伴不应该是死者，更不会是牧群和最纯正的信徒。创造者的伙伴只能是其他的创造者，是那些将新的价值观念书写在新的规则世界的人。</p></blockquote><h3 id="2、三种变形"><a href="#2、三种变形" class="headerlink" title="2、三种变形"></a>2、三种变形</h3><p>精神本身存在着三种变形，精神变成骆驼，骆驼变成狮子，狮子变成小孩。首先是”负担”，然后是”我想”，最后是”我是”。</p><blockquote><p>精神本身存在着三种变形，精神变成骆驼，骆驼变成狮子，狮子变成小孩。</p></blockquote><h3 id="3、德性讲坛"><a href="#3、德性讲坛" class="headerlink" title="3、德性讲坛"></a>3、德性讲坛</h3><p>德性之高者必拥有好的睡眠。</p><blockquote><p>睡眠很重要，它不是一件小事，白天，我们精神奕奕，保持理智和清醒，为的就是在晚上能够睡好。</p></blockquote><h3 id="4、彼世论者"><a href="#4、彼世论者" class="headerlink" title="4、彼世论者"></a>4、彼世论者</h3><p>幻想一个虚妄的来世，这本身就是一种消极的虚无主义；用强大的生命力赋予今生今世、此时此刻以意义，这才是真实。</p><blockquote><p>所谓的彼世，不是解脱，而是另一种痛苦，它代表着无能，它是一种疯狂，只有沉浸在最深沉的苦难中的人才能从其中体会到短暂的幸福。</p><p>他们相信的不是所谓的彼世，也不是救赎的血滴，而是他们自己的身体，对他们来说，自己的身体就是承载自由的容器。</p></blockquote><h3 id="5、身体的蔑视者"><a href="#5、身体的蔑视者" class="headerlink" title="5、身体的蔑视者"></a>5、身体的蔑视者</h3><p>“我的身体就是我的灵魂”是对”抽象的灵魂对肮脏的肉体的蔑视”的批判。</p><blockquote><p>我的身体就是完整的我，除了身体，一切其他的东西都不存在，灵魂也不过是人们对身体中某个特定部位的称呼。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《沉思录》｜读书笔记</title>
    <link href="/2021/05/30/thought/%E3%80%8A%E6%B2%89%E6%80%9D%E5%BD%95%E3%80%8B%EF%BD%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/05/30/thought/%E3%80%8A%E6%B2%89%E6%80%9D%E5%BD%95%E3%80%8B%EF%BD%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot注解</title>
    <link href="/2021/05/30/tech/JavaSE/SpringBoot%E6%B3%A8%E8%A7%A3/"/>
    <url>/2021/05/30/tech/JavaSE/SpringBoot%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p><code>@RequestMapping</code>是用于处理请求地址映射的注解，请求地址为类地址和方法地址的拼接（如果类上没有该注解则直接为方法地址）。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol><li><code>value</code>：指定请求的实际地址，指定的地址可以是URI Template 模式；</li><li><code>method</code>： 指定请求的method类型， GET、POST、PUT、DELETE等；</li><li><code>consumes</code>： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</li><li><code>produces</code>: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li><li><code>params</code>： 指定request中<strong>必须</strong>包含某些参数值时，才让该方法处理。</li><li><code>headers</code>： 指定request中<strong>必须</strong>包含某些指定的header值，才能让该方法处理请求。</li></ol><blockquote><p>在设置<code>value</code>参数的时候，可能涉及的相关注解为：<a href="#PathVariable">@PathVariable</a>；<br>在设置<code>params</code>参数的时候，可能涉及的相关注解为：<a href="#RequestParam">@RequestParam</a>；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// value可以是一个具体的URI，也可以是含有变量的URI（URI Template Patterns with Path Variables–restful风格）。</span><br><span class="hljs-meta">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testPathVariable</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id2)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;testPathVariable: &quot;</span> + id2);<br>    <span class="hljs-keyword">return</span> SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/J080624/article/details/55193269">参考</a></p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p><code>@PathVariable</code>用来获得请求url中的动态参数，一般修饰于方法中的入参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;  <br><br>     <span class="hljs-meta">@RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET)</span>  <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLogin</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> String userId,  </span></span><br><span class="hljs-function"><span class="hljs-params">         <span class="hljs-meta">@PathVariable(&quot;roleId&quot;)</span> String roleId)</span></span>&#123;<br>           <br>         System.out.println(<span class="hljs-string">&quot;User Id : &quot;</span> + userId);  <br>         System.out.println(<span class="hljs-string">&quot;Role Id : &quot;</span> + roleId);  <br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;  <br>     <br>     &#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p><code>@RequestParam</code>用于获取request请求的参数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CopperVO&gt; <span class="hljs-title">getOpList</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-meta">@RequestParam(value = &quot;pageIndex&quot;, required = false)</span> Integer pageIndex,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-meta">@RequestParam(value = &quot;pageSize&quot;, required = false)</span> Integer pageSize)</span> </span>&#123;<br><br> &#125;<br><br></code></pre></td></tr></table></figure><h2 id="ResponseBody-amp-RequestBody"><a href="#ResponseBody-amp-RequestBody" class="headerlink" title="@ResponseBody &amp; @RequestBody"></a>@ResponseBody &amp; @RequestBody</h2><p><code>@ResponseBody</code>用于将Controller的方法返回的对象，根据HTTP Request Header的Accept的内容,通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p><code>@ResponseBody</code>使用在返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用.</p><p><code>@RequestBody</code>用于将Controller的方法参数，根据HTTP Request Header的content-Type的内容,通过适当的HttpMessageConverter转换为JAVA类</p><p><code>@RequestBody</code>使用在POST或者PUT的数据是JSON格式或者XML格式,而不是普通的键值对形式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/testRequestBody&quot;, method= RequestMethod.POST)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">testRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Person p)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;creating a employee:&quot;</span> + p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;   <br></code></pre></td></tr></table></figure><p><img src="/img/2021/@ResponseBody&@RequestBody%E4%BD%BF%E7%94%A8.png" alt="数据的格式的转换过程"></p><p><a href="https://www.jianshu.com/p/7097fea8ce3f">参考</a></p><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p><code>@RestController</code>和<code>@ResponseBody</code>注解都会处理返回的数据格式，使用了该类型注解后返回的不再是视图，不会进行转跳，而是返回json或xml数据格式，输出在页面上。</p><p>二者的区别在于：<code>@ResponseBody</code>，一般是使用在单独的方法上的，需要哪个方法返回json数据格式，就在哪个方法上使用，具有针对性；<code>@RestController</code>，一般是使用在类上的，它表示的意思其实就是结合了<code>@Controller</code>和<code>@ResponseBody</code>两个注解，如果哪个类下的所有方法需要返回json数据格式的，就在哪个类上使用该注解，具有统一性；</p><p>使用了<code>@RestController</code>注解之后，其本质相当于在该类的所有方法上都统一使用了@ResponseBody注解，所以该类下的所有方法都会返回json数据格式，输出在页面上，而不会再返回视图。</p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java异常机制代码执行顺序</title>
    <link href="/2021/05/29/tech/JavaCE/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2021/05/29/tech/JavaCE/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>在本周实习coding的时候遇到这样一个问题，如果code2处发生异常，整个程序是直接终止吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    code1<br>    code2 <span class="hljs-comment">// 发生异常</span><br>    code3<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    code4<br>&#125;<br>code5<br></code></pre></td></tr></table></figure><p>借此机会，对异常的代码执行顺序进行一个简单的整理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;发生异常！&quot;</span>); <span class="hljs-comment">// code1</span><br>            <span class="hljs-comment">// System.out.println(&quot;code1&quot;); IDE会提示为无效代码，会产生编译错误。</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace(); <span class="hljs-comment">// 捕获到了code1的代码</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;finally&quot;</span>); <span class="hljs-comment">// try完无论抛不抛异常都会执行的代码</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>); <span class="hljs-comment">// 被catch到的异常会执行，没被catch到的或者catch完有抛了新的异常都不会执行。</span><br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;参数越界&quot;</span>); <span class="hljs-comment">// IDE提示在函数头抛出异常</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;异常后&quot;</span>); <span class="hljs-comment">//抛出异常，不会执行</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">java.lang.Exception: 发生异常！</span><br><span class="hljs-comment">at Test.main(Test.java:7)</span><br><span class="hljs-comment">Exception in thread &quot;main&quot; java.lang.Exception: 参数越界</span><br><span class="hljs-comment">at Test.main(Test.java:17)</span><br><span class="hljs-comment">finally</span><br><span class="hljs-comment">end</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Process finished with exit code 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1、<a href="https://blog.csdn.net/qq_2300688967/article/details/79425729">https://blog.csdn.net/qq_2300688967/article/details/79425729</a></p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git命令学习</title>
    <link href="/2021/05/29/tech/develop/Git%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/05/29/tech/develop/Git%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/2021/git-command.jpeg" alt="git-command"></p><p>写代码时，要把公司仓库的代码clone到本地，在workspace路径下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b &lt;branch_name&gt; &lt;repository&gt;<br></code></pre></td></tr></table></figure><p>分支操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch <span class="hljs-comment"># 查看本地分支</span><br>git branch &lt;branchName&gt; <span class="hljs-comment"># 创建分支</span><br>git checkout &lt;branch_name&gt; <span class="hljs-comment"># 转到某一分支</span><br><br>git checkout -b &lt;branchName&gt; <span class="hljs-comment"># 在当前分支下创建新的分支并切换到新创建的分支</span><br></code></pre></td></tr></table></figure><p>修改完代码提交到远程仓库分支中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add . <span class="hljs-comment"># 将所有文件放到暂存区</span><br>git commit -m &lt;message&gt;  <span class="hljs-comment"># 提交到本地仓库</span><br><br>git commit -am &lt;message&gt; <span class="hljs-comment"># 合并add 和commit的命令</span><br><br>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; <span class="hljs-comment"># 将本地的分支版本上传到远程并合并</span><br>git push &lt;远程主机名&gt; &lt;本地分支名&gt; <span class="hljs-comment"># 如果本地分支名与远程分支名相同，则可以省略冒号，一般远程主机名为origin</span><br><br>git pull &lt;remote&gt; &lt;branch&gt; <span class="hljs-comment"># 取远程仓库变化，合并到当前分支</span><br><br>git pull <span class="hljs-comment"># 一般都是从master clone下来的，所以pull到master分支</span><br>git merge master <span class="hljs-comment"># 在当前分支下，将本地master合到当前分支</span><br><br>git checkout . <span class="hljs-comment"># 未执行add，撤销工作区的修改</span><br>git reset HEAD &lt;filename&gt; <span class="hljs-comment"># add之后撤销暂存区的修改，但保留工作区修改</span><br>git restore &lt;finename&gt; <span class="hljs-comment"># 撤销工作区的修改</span><br>git reset --hard HEAD^ <span class="hljs-comment"># commit之后回到最新一次的提交</span><br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status <span class="hljs-comment"># 显示所有🈶变更的文件</span><br>git diff <span class="hljs-comment"># 显示暂存区和工作区的差异</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“提升专注力”｜B站&lt;YXZHANG_&gt;</title>
    <link href="/2021/05/23/thought/%E2%80%9C%E6%8F%90%E5%8D%87%E4%B8%93%E6%B3%A8%E5%8A%9B%E2%80%9D%EF%BD%9CB%E7%AB%99%3CYXZHANG_%3E/"/>
    <url>/2021/05/23/thought/%E2%80%9C%E6%8F%90%E5%8D%87%E4%B8%93%E6%B3%A8%E5%8A%9B%E2%80%9D%EF%BD%9CB%E7%AB%99%3CYXZHANG_%3E/</url>
    
    <content type="html"><![CDATA[<p>生命的有效时长由三个因素决定，一是所行之事本身是否有意义，在此基础上，另一个是行事的有效投注时间。</p><p>提升专注力不等同于提升效率，因为追求效率意味着可能掉进时间管理的陷阱，即被过程中的形式主义所束缚，而忽略了问题的本质和最终的目标。</p><p>专注和效率的正确关系是，<strong>效率是专注做事附带的产物</strong>，而专注除了可以提升产出效率外，还可以保持头脑清晰，带来心情愉悦。</p><p>专注是需要精力的，所以提升专注要围绕两方面展开，一方面要减少精力的消耗，另一方面要直接或间接地补充精力。</p><p>精力消耗的一种情况是走神，应对策略是自我暗示，即告诉自己当下在做什么，如此可以减少走神时间。除此，要控制好环境变量，减少信源等，可以采用效率软件辅助。</p><p>补充精力要早起早睡，运动，规律饮食，三者可以形成正反馈闭环，主动提升专注力。除此，正念冥想的作用也十分明显。</p><p>分析精力消耗和精力补充的关系：在补充精力代价下，如果控制不好精力的消耗，意味着产出的低效，这不会影响头脑的清晰，但会被动使心情变糟；在控制好精力消耗的代价下，没有补充好精力，这将导致心有余而力不足，久而久之形成恶性循环。</p><p>分析各因素的性价比：</p><ol><li>睡眠时间是实打实的，长期规律的休息时间大概在8个小时左右，如果睡眠时长在5个小时左右，甚至更短，可能需要用几天甚至一周的时间来调整，性价比极低，因此需要保证工作日睡眠的基本充足；</li><li>冥想时间在15分钟左右；长期冥想会直接影响到一天的精神状态，性价比极高。</li><li>运动时间在1小时左右，长期规律运动会保持心情愉悦，也有助于脑力和身体其他技能锻炼，性价比也很高。</li><li>减少信源，可以设定时间间隔看信息，比如每隔一小时回复消息，每隔三天刷一次朋友圈。</li></ol><p>至此，一个良性的专注力提升闭环已形成：</p><ol><li>通过早起早睡保证有力可用；</li><li>通过正念冥想使精神集中，直接提高专注能力；</li><li>通过运动调整身体机能和心情，辅助更好地专注；</li><li>做事前屏蔽掉噪声信源，减少走神的概率和频次；</li><li>走神的时候通过自我暗示最大程度减少走神时间。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.bilibili.com/video/BV1ND4y1m74e">https://www.bilibili.com/video/BV1ND4y1m74e</a></p>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《刘擎西方现代思想讲义》｜伟大又危险的尼采</title>
    <link href="/2021/05/02/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E4%BC%9F%E5%A4%A7%E5%8F%88%E5%8D%B1%E9%99%A9%E7%9A%84%E5%B0%BC%E9%87%87/"/>
    <url>/2021/05/02/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E4%BC%9F%E5%A4%A7%E5%8F%88%E5%8D%B1%E9%99%A9%E7%9A%84%E5%B0%BC%E9%87%87/</url>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>尼采说：“一个人能承受多少真相，是对他精神强度的考验。”只有我们有勇气直面上帝之死后的种种真相，才能真正找到生命的意义。这也正是罗曼罗兰所说的：“世上只有一种英雄主义，就是在认清生活的真相后依然热爱生活。”</p><h2 id="从“上帝死了”说起"><a href="#从“上帝死了”说起" class="headerlink" title="从“上帝死了”说起"></a>从“上帝死了”说起</h2><h3 id="可怕的宣言"><a href="#可怕的宣言" class="headerlink" title="可怕的宣言"></a>可怕的宣言</h3><p>随着启蒙时代的到来，理性主义大行其道。而把宗教从神坛基本上推下来的，应该是尼采的那句“上帝死了”。然而，这真的像是一场革命胜利的欢呼吗？</p><p>其实，尼采在宣告“上帝死了”之后的下一句是“是我们杀死了上帝！”这根本不是欢呼，这完全是一句沉痛的哀告。</p><p>为什么说这是一句哀告？因为对于当时的西方人而言，否定了上帝，信仰的大厦完全崩塌，生命找不到意义，人们就会陷入「虚无主义」之中。</p><p>可为什么尼采又说“是我们杀死了上帝”？</p><p>学术界有千万种解释，而作者认为，尼采虽以反基督教著称，但他对耶稣本身并无敌意。只是他认为，耶稣并不是要直接救赎人类，而是告诉人们应该怎么生活。可耶稣的门徒却把经念歪了，不仅没有好好实践“怎样生活”，还搞出一套教义理论自欺欺人。这根本不是耶稣的愿意，而是一套虚假的思想。</p><h3 id="虚假的形而上"><a href="#虚假的形而上" class="headerlink" title="虚假的形而上"></a>虚假的形而上</h3><p>这个虚假的思想究竟是什么呢？</p><p>尼采给出的答案是“形而上学”。</p><p>尼采将形而上学概括为三大信念：</p><ol><li>相信在感知的表象世界背后有一个更真实的本质世界；</li><li>相信这个混乱的世界实际上是有目的的；</li><li>相信这个纷乱多样的世界背后有一种统一性。</li></ol><p>可尼采认为，那个所谓的更真实的、有目的的、有统一性的本质世界根本不存在。这完全是形而上学的编造，其本质原因是人们需要安慰。但这种安慰最终却会带来恶果：就好比一个人本来很爱钱，但因为贫穷感到自卑，于是他就去信奉一套所谓的“高尚的人应该是金钱如粪土”的说辞来躲避自己的自卑感。可生命欲望却是真实的，也是正当的。</p><p>因此在尼采看来，那些看上去高尚典雅、充满确定感的形而上学才是虚无主义的真正根源。</p><h2 id="直面虚无主义的真相——“超人学说”"><a href="#直面虚无主义的真相——“超人学说”" class="headerlink" title="直面虚无主义的真相——“超人学说”"></a>直面虚无主义的真相——“超人学说”</h2><blockquote><p>人类的高贵在于自身有决定价值的能力，不需要别人同意，他懂得自己给事物以荣耀。    —— 尼采</p></blockquote><h3 id="积极的虚无主义"><a href="#积极的虚无主义" class="headerlink" title="积极的虚无主义"></a>积极的虚无主义</h3><p>上帝之死所产生的虚无难道一定是一种很悲剧很可怕的处境吗？</p><p>尼采的回答是，未必。</p><p>而如果对尼采一生的哲学命题进行一个概括的话，就是：人生虚无、理论虚假、生命强健。</p><p>生命本身就是对抗虚无的办法。</p><p>其实在尼采看来，虚无主义本身还分积极的和消极的。先说消极的虚无主义，虚无并不直接导致消极，从虚无到消极，要必经一个中间环节——幻念：认为在世界的表象背后还存在绝对的本质，并且认为人生必须依靠这个绝对的本质才能找到价值和意义。然而当你所认为的这个本质被一次次击碎的时候，幻念将变成绝望。而积极的虚无主义则是：认识到世界本无意义，而这恰恰带来了创造的自由。</p><p>最好的积极的虚无主义的例子，就是加缪笔下的西西弗斯。西西弗斯的命运象征着人生的困境，一切皆是徒劳。但除了沮丧绝望让整个生命历程变成一种痛苦的折磨的选择外，还有一种选择就是勇敢无畏精神焕发地推动那块巨石。西西弗斯选择了后者，他用自己的选择创造出了意义，用无尽的斗争精神去对抗虚无。因此加缪写道：“登上顶峰的斗争本身足以充实人的心灵。应该设想，西西弗斯是幸福的。”</p><h3 id="奴隶道德与主人道德"><a href="#奴隶道德与主人道德" class="headerlink" title="奴隶道德与主人道德"></a>奴隶道德与主人道德</h3><p>我们每个人都是西西弗斯，面对虚无的人生，有两种截然不同的选择。尼采把这两种人生选择叫作奴隶道德<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="奴隶道德就是放弃自己生命的激情，用虚假的思想来约束自己、安慰自己，把人生希望寄托在虚妄的观念之中。">[1]</span></a></sup>和主人道德<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="主人道德就是放弃一切幻念，直面虚无和荒谬，像西西弗斯那样用生命的激情去自我创造，做一个勇敢、荒谬的英雄。">[2]</span></a></sup>。</p><p>而拥有主人道德的人就是「超人」，超人能够在上帝死后，成为自己的主人。可以说，超人于普通的人，无异于普通人于一只猴子。</p><h3 id="“超人学说”本身是否也是一种虚假理论"><a href="#“超人学说”本身是否也是一种虚假理论" class="headerlink" title="“超人学说”本身是否也是一种虚假理论"></a>“超人学说”本身是否也是一种虚假理论</h3><p>历史上所有的先知都呼吁他们的信徒“听从我，追随我”，而尼采却说，你否定了我才是真正理解了我，才是深刻的追随，我才会回到你们身边。</p><p>所以，如果你相信一种真理，那就不该盲从它，如果你真的理解一种思想，就不该相信创造这种思想的人所留下的教条，而是去探索自己的生命。</p><blockquote><p>你们说相信查拉图斯特拉，但查拉图斯特拉算什么？你们说是我的信徒，但所有的信徒又算得了什么？你们没有探索自己，却发现了我……现在我要你们丢开我去发现自己，只有当你们全部否定我的时候，我才会回到你们身边。    —— 尼采 《查拉图斯特拉如是说》</p></blockquote><h2 id="我们共同的真相应该是什么"><a href="#我们共同的真相应该是什么" class="headerlink" title="我们共同的真相应该是什么"></a>我们共同的真相应该是什么</h2><h3 id="视角主义"><a href="#视角主义" class="headerlink" title="视角主义"></a>视角主义</h3><p>尼采在一个多世纪前，就看到了后真相现象<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="用来描划“客观事实在形成舆论方面影响较小，而诉诸情感和个人信仰会产生更大影响”的情形。比如对硅谷的程序员来说，全球化推动了美国经济的发展，这是一个事实。而事业的重工业区就业者说出的另一个事实是，全球化推动了互联网公司的发展，但是制造业却衰退了而制造业却是国家的立身之本。">[3]</span></a></sup>的本质：客观的事实真相可能根本不存在。这种观点在哲学届被称为“视角（perspective）主义”，即没有事实，只有阐释。</p><p>但这和我们传统的认知模式<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="这种传统的认知模式可以是：横看成岭侧成峰，远近高低各不同。也可以是我们借用科学工具能看到我们肉眼看不到的客观世界。">[4]</span></a></sup>有一个根本的不同。我们传统认知模式有一个前提是：认为存在一个客观的真相或真理。我们不断地去认知它，理解它，表达它，只要不断推进这个过程，我们最终是可以完全认识和掌握这个真相的。</p><p>但尼采的视角主义认为，“存在一个客观真相”不过是一厢情愿的假设。这种“客观性”不过是一种合理的错觉。我们以为我们在“认知”真相，其实我们只是在“制造”真相。</p><p>而事实是，那些我们的“共同视角”所看到的真相，只不过得到了一致的解释，但客观事实也会变，科技也在进步，我们所看到的“客观事实”也会随着“共同视角”的变化而变化。</p><h3 id="“后真相”时代给我们的启示"><a href="#“后真相”时代给我们的启示" class="headerlink" title="“后真相”时代给我们的启示"></a>“后真相”时代给我们的启示</h3><p>在后真相时代下，难道社会注定只能陷入无休止的分裂和争执吗？</p><p>理财的视角主义种还蕴藏着另一种可能性：恰恰是因为明白了每个人视角都只是视角之一，所以我们应该意识到我们所以为的真相其实不一定是绝对的真相。了解不同，不是要我们和他人划清界限，而是要我们以更开放的态度，去倾听、理解和学习它们。</p><blockquote><p>我们越是运用更多的眼睛、不同的眼睛去观察同一个东西，我们对这个东西的“概念”就越“完整”。我们也能越“客观”。    —— 尼采《道德的谱系》</p></blockquote><h2 id="我的感受"><a href="#我的感受" class="headerlink" title="我的感受"></a>我的感受</h2><p>阅读刘擎笔下尼采这部分的文字，所给我带来的精神愉悦无疑是极致的。了解了尼采的“超人主义”过后，再回头去想加缪笔下的西西弗斯，才发现虚无主义可能包含的积极性究竟在哪。“后真相”时代让每个人都成为自己“视角主义”的上帝，但与此同时一个事实也十分明显：保持开放态度地倾听、理解和学习他人视角下的真相只是一种“应然”，而现实却是人群中随处可见的傲慢与偏见。我们每个人的确可以做自己生命中的乐观的悲观主义者，但上帝死后的世界究竟该何去何从，混乱的世界到底还要不要一个相对统一的价值判断，如果要，它会是什么，尼采似乎并没有告诉我们答案。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>奴隶道德就是放弃自己生命的激情，用虚假的思想来约束自己、安慰自己，把人生希望寄托在虚妄的观念之中。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>主人道德就是放弃一切幻念，直面虚无和荒谬，像西西弗斯那样用生命的激情去自我创造，做一个勇敢、荒谬的英雄。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>用来描划“客观事实在形成舆论方面影响较小，而诉诸情感和个人信仰会产生更大影响”的情形。比如对硅谷的程序员来说，全球化推动了美国经济的发展，这是一个事实。而事业的重工业区就业者说出的另一个事实是，全球化推动了互联网公司的发展，但是制造业却衰退了而制造业却是国家的立身之本。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>这种传统的认知模式可以是：横看成岭侧成峰，远近高低各不同。也可以是我们借用科学工具能看到我们肉眼看不到的客观世界。<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《刘擎西方现代思想讲义》｜韦伯—现代思想的成年</title>
    <link href="/2021/05/01/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E7%9A%84%E6%88%90%E5%B9%B4/"/>
    <url>/2021/05/01/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E7%9A%84%E6%88%90%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>从现代社会的底层机制和最深层的缺陷看待我们如何成为一个完整的人。</p><h2 id="韦伯与现代思想的成年"><a href="#韦伯与现代思想的成年" class="headerlink" title="韦伯与现代思想的成年"></a>韦伯与现代思想的成年</h2><p>在阅读导论的时候，我们说道韦伯是作为现代思想成年的标志，这是因为他完成了两项任务：看清现代，反思现代。</p><p>所谓看清现代，是说他的思想<strong>真正理解了现代社会运作的底层机制</strong>。韦伯之前，西方的现代化虽已发展两百年，但人们对于现代化的理解大多还是片面和混乱的。直到韦伯以“理性化”为核心，建立了一套现代化理论，才第一次全面而系统地解释了现代社会的来龙去脉和运转机制。</p><p>而所谓反思现代，是说韦伯的思想<strong>指出了现代性最深层的缺陷</strong>。这种缺陷是根植于现代化本身的问题。这些问题不随社会进步而消除，反因社会发展而更加严重。</p><p>韦伯在《学术作为一种志业》的演讲中指出了生命意义的问题是一种超出科学边界的存在，即：科学永远无法回答我们做出什么样的选择才是值得的；我们过什么样的生活才是有意义的；我们生命的目的究竟是什么。<strong>科学也许可以给出最有的“方案”，但永远无法教给我们一个最有的“选择”</strong>。（关于方案和选择，其实就是后面要提到的「工具理性」和「价值理性」的问题）</p><p>在欧洲文艺复兴之后，人们把理性推向了替代神明的高座，却对于其产生的后果没有充分的认识。韦伯真正的贡献不在于阐明了现代的理性化特征，而是揭示了理性化的各种复杂后果，打破了启蒙时代以来对于科学理性的乐观主义错觉。</p><p>而后的几节，分别是作者从韦伯思想中提炼的核心命题：“世界的祛魅”“诸神之争”“现代的铁笼”。</p><h2 id="祛魅"><a href="#祛魅" class="headerlink" title="祛魅"></a>祛魅</h2><p>今天我们再看待过去时代的人所信仰的神明，它可能意味着任何世界之间是可以建立起某种联系的，甚至是可以沟通和互动的。诸如：渔船出海前祭奠妈祖；打仗出征前到神庙占卜；生不出孩子去求送子观音。虽然未必有用，但至少有路可走，内心是安稳的。这些冥冥之中难以言说的神秘事物，组成了古代精神极为重要的一部分，让人类与整个宇宙紧密连结成一个整体，构成宇宙秩序（consmos）。古代人从这种秩序中确立了生存的意义。</p><p>而祛魅则意味着用理性的力量驱散了神秘的魅惑，作为一种理性化的取向，祛魅所要考问的是所有超验的、神秘的东西，这个逻辑链条一旦展开，就不会停止。因此祛魅除了要祛除迷信，还要祛除宗教。而当尼采喊出“上帝死了”的时候，这个祛魅的挑战也就算基本完成了。</p><p>自然世界客观化了，不再具有神性和灵性的世界，变成了用冷冰冰的因果规律解释的物理世界。</p><blockquote><p>我们的时代，是一个理性化、理知化，尤其是将世界之迷魅加以祛除的时代；我们这个时代的宿命，便是一切终极而最崇高的价值，已自公共领域隐没。    —— 韦伯《学术作为一种志业》</p></blockquote><p>失去了神的默认选项，对人类意味着什么？也许这意味着到了现代社会，一个人从“母体”中剥离出来，从此要孤独地、无依无靠地存活在这个世界上。这在一定程度上解释了当代年轻人的孤独。</p><p>关于韦伯所讲的祛魅，我们还要关注的一点是，它并不带有好坏值评判的色彩，充其量只是一个对客观事实的描述：一方面，祛魅让人的精神格外“荒凉”，理性主义的科学并不能为生命的意义提供新的根本依据；另一方面，祛魅只是现代的真相，无论你是否喜欢，它都作为现代的特性不能被消除，我们所要做的只是要直面这个真相。</p><p>那么，清醒后的现代人又该如何重建终极价值和生命的意义？祛魅的额世界如何才能不成为荒凉的世界？科学和理性能帮我们做什么呢？这这就牵扯了“诸神之争”。</p><h2 id="诸神之争——事实判断和价值判断"><a href="#诸神之争——事实判断和价值判断" class="headerlink" title="诸神之争——事实判断和价值判断"></a>诸神之争——事实判断和价值判断</h2><p>想回答上面的问题，需要引入两个概念：「事实判断」和「价值判断」。「事实判断」对应的是「是然」，它具有统一的标准；而「价值判断」对应的是「应然」，所依据的是个人形成的一套价值标准，会产生多元化。「价值多元化」让个体获得了更多的自由，但又可能是另一种“困境”。</p><p>从个人层面来说，每个人的人生选择都可能有自己的主观理由，却没有一个公认的共同理由。因此很多问题我们并不能给出确定无疑的答案，就如同糟糕的并不一定是我们没有充分依据的选择，而是即便我们选了也永远不知道选得对不对。</p><blockquote><p>人是悬挂在自己编织的意义之网上的动物。    —— 韦伯</p></blockquote><p>从社会层面来说，公共生活中许多激烈对立的议题本质上是价值观之间的冲突。我们不难联想到当下被推向舆论风口浪尖的议题，但我想说的是，这些在部分人眼中的所谓的应然的价值判断，除了能说明个人的基本权利，其他什么都改变不了，任何所谓的重新审视某些问题从来和历史发展的必然性没有直接联系，如果一个事情从根本上得到了改变，那必然是社会秩序发生了新一轮进化的结果。</p><p>对此，韦伯对这场“诸神之争”的态度是：“对待生活的各种可能的终极态度，是互不相容的，因此它们之间的斗争，也是不会有结论的。”</p><blockquote><p>个人必须决定，在他自己看来，哪一个是上帝，哪一个是魔鬼。  —— 韦伯</p></blockquote><p>韦伯带给我们的启示是，坦然面对这种困境，与此共存，也许是智性成熟的一种标志。</p><h2 id="现代铁笼"><a href="#现代铁笼" class="headerlink" title="现代铁笼"></a>现代铁笼</h2><h3 id="先破后立，立了什么"><a href="#先破后立，立了什么" class="headerlink" title="先破后立，立了什么"></a>先破后立，立了什么</h3><p>如果说现代社会是对古代社会的“先破后立”，我们已经讨论了“破”的是什么，那接下来我们再来聊聊又“立”了什么。</p><p>说起这个我们还要回到「事实判断」这个问题上，因为它才给我们提供了一套统一的标准。如果让你来说一下在当今社会，有哪样一种东西可以最替代或者说最接近曾经的上帝或神灵，我想我们的回答都会是一个：金钱。对于金钱的态度，现代人的态度似乎确实高度一致。</p><blockquote><p>金钱有一点像上帝，上帝对所有人一视同仁，每个人都可以用上帝的名义做自己的事情。    —— 齐美尔</p></blockquote><h3 id="工具理性带来的问题是什么？"><a href="#工具理性带来的问题是什么？" class="headerlink" title="工具理性带来的问题是什么？"></a>工具理性带来的问题是什么？</h3><p>为了更好的理解金钱，形成我们个人的价值观，有必要引出韦伯提到了一个重要概念——“工具理性”。韦伯认为，人类的理性可以区分成两种不同类型，工具理性和价值理性。</p><p>工具理性即做事的手段，它不关心目的，只关心达成目的的手段是否最优。而价值理性是说我需要决定到底要不要做这件事。</p><p>这就意味着很明显的几种特质：手段的价值更容易“计算”，选择的价值更难于“计算”；工具理性问题有客观标准，更容易达成一致，而价值理性标准不一，很难找到确定的答案。而这，也就导致了在现代化过程中，工具理性大行其道，压倒了价值理性。</p><p>社会的理性化发展，变成来工具理性的单方面扩张，理性化变成来不平衡的“片面的理性化”。在实践中，表现为<strong>对手段的追求压倒了对目的的追求</strong>。这种后果对个人层面和社会层面都是如此。</p><p>一个显著的后果就是社会制度的官僚化。官僚制最典型的体现就是行政管理系统，它的特点是有一个登记严密的上下结构关系，整个系统都有明确的分工，每个人都要按流程规矩办事；它的本质其实是最大化工具理性的生产效率；虽然你的主观感受是官僚制度繁文缛节、办事拖沓、效率低下，但这并不是它的必然结果。反而，事实正好相反，对个人来说，这可能是僵硬、机械的，但个人体验和全局效益不同，个人体验不佳恰恰是系统追求高效的结果。这种“非个人化”（impersonal）的好处是，无法被计算的复杂个人变成来可以计算的数据。而事实上，绩效制（meritocracy）就是这么来的。</p><p>“非个人化”使得在公司内部，人被看成是“机器的零件”，而不光是公司内部，现代社会也成了一条“流水线”，社会上的任何一个部门都是这个自我循环的流水线的一环。过去周而复始的循环历史观破碎了，现在周而复始的生产方式又建立了。韦伯把这种特征概括为“铁笼”。</p><p>铁笼存在两个非常大的弊端，一个是片面的社会文化，诸如用利益计算解决道德问题的治标不治本等；还有一个是早就了片面的社会关系：人与人、人与组织之间逐渐变成了一种商业的“供求关系”。</p><p>身处这个铁笼之中，即使有丰富的只是，成了专家，也不过是一种高级的零件罢了，本质上，没有任何区别。而所谓的“社会核心竞争力”也并没有真正意义上的人格的自主性，因为有一个摆在我们每个人眼前的迫切任务：<strong>满足社会机器对一个零件的要求</strong>。我们在竞争激烈的内卷中成为一个优质的、合格的零件。这也许就是铁笼这个比喻所蕴含的深意：人类作为“万物的灵长”，那些生命和灵性发展的需求被忽视和淹没了。</p><blockquote><p>专家没有灵魂。    —— 韦伯</p></blockquote><h3 id="铁笼可以被打破吗"><a href="#铁笼可以被打破吗" class="headerlink" title="铁笼可以被打破吗"></a>铁笼可以被打破吗</h3><p>既然我们已经知道了现代社会变成了一个铁笼，有这么大的弊端，那是不是打破这个铁笼就可以了呢？</p><p>也没有那么简单。因为铁笼一方面囚禁了人的灵性，另一方面也保护了我们。科技的进步确实有效地解决了困扰人类数千年的问题：贫困、奴役、疾病，等等。</p><p>历史的车轮还要继续前进，没有谁可以阻挡。</p><h3 id="我们可以做些什么"><a href="#我们可以做些什么" class="headerlink" title="我们可以做些什么"></a>我们可以做些什么</h3><p>现在的一种流行说法是：先实现财富自由，再去追求诗和远方。但在实现财务自由的过程中，我们自身也会被过程本身塑造，最后我们可能变得只会赚钱。赚钱本来是一种手段，但为了找到实现目标的最优手段花费了我们太多的时间和精力，陷的太深，以至于忽视了，甚至放弃了最初的目标。所谓的不忘初心，莫过于此。</p><p>前面我们引用了齐美尔的那句话，“金钱有点像上帝”，但其实他还有另外一句话：</p><blockquote><p>金钱只是通向最终价值的桥梁，而人是无法栖息在桥上的。  —— 齐美尔</p></blockquote><p>在这座桥上，我们真的能找到安身立命的根本，找到生命的意义吗？这个问题只能留给你自己。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>反观自己，如果专业技术水平没有办法做到专家，那未尝不是一件高兴的事，起码有更多时间精力追求自身的价值判断。</p><p>尽早地规律作息、加强锻炼可以延寿，而延寿是为了可以增加追求自己内心价值的事情的时间。同样地，如果注定要卷入现代社会的疯狂内卷中，那每天除了“996”地追求金钱这个统一的价值标准，也要预留出固定的时间去迎合内心的价值判断，做自己喜欢的事。</p><p>总之，不忘初心，做一个完整的人。</p>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>第一章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《刘擎西方现代思想讲义》｜古今之变</title>
    <link href="/2021/04/30/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E5%8F%A4%E4%BB%8A%E4%B9%8B%E5%8F%98/"/>
    <url>/2021/04/30/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E5%8F%A4%E4%BB%8A%E4%B9%8B%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>历史上是否任何一个时代都可以自称为现代？如果不是，我们所处在时代和以往相比又有哪些不同？启蒙理性主义是如何影响现代社会秩序的建立的？我们又该如何审视当下人们口中频繁讲出的「我喜欢」和「我愿意」？</p><p>在阅读前言和导论的时候，我重点提取了所谓的「现代」的含义，如何从历史的发展来看待「古今之变革」以及具体「变在哪」。</p><p>这样做的一个好处是让我们对现代社会所捕捉的现象，衍生的问题更加敏感。我认为，保持敏感是适时作出合理应对的良好前提。</p><h2 id="现代和现代性"><a href="#现代和现代性" class="headerlink" title="现代和现代性"></a>现代和现代性</h2><p>历史上任何一个时期都有自己“当下的时代”，但并非每一个时期能可以自称为“现代”。</p><p>古人的历史观在学术界被称为“<strong>循环历史观</strong>”，即人们感知到的时间是在不断循环的：日升日落，四季轮回。但直到文艺复兴，这种“循环历史观”才发生改变。人们逐渐意识到，“当下的时代”不再是以往的延续和重复，而是前所未有的，是崭新的。时间不再是循环往复的，而是线性展开的——从过去、到现在，然后通往未来，时间成为一个有方向的适量概念。</p><p>这种时间观念带来几种重要变化：</p><ol><li>我们不能完全依靠传统习俗引导现代生活；</li><li>“线性进步的历史观”让人们认为社会具有不断进步的可能性，即当下及未来比过去更重要；</li><li>人类从循环历史宿命的束缚中解放，成为有自由的、有目的的创造者，成为主宰自己命运的主体。</li></ol><p>现代意味着重大变革，现代也可以被称之为“古今之变”。</p><blockquote><p>一切固定的东西都烟消云散了，一切神圣的东西都被亵渎了。    —— 《共产党宣言》</p></blockquote><p>其中，引发现代变革的动力是“启蒙理性主义”，而“古今之变”催生的产物则是现代社会和现代人。而“现代性”则是现代产物所具有的特点。</p><p>所谓的“启蒙理性主义”是说，直到欧洲的启蒙时代，西方社会才把理性推到了至高无上的地位，理性成为划分“光明”和“黑暗”的决定性标准。而在此之前，理性和信念、情感、感受、直觉、冥想、猜测、灵感等处于平衡之中，都作为人的各种能力而存在。</p><p>启蒙思想的原型起源于古希腊的“洞穴寓言”<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="“洞穴寓言”是柏拉图在《理想国》中提到的，它是说，从小就被禁锢在黑暗中的奴隶，有一天终于走出了洞穴，第一次看到了太阳，才知道洞穴中的一切原来只是虚假的幻象，阳光照耀下的世界才是真实的。太阳代表了理性，让人发现了最高的真善美。">[1]</span></a></sup>。</p><blockquote><p>只有经得住理性的自由、公开检查的东西才能博得理性的尊敬。  —— 康德</p></blockquote><p>启蒙理性主义作为西方古今之变的核心，让理性成为区分真理与蒙昧的决定性标准，成为了衡量一切的准绳。</p><h2 id="“古今之变”变在哪"><a href="#“古今之变”变在哪" class="headerlink" title="“古今之变”变在哪"></a>“古今之变”变在哪</h2><h3 id="个体主观价值的提升"><a href="#个体主观价值的提升" class="headerlink" title="个体主观价值的提升"></a>个体主观价值的提升</h3><p>现代出现了一个新的、关键的问题，即我喜不喜欢，我愿不愿意。</p><p>以前我们说喜欢一件事物总要说些理由出来，只有讲出个一二三来，才能有人信服。但现在问题变得简单多了，基本上说一句“我喜欢”就够了。一方面，“我喜欢”包含了对个人的尊重，对个人的尊重是个人解放的前提，是打破旧有等级体系的力量，是民主化的基础；但另一方面，这种现象又会让人困惑：无论多么伟大、崇高、优美的东西，只要一句“我不在乎”，好像就能否定它的价值。在和别人讨论问题的时候，有些话题只要你说“我喜欢”“我愿意”，对方似乎就无法反驳了。这种轻率和傲慢在过去是不可想象的。</p><p>如果我们做出选择的最高基准是主观意愿的话，“选择”就成了孤证。除了“我的意愿”，不存在任何同等有力的旁证。选择变得脆弱、不稳定。我们可能自己都无法坚信自己的选择。于是，我们一方面处在解放的轻松与兴奋当中，另一方面又处在不确定的、没有把握的焦虑当中；一面习惯于“轻率的傲慢”，一面又常常感到惶恐和不安。</p><h3 id="自然秩序被理性打破"><a href="#自然秩序被理性打破" class="headerlink" title="自然秩序被理性打破"></a>自然秩序被理性打破</h3><p>古代人只遵循一个准则，或者是上帝，或者是传统的教化。而现代人大都“我命由我不由天”。我们抛弃了自然秩序这个神话，得到了自由，代价是：在价值与价值之间很难区分高低优劣，每一种价值都有自己的道理，彼此冲突的观念，谁也说服不了谁。</p><p>共同的神话束缚了我们，却也让我们有了共同的准则。摆脱这个神话之后，我们有了自由，却又陷入混乱和茫然之中。</p><h3 id="新秩序的建立"><a href="#新秩序的建立" class="headerlink" title="新秩序的建立"></a>新秩序的建立</h3><p>在古代，春节是传统，春运不是。但在现代，随着大量人口流动，春运成为了一种新传统。此新秩序的建立本质是因为现代化改变了我们的社会生产和组织方式。</p><h2 id="“古今之变”后的两个观念转变"><a href="#“古今之变”后的两个观念转变" class="headerlink" title="“古今之变”后的两个观念转变"></a>“古今之变”后的两个观念转变</h2><p>一个是“人类中心主义的转变”，另一个是“个人主义的转变”。</p><p>书中关于后者有一个解释比较有意思。在现代社会，大量的人口流动使越来越多的人背井离乡工作和生活。于是，那种无法离开的“血肉相连”的有机共同体变成了一个神话，只有你和你自己才是血肉相连的。这个时候由社群过渡到个人的重要性和优先性就突显出来了。这就是所谓的“个人主义的转向”。</p><p>这种转向带来了传统社会难以想象的个人自由，生活变得多样而丰富，这是现代性的主要成就。但代价是，因为个人失去了与一个特定群体的久远、厚重和牢固的纽带关系，这带来了孤独感、漂泊感和乡愁。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>古今之变的最主要的特征就是从原来的“自然的”变成了“不自然”。</p><p>在现代秩序下，我们要面对两个难题。</p><p>一个与个人生活意义相关。我们不再相信神和传统，那我们的信仰该是什么呢？我们活着的意义是什么呢？如果用理性作答将是十分艰难的。如何找到生活的意义和理由，这是一个难题。</p><p>另一个与社会秩序相关。在以理性为基础的新秩序中，人人自由平等，那最终究竟由谁来统治谁？社会秩序就建立在我们对于这类问题的回答中。</p><p>最后，为了回答这些问题，我们需要拜访一些现代的哲学家、思想家。第一位是马克思·韦伯，因为在作者看来，他的思考标志着现代思想的成年。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>“洞穴寓言”是柏拉图在《理想国》中提到的，它是说，从小就被禁锢在黑暗中的奴隶，有一天终于走出了洞穴，第一次看到了太阳，才知道洞穴中的一切原来只是虚假的幻象，阳光照耀下的世界才是真实的。太阳代表了理性，让人发现了最高的真善美。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>前言</tag>
      
      <tag>导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《十三邀x微信十年》｜如何成为更好的自己</title>
    <link href="/2021/04/28/thought/%E3%80%8A%E5%8D%81%E4%B8%89%E9%82%80x%E5%BE%AE%E4%BF%A1%E5%8D%81%E5%B9%B4%E3%80%8B%EF%BD%9C%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
    <url>/2021/04/28/thought/%E3%80%8A%E5%8D%81%E4%B8%89%E9%82%80x%E5%BE%AE%E4%BF%A1%E5%8D%81%E5%B9%B4%E3%80%8B%EF%BD%9C%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>在短平快的时代里，做一个清醒的现代人，能够自觉，能够掌握自己的生活，这是非常困难的。在这个意义上，如果你能够完成，这将是一个非常光荣的使命。</p><h2 id="语录摘记"><a href="#语录摘记" class="headerlink" title="语录摘记"></a>语录摘记</h2><h3 id="以下是刘擎的语录摘记："><a href="#以下是刘擎的语录摘记：" class="headerlink" title="以下是刘擎的语录摘记："></a>以下是刘擎的语录摘记：</h3><p>微信它是具有反讽的双重性的。</p><p>一方面它是便捷的，丰富的，开放的，自由的，带给我们全新的美妙的体验。</p><p>但另一方面当我们不具有反思性的，依靠本能的愿望使用它的时候，它在便捷当中会带来轻率，在丰富当中会带来另外一种贫乏，在开放当中可能会固化我们已有的见解——变得封闭、部落化、有偏见，而在自由当中我们可能会变得放纵变得失控。</p><p>微信改变了人的存在论的环境，这样就导致了成年人的童稚化。童稚化的一个标志就是我们不太能够延迟满足。</p><p><strong>真正的自由是自己能够把握自己，引导自己，而且向着更好的自我成长。</strong></p><p><strong>更好的自己意味着你能够通过理性的自我掌控变成了一个自己更喜欢的人，你能够讲好一个关于自己的故事。</strong></p><p>如果你是一个沉湎的、失控的、放纵的自己，你讲不好自己的故事，你会讲一堆纷乱的事情，但是你没有办法理解自我，把你自己组织起来整合成一个发展的成长的线索。</p><p>那个更好的自己，它是需要努力的，是需要克制的，需要来辨析自己，需要用理性来主导自己：你必须要来判断这些事情你收到的赞美是你需要的还是不需要的，你必须区分真正的骄傲和虚荣在哪里，真实受到的夸赞和点赞在哪里。那个反思的自我，那个反思的时刻的引入是非常重要的，但是是缺失的。</p><p>所以做一个清醒的现代人，能够自觉，能够掌握自己的生活，这是非常困难的。在这个意义上，如果你能够完成，这将是一个非常光荣的使命。</p><h3 id="以下是许知远的语录摘记："><a href="#以下是许知远的语录摘记：" class="headerlink" title="以下是许知远的语录摘记："></a>以下是许知远的语录摘记：</h3><p>怎么理解一个新技术在自己既有的土壤中生长？</p><p>我们对这件事情没有进行一个深入的讨论和言说，因此会很容易掉入一个非常二元化的思维窠臼：它是不是破坏了我们过去的东西？它是不是丢失了很多缓慢的情感？它是不是使我们思考不再具有深度？</p><p>我们非常容易陷入一种很简化的判断，过去和现在，过去和未来，正面和反面。但事物的发展却不是这样的，<strong>它们永远都在过去之中就孕育着未来，在新生之中就会孕育着腐朽，在腐朽之中又会产生新的可能性。</strong>所有的事物都是这样进行的。</p><p>事实上我们在过去的思考也不见得就有深度，我们也未必一定会移向一个更美好的未来。微信只是做出了一种新的回应方式，现阶段我们正处在迁移过程的挣扎之中。但是我们一定会在这种过程中学会新的游泳的方式的，只是在这个过程中，我们需要邀请更多的人加入去理解这个新事物，这种智识上的回应是非常必要的。</p><h2 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h2><p>在短平快的时代下，我们大多数人都能够保持警惕，但在警惕之下，做一个清醒的人还要保持反思和专注。关于这一点，我反思了自己的不足。</p><p>我自认自己是个相对自律的人，一个好的习惯让我的自我反思过程和有效专注时间的下限是要比同龄人高的。但我不得不进一步反思的是：这样的自律究竟只是出于一种习惯的养成，还是通过真正的哲学反思来主动获取的。</p><p>前者很可能是以牺牲其他娱乐活动为代价，事实上我并不讨厌娱乐活动，我只是讨厌自己在进行一个事先并未赋予其意义与价值的娱乐活动。我也很难轻易地给他人的娱乐活动点赞，因为只有当我能够感受到这件事对ta究竟具有怎样的意义的时候，我才能把自己的点赞和夸赞视为等同。</p><p>进而我把自己的不足推向了“如何成为更好的自己”的问题上。</p><p>正如刘擎教授所说的：<strong>“更好的自己意味着你能够通过理性的自我掌控变成了一个自己更喜欢的人，你能够讲好一个关于自己的故事。”</strong>我觉得我对自己的掌控还不够理性，很多时候只是出于一种直觉。当然，如果按照认识论说的“一切理性都是由感性产生的”的那样，我只有将自己的直觉一步步抽离出一个个抽象的层次，然后清晰自己的认识和表达，才能算作崇高的理性。因此，我并没有很好的自我掌控自己。</p><p>另外一个问题，我能否讲好一个自己的故事，我认为完全没有。我对问题还停留在纷乱的、不清晰的表述层面上，甚至我对自己故事的表达也是如此。当然，这也部分解释了我喜欢哲学的原因，出于一种天然的欣赏（从相对更加故事性、平叙地讲述，我更容易被深刻的、清晰的、简洁的、甚至有点抽象难以理解的表达所吸引来说），还有我对它的需要（指我对自我及世界的本质的认识）。</p><p>我已经逐渐意识到了问题的所在，也在这个过程中更加清晰了喜欢的自己应有的模样。即便这一切才刚刚开始，但直觉告诉我，一切都还来得及。</p>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《作为意志和表象的世界》｜读书笔记</title>
    <link href="/2021/04/26/thought/%E3%80%8A%E4%BD%9C%E4%B8%BA%E6%84%8F%E5%BF%97%E5%92%8C%E8%A1%A8%E8%B1%A1%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/04/26/thought/%E3%80%8A%E4%BD%9C%E4%B8%BA%E6%84%8F%E5%BF%97%E5%92%8C%E8%A1%A8%E8%B1%A1%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在过去的几年时间里，我大部分的时间都是用来学习和理解这个世界上早有人创造出来的东西。</p><p>可能也是伴随着对自身天赋的逐渐意识，我对自己的人生定位开始变成了通过不断的学习和理解，试图更深刻地认识自己以及认识这个世界，同时，对那些天赋异禀，能够改变时代改变世界，甚至思想可以领先所处时代数十年百年的人，表示无比的欣赏和羡慕。</p><p>当然，叔本华就是这样的人。</p><blockquote><p>“人存在于这个世界上，最大的问题是认识本质，包括自我和世界的本质。”</p></blockquote><h2 id="对序言的概括"><a href="#对序言的概括" class="headerlink" title="对序言的概括"></a>对序言的概括</h2><p>在该书的序中，叔本华除了提出了几点阅读建议和要求，以及对版本之间的修调加以说明外，还描述了自己所处时代背景下的哲学现状，和自己所追求的哲学。</p><p>在第一版序言的开篇，作者就说明了这本书在解决什么问题：</p><blockquote><p>这本书所要表达的思想是长久以来哲学家们苦苦探求的东西。伟大的哲学家们用思想照亮前进的道路，遗憾的是，他们仍未找到他们一心想要得到的东西。这种历经努力而没有回报的经历让拥有历史素养的人们感到无望。普林尼说过：“直至成为事实之前，多少事不都是人们认为不可能的吗？”他们都直接放弃寻觅，觉得这一切都是虚妄，就像石头终究不能变成金子，世上不可能有长生仙药一样。</p></blockquote><p>在序中，作者也给出了对读者的三点阅读要求，不要因为深究一个具体的细节而忽略本书的主干思想，要系统整体地看待本书的全部论证程序。本书行文逻辑层层递进，前一章节皆可看作后面章节论调基于的前提，章节内也联系紧密，前后照应。同时，要把本书的序读完（虽然如果一上来就不读序的读者也不会看到这句话哈哈）。在阅读本书前，还要先阅读康德的经世名作《纯粹理性批判》和叔本华的博士论文《充分理由律的四重根》，本书第一部分是对那片博士论文的继承，以及在作者看来康德的某些不正确思想的批评和指正。事实上，在那篇博士论文的开篇，叔本华就对柏拉图和康德盛赞一番，他将柏拉图奉若神明，视康德为一个奇迹，对这两人的思想相当崇敬。</p><blockquote><p>“神圣的柏拉图和惊人的康德同声高呼, 向世人介绍一个法则, 说这个法则可以作为所有哲学探索也可以作为所有其他科学的方法1。他们告诉我们,有两个准则应一视同仁,绝不可厚此薄彼。它们是：统一律和分解律。”   ——《充分理由律的四重根》</p></blockquote><p>但叔本华十分厌恶后来费希特、黑格尔代表的思辨哲学，这集中体现在第二版的序中，他认为哲学成为了一种政治目的和个人目的，很多人为了自己真实的俗世的背后目的宣扬一种他们彼此之间心照不宣的言论，然后将其视为哲学误导大众。对于纯粹的真理他们视若不见，而且也并不想经受追求和发现真理过程中所经历的感受的苦楚，他们只是把哲学当成一种达成自己动机的工具。</p><p>叔本华建议读者在阅读康德经典著作的时候一定要看原著，而不是去看一些经由他人理解而“分泌”<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="“分泌”这个词，最早来自歌德的一种形容，它指“对有意义或者重要的东西的侵蚀”。">[1]</span></a></sup>的产物。他的原话是这样说的：</p><blockquote><p>想要真正地了解哲学，最有效的方式便是在创造者的原著中感受寻找，真正的哲学家原著中所提供的学说比那些经过庸人头脑专属出来的报告更有价值。</p></blockquote><p>以上是我抽取出来的主干层次，当然我建议大家最好都要读一下这些序。单纯是序言，就已经很让我兴奋不已了。</p><p>好了，最后让我们再来总结一下作者提出的三点要求：</p><ol><li>不要因为深究一个具体的细节而忽略本书的主干思想；</li><li>把读完序论作为开始阅读这本书的前提；</li><li>对作者博士论文《充分根据律的四重根——一篇哲学论文》和康德的《纯粹理性批判》有一个大致的了解。</li></ol><h2 id="对充足理由律的四重根的概括"><a href="#对充足理由律的四重根的概括" class="headerlink" title="对充足理由律的四重根的概括"></a>对充足理由律的四重根的概括</h2><h3 id="充足理由律"><a href="#充足理由律" class="headerlink" title="充足理由律"></a>充足理由律</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%85%85%E8%B6%B3%E7%90%86%E7%94%B1%E5%BE%8B">充足理由律</a>可以被概括地表达为：“任何事物都有它之所以如此的理由，或者说任何事物皆可被解释”。</p><p>叔本华首先对充足理由律的本质作出了描述，他说在他之前这条定律的被不明其理的人们滥用了，从而常常使人陷入谬误和混乱。在他看来，充足理由律的两种基本性质被混淆了，一是将它用于判断，即判断为真的理由，其次是将它用于对象的变化，即事物变化的原因，这两者实质上是不同的。事实上，叔本华认为充足理由律有四种不同的意义，即一切表象都可以从四个层次上进行解释，从而将这四种意义比喻为“四重根”。</p><p>充足理由律在叔本华那里具有一种先验的地位，即它是不能证明的。叔本华认为康德等人试图证明它是徒劳无功的，因为为了证明一个特定命题，就必须假定一个给它正确的理由，而这个理由却正是充足理由律。为了证明它，就必须假定它成立，所以证明这个命题将陷入不可避免的循环论证。他的这种思想在一定程度上影响了维特根斯坦。此外叔本华将充足理由律和<a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%9F%9B%E7%9B%BE%E5%BE%8B">无矛盾律</a>、<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E4%B8%80%E5%BE%8B">同一律</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E4%B8%AD%E5%BE%8B">排中律</a>并列，把它看成第四个思维规律。</p><h3 id="四重根"><a href="#四重根" class="headerlink" title="四重根"></a>四重根</h3><p>叔本华认为充足理由律的四种不同表现形式分别是：因果律，逻辑推论，数学证明，行为动机。这四种形式并不作为证明充足理由律的原因，而是充足理由律在这四者中表现其自身。</p><p>叔本华认为因果律只作用于表象之间而和物自体没有丝毫联系，而且一切表象间都受到因果律影响，任何事物的变化都有其先前的一个原因。像上帝这样一个不动的动者或者不存在的东西进入存在被叔本华认为是绝对不可能的。基于这个立场，<strong>叔本华既是个坚定的无神论者又是一个完全的宿命论者</strong>。</p><p>逻辑真理的成立必然存在一个先验的、在它之前的真理，这是充足理由律的表现形式的第二个形式。叔本华将引导至真理的途径分为逻辑的，经验的，先验的，超验的。这四种理由和根据证明真理本身的同时也表现了充足理由律。<br>因果律中的表象被认为是时间和空间中纯粹直观的表象，而时间和空间本身是在对表象观察中被感性地连续知觉到的表象，两者间的本质区别是物质。这里叔本华沿用了康德的看法，时间和空间分别对应于数学和几何。时空中的表象是数学证明的前提而不是它可证明的依据。</p><p>人的行为动机被叔本华认为是充足理由律第四种形式。也就是说，人的每一个行为必有其动机上的原因，并从动机上得到解释。事实上这一看法引出了他的另一部著作《作为意志和表象的世界》，也奠定了它的伦理学说。</p><h2 id="批判康德哲学"><a href="#批判康德哲学" class="headerlink" title="批判康德哲学"></a>批判康德哲学</h2><p>叔本华对康德是充满赞美之情的。在对康德哲学批判的附录标题上，他引用了伏尔泰的话：<em>“真正的天才可以犯错而不受责难，这是他们的特权”</em>。</p><p>叔本华认为康德的最大功绩不是他的认识论，而在于他划分了表象和物自体之间的区别。他认为康德错误地假定知觉包括想象，将直观和思维混淆起来。康德构造了将感性直观和知性十二范畴共同构成经验对象的理论。叔本华发现若按照这种理论，表象世界就成了既是直观又是思维，既非直观又非思维的东西。而且这样一来动物要么就具有思维，要么就连外在世界的表象也没有了，这显然是不合情理的。</p><p>在康德那里，因果律是先验的，所有的经验知觉都是处于主观之上，不可能区别或认识物自体。而叔本华认为仅用直观我们就能获得经验对象。关于物自体的知识，是通过理智这种内在感觉而获得的，它只在时间的形式中被认识。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>叔本华为这部悲观主义巨著作出了乐观的预言：这部书不是为了转瞬即逝的年代而是为了全人类而写的。</p><p>的确如此，我早已兴奋不已，准备开始阅读这部超越时代，并且成为整个人类文明经典的著作了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%9B%BE%E5%B0%94%C2%B7%E5%8F%94%E6%9C%AC%E5%8D%8E">维基百科</a></li><li>《充分理由律的四重根》</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>“分泌”这个词，最早来自歌德的一种形容，它指“对有意义或者重要的东西的侵蚀”。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界读书日的由来</title>
    <link href="/2021/04/23/info/%E4%B8%96%E7%95%8C%E8%AF%BB%E4%B9%A6%E6%97%A5%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <url>/2021/04/23/info/%E4%B8%96%E7%95%8C%E8%AF%BB%E4%B9%A6%E6%97%A5%E7%9A%84%E7%94%B1%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="美丽传说"><a href="#美丽传说" class="headerlink" title="美丽传说"></a>美丽传说</h2><p>世界读书日来源于一个骑士屠龙的悲壮故事。</p><p>在1700多年前的罗马帝国时代，有一个叫圣乔治的巴勒斯坦人，生于260年。他长大后加入了罗马军队，因为骁勇善战，屡立战功，成为一名罗马骑兵军官。</p><p>当时，欧洲有一个城堡，城堡堡主的女儿长得非常美丽，引来了恶龙的垂涎。恶龙威胁堡主，要他把女儿献给自己。圣乔治闻讯后，跨上战马，带着长枪前往城堡拯救堡主的女儿。到了城堡，圣乔治与恶龙进行了一番激烈的搏斗，最后，凭借自己的勇敢和指挥，杀死了这条祸害当地老百姓的恶龙，解救了堡主的女儿。恶龙流出的血在地上形成了一个十字形。</p><p>堡主的女儿为了表示感谢之情，送了圣乔治一本书。从此，书籍就成了胆识和力量的象征。</p><p>不过，圣乔治由于跟恶龙搏斗时耗费了所有的精力，筋疲力尽而亡，年仅43岁。这一年，是303年。</p><p>圣乔治死后700年，成了英格兰的守护圣人。</p><p>那是十字军第三次东征(1189—1192年)的事情了。英格兰国王理查一世成为十字军第三次东征的统帅。理查一世因勇猛善战而号称“狮心王理查”。他当了10年国王，期间不关心处理政务，而是将全部心思花在征战上。期间，理查一世在当年圣乔治屠龙附近的地方，与拥有优势兵力的敌人作战，在极度不利的情况下，终于扭转战局，击败了敌人，取得了胜利。</p><p>理查一世认为，这是圣乔治的神灵在保护英格兰，便将圣乔治封为英格兰的守护圣人，并将圣乔治死去的日子4月23日，作为“圣乔治日”。每到这一天，全国宣布放假，人们要向爱人送一支玫瑰，向孩子送一本书。</p><p>1277年，英格兰根据圣乔治屠龙时龙血的形状，设计出一款白底红十字的“圣乔治旗”，这就是后来的英格兰国旗。</p><p>圣乔治的故事，不但成为英格兰文化很重要的一部分，还在德国、格鲁吉亚、保加利亚、葡萄牙以及加泰罗尼亚等受英格兰文化影响的国家和地区流传。在15世纪之前，圣乔治日作为一个重要的节日，与圣诞节享受一样的待遇。只不过，后来圣乔治日逐渐被人们淡忘。</p><h2 id="灵感来自于西班牙浪漫传统"><a href="#灵感来自于西班牙浪漫传统" class="headerlink" title="灵感来自于西班牙浪漫传统"></a>灵感来自于西班牙浪漫传统</h2><p>选择4月23日的灵感来自于西班牙加泰罗尼亚地区的一个传统。1926年，当时的西班牙国王设立了“西班牙自由节”，并把伟大作家塞万提斯的生日10月7日作为这个节日的庆祝日。1930年庆祝活动移到4月23日——塞万提斯的忌日，这一天也是加泰罗尼亚大众节日“圣乔治节”（加泰罗尼亚一直在坚持圣乔治日）。相传勇士乔治屠龙救公主，并获得了回赠一本书册，象征着知识与力量。一些欧洲国家将这种传统延续至今。</p><p>加泰罗尼亚地区作为“读书日”缘起传说的发祥地有一个传统，你会看到很多人拿着玫瑰在街上走，像是情人节一样，十分有趣。妇女们就给丈夫或男朋友赠送一本书，男人们则回赠一支玫瑰花。如今每到4月23日这一天，当地的书籍会减价10%，玫瑰花的价格则陡然上涨。</p><h2 id="文学大师们的生日与忌日"><a href="#文学大师们的生日与忌日" class="headerlink" title="文学大师们的生日与忌日"></a>文学大师们的生日与忌日</h2><p>4月23日与世界上很多著名作家也有很大关系：它是莎士比亚出生和去世的日期，也是塞万提斯、西班牙游记作家何西·布拉、秘鲁文学家加尔西拉索去世的日子，还是纳博科夫、法国作家莫里斯·德鲁昂、冰岛诺贝尔文学奖获得者拉克斯内斯、哥伦比亚小说家曼努埃尔·梅希亚·巴列霍等人的生日。</p><h2 id="庆幸生在这一天"><a href="#庆幸生在这一天" class="headerlink" title="庆幸生在这一天"></a>庆幸生在这一天</h2><p>是的，很荣幸可以生在世界读书日这一天，与这么多伟大的思想家作家同一天。自打小时候有记忆以来，我从来都是对书有莫名好感的。自己喜欢书，也同样喜欢爱书的人。爱读书，谈吐举止中洋溢着书生气的人往往也会给我带来莫名的好感，与这些人的交流中，我往往能得到启发，或者产生强烈的共鸣。人的爱好可能不止一个，喜欢的人或事也不只一类，但于我而言，读书，读书之人，却几乎是我所有的喜欢里之最的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.guidaye.com/h/sj/512699.html">“4月23日世界读书日”的由来</a></li><li><a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E8%AF%BB%E4%B9%A6%E6%97%A5">百度百科</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
