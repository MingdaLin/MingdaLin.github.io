<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>项目梳理-商城秒杀系统</title>
    <link href="/2021/08/27/tech/project/%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86-%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80/"/>
    <url>/2021/08/27/tech/project/%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86-%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="商城秒杀"><a href="#商城秒杀" class="headerlink" title="商城秒杀"></a>商城秒杀</h1><h2 id="需求点梳理"><a href="#需求点梳理" class="headerlink" title="需求点梳理"></a>需求点梳理</h2><h3 id="项目简介-amp-重点模块梳理"><a href="#项目简介-amp-重点模块梳理" class="headerlink" title="项目简介 &amp; 重点模块梳理"></a>项目简介 &amp; 重点模块梳理</h3><p>该项目是一个高并发场景下的商品秒杀活动。</p><p>除了一些边缘模块外，项目核心内容有两个：分别是下单秒杀前的削峰限流，和下单后保证用事务异步更新销量和扣减库存。</p><p><em><strong>削峰限流</strong></em></p><p>削峰限流主要是在用户下单前通过验证、限流等策略大都缓冲、平滑流量的目的。具体实现流程和用到的技术为：</p><ol><li>通过增加验证码来平滑访问流量；</li><li>通过限制大闸，颁发令牌进行削峰（考虑到商品库存100，而秒杀用户量为10w的场景，只需颁发1000个令牌即可）；</li><li>通过引入限流器（采用令牌桶算法），限制单机TPS，防止服务器挂掉；</li><li>通过引入线程池进行缓冲，再由线程池管理线程进行生产者发送消息。</li></ol><p><img src="/img/2021/%E5%89%8A%E5%B3%B0%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88.png" alt="削峰限流方案"></p><p><em><strong>更新销量</strong></em></p><p>由于更新销量不影响用户秒杀操作，所以可以放到MQ里异步更新。否则直接操作数据库要加锁，影响性能。</p><p><em><strong>扣减库存</strong></em></p><p>由于秒杀是在高并发场景下进行的，在较短时间间隔有大量用户对同一商品资源进行互斥访问，数据库加锁的方式吞吐量太低，因此考虑先用Redis缓存库存，再最终将库存信息通过MQ异步写入数据库中。</p><h3 id="超卖-amp-少卖"><a href="#超卖-amp-少卖" class="headerlink" title="超卖 &amp; 少卖"></a>超卖 &amp; 少卖</h3><p><em><strong>超卖</strong></em>：超卖是说用户下单量超过商品的库存量。在真实场景中，对用户下单并未完全达成同步，导致少扣库存了，这将导致用户体验不佳，在实际中很少采用。</p><p><em><strong>少卖</strong></em>：少卖是说最终用户的付款量少于商品的库存。在实际中，用户可能下单后又退款了，这对收益不会有很严重的影响，但是不会有超卖的用户体验不佳的问题，在实际中大多采用少卖。</p><p>少卖的解决方案：</p><ol><li><p>一个想到的解决方案是利用RocketMq的延时消费机制，为队列设置一个延时时间，用户下单的时候进入队列，在规定付款时间之后进行消费，消费时，可以通过检查订单状态（已付款和未付款自动取消订单）来确定是否进行消费。</p></li><li><p>如果用redis来解决的话，将提交的订单按创建时间写入到一个队列里，然后设定时间间隔轮询队头对时间做差，如果超过付款时间出队，检查订单付款状态，如果没付款，自动回补库存，如果付款，将消息封装到MQ进行消费。</p></li></ol><h3 id="问题点梳理"><a href="#问题点梳理" class="headerlink" title="问题点梳理"></a>问题点梳理</h3><p><em><strong>Mq第二阶段check的时候为什么要存流水，查订单不行吗？</strong></em></p><p>订单在本地事物生成的时候可能会有延时，当订单生成成功时，可能还没来得及写到数据库里，这时check的时候并不能说明本地事务是失败的。</p><p>用流水check的好处在于，在生产者发送消息之前先产生了一个流水存在数据库里，这样check的时候肯定能查到这条数据，同时，本地事务包含了流水的更新，通过查状态值可以判断本地事务是否已经提交。</p><h2 id="开发逻辑梳理"><a href="#开发逻辑梳理" class="headerlink" title="开发逻辑梳理"></a>开发逻辑梳理</h2><ul><li>controller<ul><li>ItemController <ul><li>getItemList [前端展示商品列表]</li><li>getItemDetail [前端展示商品详情]</li></ul></li><li>OrderController<ul><li>getCaptcha [用户点击获取二维码][削峰限流-二维码平滑]<ul><li>验证用户<code>login_token</code></li><li>以<code>userid</code>为K，<code>kaptcha</code>为V，存到redis(String)</li><li>将<code>response</code>存到服务器，用于后续颁发令牌验证 <!--这个response里有什么，怎么验证--></li></ul></li><li>generateToken [颁发令牌][削峰限流-令牌桶算法][promotionService.generateToken]<ul><li>验证验证码</li><li>生成令牌，返回给用户</li></ul></li><li>create [创建订单][削峰限流-单机限流&amp;缓冲队列][orderService.createOrderAsync]<ul><li>单机限流</li><li>验证活动凭证-令牌token（通过PromotionService.generateToken生成的）</li><li>通过线程池（缓冲队列）调用mq</li><li>异步创建订单</li></ul></li></ul></li><li>UserController<ul><li>login </li><li>logout</li><li>getUser [根据token获取用户信息]</li></ul></li></ul></li><li>service  <!--1. 商品和库存与活动实体是关联的；      1. 用户对商品信息的查询用到了二级缓存，增加查询效率；      2. 扣减库存的时候，为了并发的请求量，用redis预减库存，最后同步到数据库，保证最终一致性；      Q：数据库和redis是如何保证最终一致的？  --><ul><li>ItemService [查询商品信息，扣减库存]<ul><li>findItemsOnPromotion [查库存和活动]<ul><li>select item from item_table by promotion [联合索引，最左匹配]</li><li>select stock from stock_table by item</li><li>select promotion from promotion_table by item</li></ul></li><li>findItemById [mysql查商品信息]<ul><li>select item from item_table by id [主键查询]</li><li>select stock from stock_table by item [外键查询]</li><li>select promotion from promotion_table by item [外键查询]</li></ul></li><li>findItemInCache [redis查商品信息]<ul><li>查本地缓存guava [二级缓存]</li><li>查redis缓存</li><li>查mysql数据库<ul><li>写到guava</li><li>写到redis</li></ul></li></ul></li><li>increaseSales [增加订单]<ul><li>select amount from item_table for update [X锁]</li></ul></li><li>decreaseStock [从数据库中删减库存]<ul><li>select stock from item_table for update [X锁]</li></ul></li><li>decreaseStockInCache [从redis中删减库存]<ul><li>直接在redis中扣减库存，得到扣减后的结果result [redis(String)]</li><li>result &lt; 0: 回补库存</li><li>result == 0: 售窑标识</li></ul></li><li>increaseStockInCache [从redis中增加库存]<ul><li>在redis中增加库存 [redis(String)]</li></ul></li><li>createItemStockLog</li><li>updateItemStockLogStatus [更新流水状态]</li><li>findItemStorkLogById [查询流水状态]</li></ul></li><li>OrderService <ul><li>createOrder [][][itemService.updateItemStockLogStatus][&amp;executeLocalTransaction.createOrder]<ul><li>预扣库存 (并发场景下如果直接走库需要加锁，性能低) [redis]</li><li>生成订单 (生成订单流水，作为主键id，方便分表) [分表]</li><li>更新销量 [mq]</li><li>更新库存流水状态 </li></ul></li><li>createOrderAsync [异步创建订单(没有实际创建，只是mq发送消息)][][][&amp;OrderController.create]<ul><li>生成库存流水 [itemService.createItemStockLog]</li><li>mq第一阶段发送消息 [rocketMQTemplate.sendMessageInTransaction][mqTransaction-1.send]</li><li>得到响应 [][mqTransaction-2.OK]</li></ul></li></ul></li><li>PromotionService<ul><li>generateToken<ul><li>生成token</li><li>放到redis里缓存</li></ul></li></ul></li></ul></li><li>mq<ul><li>producer<ul><li>executeLocalTransaction [执行本地事务][mqTransaction-3.transaction]<ul><li>createOrder [创建订单][mqTransaction-4.commit/rollback][orderService.createOrder,itemService.updateItemStockLogStatus(false)]</li></ul></li><li>checkLocalTransaction [回查][mqTransaction-5.check]<ul><li>checkStockStatus [查询流水状态][mqTransaction-6.checkStatus&amp;7.commit/rollback][itemService.findItemStorkLogById]</li></ul></li></ul></li><li>consumer<ul><li>DecreaseStockConsumer<ul><li>onMessage [itemService.decreaseStock]</li></ul></li><li>IncreaseSalesConsumer<ul><li>onMessage [itemService.increaseSales]</li></ul></li></ul></li></ul></li></ul><h2 id="技术点梳理"><a href="#技术点梳理" class="headerlink" title="技术点梳理"></a>技术点梳理</h2><h3 id="mq原理"><a href="#mq原理" class="headerlink" title="mq原理"></a>mq原理</h3><p>RocketMQ两阶段提交的过程概述</p><p>1.事务消息发送及提交：</p><ul><li>发送消息（half消息）。</li><li>服务端响应消息写入结果。</li><li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</li><li>根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</li></ul><p>2.补偿流程：</p><ul><li>对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</li><li>Producer收到回查消息，检查回查消息对应的本地事务的状态</li><li>根据本地事务状态，重新Commit或者Rollback</li></ul><p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p><p><img src="/img/2021/ROCKETMQ%E4%BA%8B%E5%8A%A1%E5%9E%8B%E6%B6%88%E6%81%AF.png" alt="ROCKETMQ事务型消息"></p><h3 id="mq的使用场景"><a href="#mq的使用场景" class="headerlink" title="mq的使用场景"></a>mq的使用场景</h3><p>producer：发送本地事务；回查</p><p>consumer：增加销量、扣减库存</p><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><p>结合代码对业务逻辑进行梳理；<br>结合业务实现对涉及到的技术点进行梳理；</p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>项目梳理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>项目梳理-社区论坛系统</title>
    <link href="/2021/08/26/tech/project/%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86-%E7%A4%BE%E5%8C%BA%E8%AE%BA%E5%9D%9B/"/>
    <url>/2021/08/26/tech/project/%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86-%E7%A4%BE%E5%8C%BA%E8%AE%BA%E5%9D%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h1><p><img src="/img/2021/login_module.png" alt="登录模块"></p><h2 id="登录页面（未登录）"><a href="#登录页面（未登录）" class="headerlink" title="登录页面（未登录）"></a>登录页面（未登录）</h2><h3 id="开发内容"><a href="#开发内容" class="headerlink" title="开发内容"></a>开发内容</h3><ol><li>账号、密码、验证码的显示；</li><li>颁发登录凭证（登录凭证是要落库的（ticket））</li><li>页面跳转</li></ol><h3 id="开发实现"><a href="#开发实现" class="headerlink" title="开发实现"></a>开发实现</h3><p>登录：</p><ol><li>验证账号、密码、验证码</li><li>成功：给客户端颁发登录凭证</li><li>失败：跳转到登录页面</li></ol><p>退出登录：</p><ol><li>将登录凭证的状态改为失效</li><li>跳转至网页首页</li></ol><p><em><strong>controller</strong></em></p><ol><li>检测验证码[起初用session来存，后期用redis优化]</li><li>检测账号密码[查库 mapper(User_table)][在内部service层颁发了ticket][ticket起初存库，后用redis优化]</li><li>使用cookie为client颁发ticket</li><li>success -&gt; ‘/index’ ; false -&gt; ‘/site/login’</li></ol><p><em><strong>service</strong></em></p><ol><li>在<code>UserService.login</code>里进行[验证码、账号、密码]的校验，设置用户的登录状态，以及创建[凭证]，设置登录状态；</li><li>在<code>UserService.loginout</code>里修改[凭证]里的登录状态；</li></ol><p><em><strong>entity</strong></em></p><p>ticket要封装为一个实体类，包含[用户id、登录状态、过期时间]等属性信息。</p><h3 id="技术盘点"><a href="#技术盘点" class="headerlink" title="技术盘点"></a>技术盘点</h3><ol><li>redis数据结构的选用</li><li>URL重定向</li><li>cookie &amp; session</li></ol><h2 id="登录页面展示（已登录）"><a href="#登录页面展示（已登录）" class="headerlink" title="登录页面展示（已登录）"></a>登录页面展示（已登录）</h2><h3 id="开发内容-1"><a href="#开发内容-1" class="headerlink" title="开发内容"></a>开发内容</h3><p>在论坛的任何动态页面，都要在导航栏的头像下拉菜单里显示登录信息。</p><ol><li>需要自定义一个登录拦截器，并重写拦截器方法；</li><li>对拦截器进行配置；</li></ol><h3 id="开发实现-1"><a href="#开发实现-1" class="headerlink" title="开发实现"></a>开发实现</h3><p>通过拦截器对所有请求进行拦截，在整个登录周期内，对用户登录状态进行校验，并以线程隔离的方式持有用户信息。</p><ol><li>定义一个拦截器<ul><li>prehandler：进行ticket验证，并使用threadlocal将User实体 保存在hostHolder实体里；</li><li>posthandler: 返回一个User实体的modelAndView；</li><li>aftercompletion: 清除hostHolder；</li></ul></li><li>对拦截器进行配置<ul><li>对静态页面不进行拦截，只对动态页面的请求进行拦截；</li><li>对所有controller的请求都进行拦截；</li></ul></li></ol><h2 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h2><h3 id="开发内容-2"><a href="#开发内容-2" class="headerlink" title="开发内容"></a>开发内容</h3><ol><li>自定义注解，在需要拦截的方法里加上这个自定义注解</li><li>定义一个拦截器，重写方法（需要对handler进行判断，捕获HandlerMethod的handler -&gt; 获取handler的method -&gt; 反射获取自定义注解的方法）</li><li>对拦截器进行配置</li></ol><h1 id="question"><a href="#question" class="headerlink" title="question"></a>question</h1><ol><li>过完拦截器登录页面的展示 &amp; aop实现日志记录，回过头对比下这两个，interceptor &amp; aop ，为什么登录页面用的是拦截器，日志记录用的是aop？</li><li>interceptor 的@Override 一定程度上反映了MVC的工作原理，需要对Spring MVC相关知识点进行关联掌握；</li><li>interceptor 在何时进行拦截的？（以登陆信息拦截为例）</li><li>为什么在[拦截登录信息-持有用户信息]的时候要使用threadlocal？</li><li>为什么用hostHolder代替session对象？可以在请求结束后清除？</li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1347180610715681">拦截器原理</a></li></ol><h1 id="点赞、关注"><a href="#点赞、关注" class="headerlink" title="点赞、关注"></a>点赞、关注</h1><p><img src="/img/2021/like_service.png" alt="点赞业务逻辑关系"></p><p><img src="/img/2021/follow_service.png" alt="关注业务逻辑关系"></p><h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><ol><li>把权限验证进行梳理 [done]</li><li>spring mvc 执行过程进行梳理 [todo] </li><li>拦截器原理进行梳理 [todo]</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>项目梳理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring知识点梳理</title>
    <link href="/2021/08/25/tech/JavaEE/Spring%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/25/tech/JavaEE/Spring%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC：控制反转（Inversion of Control）容器，是一种设计思想。它意味着将对象交给容器控制，而不是开发者在对象内部控制。IoC是通过DI来实现的。</p><blockquote><p>谁控制谁？IoC容器来控制对象。<br>控制什么？控制了外部资源获取（不只是对象包括比如文件等）<br>为什么是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转。<br>什么被反转了？依赖对象的获取被反转了。</p></blockquote><p>DI：依赖注入（Dependency Injection），组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。IoC和DI其实是同一个概念的不同角度描述。</p><p>DI是通过IoC容器来实现的。</p><p><img src="/img/2021/%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8EIoC%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94.png" alt="传统获取对象的方式与IoC方式对比"></p><h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><p>IoC容器本质是一个工厂。Spring主要提供了两种类型的容器。</p><p><em><strong>BeanFactory</strong></em></p><p>BeanFactory是IoC容器的顶层接口，ApplicationContext是在BeanFactory之上创建的。</p><p>BeanFactory一般采用延迟初始化的策略。只有当客户端访问容器里的对象的时候，才对对象进行初始化和依赖注入。因此容器启动初期速度较快。</p><p><em><strong>ApplicationContext</strong></em></p><p>ApplicationContext 在BeanFactory功能至上，还有事件发布等功能。</p><p>ApplicationContext 在容器启动时就完成所有对象的初始化，因此启动需要的资源多，启动慢。  </p><h2 id="Bean的管理"><a href="#Bean的管理" class="headerlink" title="Bean的管理"></a>Bean的管理</h2><p> Spring通过Ioc容器对Bean进行管理。可以通过注解或者xml文件的方式进行配置。</p><p> 管理Bean常用的注解：</p><ul><li><code>@ComponentScan</code>用于声名扫描Bean的策略，对哪些包哪些类型的Bean进行扫描；</li><li><code>@Component``Repository``Service``Controller</code>用于声明Bean；</li><li><code>@Autowired``@Qualifier</code>用于注入Bean；<code>Autowired</code>按照Bean的类型进行匹配，如果同一类型的Bean有多个，可以通过<code>@Qualifier</code>按Bean的名称进行匹配；</li><li><code>@Scope</code>用于声明Bean的作用域，Bean默认是单例的</li><li><code>PostConstruct``PreDestory</code>用于声明Bean的生命周期，<code>PostConstruct</code>在Bean初始化后调用，<code>PreDestory</code>在销毁Bean之前调用；</li></ul><h2 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h2><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>Spring 只管理单例模式Bean的完整生命周期。</p><p><code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解在Bean创建和销毁阶段调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationBean</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(AnnotationBean.class);<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;AnnotationBean start&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;AnnotationBean destroy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h2><h3 id="aop-amp-spring-aop"><a href="#aop-amp-spring-aop" class="headerlink" title="aop &amp; spring aop"></a>aop &amp; spring aop</h3><p>AOP(Aspect oriented programming)面向切面编程，是OOP的一种补充。</p><p>OOP的一大特性——继承，体现了对象之间的“上下关系”，而AOP的切面之间则可以为分散的对象提供公共行为，是一种“左右关系”。</p><p>利用AOP可以为业务逻辑进行解耦，提高开发效率。</p><p>spring aop 有两种实现方式：</p><ul><li>JDK动态代理:这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默 认采用这种方式，在接口的代理实例中织入代码。 </li><li>CGLib动态代理:采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。</li></ul><p><img src="/img/2021/AOP&OOP.png" alt="AOP &amp; OOP"></p><h3 id="filter-amp-interceptor-amp-aop"><a href="#filter-amp-interceptor-amp-aop" class="headerlink" title="filter &amp; interceptor &amp; aop"></a>filter &amp; interceptor &amp; aop</h3><ul><li>Filter：和框架无关，过滤器拦截的是URL，可以控制最初的http请求，但是更细一点的类和方法控制不了。</li><li>Interceptor：拦截器拦截的也是URL，拦截器有三个方法，相对于过滤器更加细致，有被拦截逻辑执行前、后等。</li><li>AOP: 面向切面拦截的是类的元数据（包、类、方法名、参数等） 相对于拦截器更加细致，而且非常灵活，拦截器只能针对URL做拦截，而AOP针对具体的代码，能够实现更加复杂的业务逻辑。</li></ul><table><thead><tr><th></th><th>filter</th><th>interceptor</th><th>aop</th></tr></thead><tbody><tr><td>使用方式</td><td>函数回调</td><td>反射机制</td><td>动态代理</td></tr><tr><td>使用场景</td><td>处理URL，过滤一些非法URL、非法字符，</td><td>日志记录、权限检查</td><td>日志记录、性能监控、权限控制、缓存优化、事务管理（声明式事务）</td></tr><tr><td>粒度</td><td>粗</td><td>中</td><td>细</td></tr></tbody></table><p><a href="https://www.huaweicloud.com/articles/9554509.html">filter interceptor 使用场景</a></p><h2 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h2><ol><li>通知（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理；通知类型，主要有以下几种：<ul><li>Before ：前置通知，在连接点方法前调用；对应Spring中@Before注解；</li><li>After ：后置通知，在连接点方法后调用；对应Spring中的@After注解；</li><li>AfterReturning：返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常；对应Spring中的@AfterReturning注解；</li><li>AfterThrowing：异常通知，当连接点方法异常时调用；对应Spring中的@AfterThrowing注解；</li><li>Around：环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法；对应Spring中的@Around注解；</li></ul></li><li>连接点（Join Point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用，可以说目标对象中的方法就是一个连接点；</li><li>切点（Pointcut）: 就是连接点的集合；对应Spring中的@Pointcut注解；</li><li>切面（Aspect）: 切面是通知和切点的结合；对应Spring中的注解@Aspect修饰的一个类；</li><li>目标对象（Target object）：即被代理的对象；</li><li>代理对象（AOP proxy）：包含了目标对象的代码和增强后的代码的那个对象；</li></ol><h2 id="AOP实现"><a href="#AOP实现" class="headerlink" title="AOP实现"></a>AOP实现</h2><h2 id="spring-aop的使用"><a href="#spring-aop的使用" class="headerlink" title="spring aop的使用"></a>spring aop的使用</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.cnblogs.com/zyly/p/13171660.html">https://www.cnblogs.com/zyly/p/13171660.html</a></li><li><a href="https://www.cnblogs.com/joy99/p/10941543.html">https://www.cnblogs.com/joy99/p/10941543.html</a></li><li><a href="https://www.pdai.tech/md/spring/spring-aop.html">https://www.pdai.tech/md/spring/spring-aop.html</a></li><li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html</a></li></ol><h1 id="SpringBoot注解"><a href="#SpringBoot注解" class="headerlink" title="SpringBoot注解"></a>SpringBoot注解</h1><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p><code>@RequestMapping</code>是用于处理请求地址映射的注解，请求地址为类地址和方法地址的拼接（如果类上没有该注解则直接为方法地址）。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol><li><code>value</code>：指定请求的实际地址，指定的地址可以是URI Template 模式；</li><li><code>method</code>： 指定请求的method类型， GET、POST、PUT、DELETE等；</li><li><code>consumes</code>： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</li><li><code>produces</code>: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li><li><code>params</code>： 指定request中<strong>必须</strong>包含某些参数值时，才让该方法处理。</li><li><code>headers</code>： 指定request中<strong>必须</strong>包含某些指定的header值，才能让该方法处理请求。</li></ol><blockquote><p>在设置<code>value</code>参数的时候，可能涉及的相关注解为：<a href="#PathVariable">@PathVariable</a>；<br>在设置<code>params</code>参数的时候，可能涉及的相关注解为：<a href="#RequestParam">@RequestParam</a>；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// value可以是一个具体的URI，也可以是含有变量的URI（URI Template Patterns with Path Variables–restful风格）。</span><br><span class="hljs-meta">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testPathVariable</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id2)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;testPathVariable: &quot;</span> + id2);<br>    <span class="hljs-keyword">return</span> SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/J080624/article/details/55193269">参考</a></p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p><code>@PathVariable</code>用来获得请求url中的动态参数，一般修饰于方法中的入参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;  <br><br>     <span class="hljs-meta">@RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET)</span>  <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLogin</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> String userId,  </span></span><br><span class="hljs-function"><span class="hljs-params">         <span class="hljs-meta">@PathVariable(&quot;roleId&quot;)</span> String roleId)</span></span>&#123;<br>           <br>         System.out.println(<span class="hljs-string">&quot;User Id : &quot;</span> + userId);  <br>         System.out.println(<span class="hljs-string">&quot;Role Id : &quot;</span> + roleId);  <br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;  <br>     <br>     &#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p><code>@RequestParam</code>用于获取request请求的参数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CopperVO&gt; <span class="hljs-title">getOpList</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-meta">@RequestParam(value = &quot;pageIndex&quot;, required = false)</span> Integer pageIndex,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-meta">@RequestParam(value = &quot;pageSize&quot;, required = false)</span> Integer pageSize)</span> </span>&#123;<br><br> &#125;<br><br></code></pre></td></tr></table></figure><h2 id="ResponseBody-amp-RequestBody"><a href="#ResponseBody-amp-RequestBody" class="headerlink" title="@ResponseBody &amp; @RequestBody"></a>@ResponseBody &amp; @RequestBody</h2><p><code>@ResponseBody</code>用于将Controller的方法返回的对象，根据HTTP Request Header的Accept的内容,通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p><code>@ResponseBody</code>使用在返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用.</p><p><code>@RequestBody</code>用于将Controller的方法参数，根据HTTP Request Header的content-Type的内容,通过适当的HttpMessageConverter转换为JAVA类</p><p><code>@RequestBody</code>使用在POST或者PUT的数据是JSON格式或者XML格式,而不是普通的键值对形式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/testRequestBody&quot;, method= RequestMethod.POST)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">testRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Person p)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;creating a employee:&quot;</span> + p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;   <br></code></pre></td></tr></table></figure><p><img src="/img/2021/@ResponseBody&@RequestBody%E4%BD%BF%E7%94%A8.png" alt="数据的格式的转换过程"></p><p><a href="https://www.jianshu.com/p/7097fea8ce3f">参考</a></p><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p><code>@RestController</code>和<code>@ResponseBody</code>注解都会处理返回的数据格式，使用了该类型注解后返回的不再是视图，不会进行转跳，而是返回json或xml数据格式，输出在页面上。</p><p>二者的区别在于：<code>@ResponseBody</code>，一般是使用在单独的方法上的，需要哪个方法返回json数据格式，就在哪个方法上使用，具有针对性；<code>@RestController</code>，一般是使用在类上的，它表示的意思其实就是结合了<code>@Controller</code>和<code>@ResponseBody</code>两个注解，如果哪个类下的所有方法需要返回json数据格式的，就在哪个类上使用该注解，具有统一性；</p><p>使用了<code>@RestController</code>注解之后，其本质相当于在该类的所有方法上都统一使用了@ResponseBody注解，所以该类下的所有方法都会返回json数据格式，输出在页面上，而不会再返回视图。</p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>JavaEE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-J.U.C梳理</title>
    <link href="/2021/08/21/tech/JavaSE/Java-JUC%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/21/tech/JavaSE/Java-JUC%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>线程安全的实现方法包含: 互斥同步: synchronized 和 ReentrantLock 非阻塞同步: CAS, AtomicXXXX 无同步方案: 栈封闭，Thread Local，可重入代码</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本地存储（ThreadLocal）是一个为每个线程创建单独的变量副本的类, 避免因多线程操作共享变量而导致的数据不一致的情况。</p><p>其特点在于，共享变量在不同线程间不存在依赖关系。</p><p>ThreadLocal比较常见的应用场景是，session管理和数据库链接管理。</p><h2 id="对于ThreadLocal的理解（为什么要用ThreadLocal）"><a href="#对于ThreadLocal的理解（为什么要用ThreadLocal）" class="headerlink" title="对于ThreadLocal的理解（为什么要用ThreadLocal）"></a>对于ThreadLocal的理解（为什么要用ThreadLocal）</h2><p>对于下面的这个数据库管理类，在多线程情况下，它可能会存在线程同步问题：不同的线程可能会多次调用<code>openConnection</code> 建立连接；t1调用connect进行数据库操作，t2调用<code>closeConnection</code>关闭链接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Connection connect = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (connect == <span class="hljs-keyword">null</span>) &#123;<br>            connect = DriverManager.getConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> connect;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (connect != <span class="hljs-keyword">null</span>)<br>            connect.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然可以通过<code>synchronzied</code>方法或者<code>ReentrantLock</code>进行线程间的同步，但是发现不同线程间的<code>connect</code>不存在依赖关系。而ThreadLocal可以为每个线程创建单独的变量副本，避免因多线程操作共享变量而导致的数据不一致的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Connection&gt; dbConnectionLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> DriverManager.getConnection(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dbConnectionLocal.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果我们希望通过某个类将状态(例如用户ID、事务ID)与线程关联起来，那么通常在这个类中定义private static类型的ThreadLocal实例。</p></blockquote><h2 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h2><p>ThreadLocal通过ThreadLocalMap类对当前线程及其threadlocals（线程局部变量，即共享变量）进行缓存，实现线程隔离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">setInitialValue</span><span class="hljs-params">()</span> </span>&#123;<br>    T value = initialValue();<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap 本质就是一个Map，区别在于：</p><ol><li>ThreadLocalMap 属于ThreadLocal的静态内部类</li><li>用Entry数组来存储Key, Value；Entry继承了<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，降低对内存的占用；哈希冲突的时候采用顺移落位。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br><br>    <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>    <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>    <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>    <span class="hljs-comment">// path would fail more often than not.</span><br><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>         e != <span class="hljs-keyword">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocal的内存泄漏问题"><a href="#ThreadLocal的内存泄漏问题" class="headerlink" title="ThreadLocal的内存泄漏问题"></a>ThreadLocal的内存泄漏问题</h2><h3 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h3><p>使用线程池操作ThreadLocal对象的时候，因为线程池里面有不会销毁的线程，存在着对ThreadLocal的强引用，这就导致被final static修饰的ThreadLocalMap的弱引用也不会释放，因此会造成内存泄漏问题。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>通过调用ThreadLocal类提供的remove方法，该方法通过调用ThreadLocalMap的remove方法，根据key把对应Entry删除，从而防止内存泄漏。</p><h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>如synchronized、Lock等都是采取阻塞同步策略的悲观锁，而原子工具类则是采用非阻塞同步策略实现的乐观锁。</p><p>原子变量类比锁的粒度更细，更轻量。原子变量将发生竞争的范围缩小到单个变量上。</p><p>原子类在内部使用 CAS 指令（基于硬件的支持）来实现同步。这些指令通常比锁更快。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS 全称 Compare And Swap（比较与交换），CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</p><p>是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p><p>在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。J.U.C包中的原子类就是通过 CAS 来实现了乐观锁。</p><p>CAS存在的问题：</p><ol><li>ABA</li><li>自旋时间长开销大</li><li>只能保证一个共享变量的原子操作</li></ol><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html</a></p><h2 id="原子类API使用"><a href="#原子类API使用" class="headerlink" title="原子类API使用"></a>原子类API使用</h2><p>略</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><h3 id="AQS（抽象队列同步器）"><a href="#AQS（抽象队列同步器）" class="headerlink" title="AQS（抽象队列同步器）"></a>AQS（抽象队列同步器）</h3><p>抽象队列同步器（AbstractQueuedSynchronizer）是一种构建锁和同步器的框架，如：ReentrantLock、Semaphore、ReentrantReadWriteLock、SynchronousQueue。</p><p>AQS的核心思想是：如果被请求的共享资源空闲，线程设为有效，共享资源设为锁定状态；如果被请求的共享资源被占用，需要一套线程阻塞等待以及被唤醒时锁分配的机制。</p><h3 id="AQS底层原理"><a href="#AQS底层原理" class="headerlink" title="AQS底层原理"></a>AQS底层原理</h3><p><em><strong>同步状态变量</strong></em></p><p>AQS使用一个int成员变量<code>state</code>来表示同步状态，通过<code>CAS</code>操作该同步状态（<code>state</code>）进行原子操作实现对其值的修改。</p><p><em><strong>同步队列</strong></em></p><p>AQS底层的数据结构是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。</p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。</p></blockquote><p>具体实现为：用双向链表实现的同步队列和用单向链表实现的条件队列。同步队列是必须的，条件队列不是必须的，但当存在多个条件时，条件队列可以为多个。</p><p><img src="/img/2021/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="AQS数据结构"></p><p><em><strong>AQS共享方式</strong></em></p><ul><li>独占（Exclusive）：只有一个线程能执行，如ReentrantLock。独占锁又分为公平锁和非公平锁。<ul><li>公平锁：线程按照在队列中的顺序，先到先得锁；</li><li>非公平锁：无视队列顺序，谁抢到就是谁的。</li></ul></li><li>共享（share）：多个线程可同时执行，如ReadWriteLock、Semaphore</li></ul><blockquote><p>在实现上，非公平比公平只是多加了一个CAS操作的条件判断。</p></blockquote><p>AQS通过调用<code>acquire</code>方法以独占模式获取资源。</p><p>在<code>acquire</code>方法做了这些事：</p><ol><li>通过调用<code>tryAcquire</code>方法，调用此方法的线程会试图在独占模式下获取对象状态；（需要开发者重写）</li><li>通过调用<code>addWaiter</code>方法，将线程封装成一个结点（Node类），放到Sync queue里；</li><li>调用<code>acquireQueued</code>方法，让Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。</li></ol><p>AQS通过<code>release</code>方法以独占模式释放资源。</p><p>在 <code>release</code>方法中做了这些事：</p><ol><li>通过<code>tryRelease</code>方法，去释放锁；</li><li>如果释放成功了，调整同步队列的结构，把占用完资源的线程出队。</li></ol><p>AQS通过调用<code>acquireShared</code>方法以共享模式获取资源。<br>AQS通过调用<code>releaseShared</code>方法以共享模式释放资源。</p><h3 id="AQS需要子类实现的方法"><a href="#AQS需要子类实现的方法" class="headerlink" title="AQS需要子类实现的方法"></a>AQS需要子类实现的方法</h3><table><thead><tr><th>方法名</th><th>方法描述</th></tr></thead><tbody><tr><td>tryAcquire</td><td>以独占模式尝试获取锁，独占模式下调用acquire，尝试去设置state的值，如果设置成功则返回，如果设置失败则将当前线程加入到等待队列，直到其他线程唤醒</td></tr><tr><td>tryRelease</td><td>尝试独占模式下释放状态</td></tr><tr><td>tryAcquireShared</td><td>尝试在共享模式获得锁，共享模式下调用acquire，尝试去设置state的值，如果设置成功则返回，如果设置失败则将当前线程加入到等待队列，直到其他线程唤醒</td></tr><tr><td>tryReleaseShared</td><td>尝试共享模式下释放状态</td></tr><tr><td>isHeldExclusively</td><td>是否是独占模式，表示是否被当前线程占用</td></tr></tbody></table><h3 id="Node节点信息"><a href="#Node节点信息" class="headerlink" title="Node节点信息"></a>Node节点信息</h3><table><thead><tr><th>字段名</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>SHARED</td><td>Node</td><td>new Node()</td><td>一个标识，指示节点使用共享模式等待</td></tr><tr><td>EXCLUSIVE</td><td>Nodel</td><td>Null</td><td>一个标识，指示节点使用独占模式等待</td></tr><tr><td><code>CANCELLED</code></td><td>int</td><td>1</td><td>节点因超时或被中断而取消时设置状态为取消状态</td></tr><tr><td><code>SIGNAL</code></td><td>int</td><td>-1</td><td>当前节点的后节点被park，当前节点释放时，必须调用unpark通知后面节点，当后面节点竞争时，会将前面节点更新为<code>SIGNAL</code></td></tr><tr><td><code>CONDITION</code></td><td>int</td><td>-2</td><td>标识当前节点已经处于等待中，通过条件进行等待的状态</td></tr><tr><td><code>PROPAGATE</code></td><td>int</td><td>-3</td><td>共享模式下释放节点时设置的状态，被标记为当前状态是表示无限传播下去</td></tr><tr><td><code>0</code></td><td>int</td><td></td><td>不属于上面的任何一种状态</td></tr><tr><td>waitStatus</td><td>int</td><td>0</td><td>等待状态，默认初始化为0，表示正常同步等待，</td></tr><tr><td>pre</td><td>Node</td><td>Null</td><td>队列中上一个节点</td></tr><tr><td>next</td><td>Node</td><td>Null</td><td>队列中下一个节点</td></tr><tr><td>thread</td><td>Thread</td><td>Null</td><td>当前Node操作的线程</td></tr><tr><td>nextWaiter</td><td>Node</td><td>Null</td><td>指向下一个处于阻塞的节点</td></tr></tbody></table><h3 id="AQS底层设计模式"><a href="#AQS底层设计模式" class="headerlink" title="AQS底层设计模式"></a>AQS底层设计模式</h3><p>AQS底层使用了模板方法模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">isHeldExclusively()<span class="hljs-comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br>tryAcquire(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br>tryRelease(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br>tryAcquireShared(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br>tryReleaseShared(<span class="hljs-keyword">int</span>)<span class="hljs-comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></code></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><!--todo 给出一个方法调用关系逻辑图--><h3 id="同步状态变量"><a href="#同步状态变量" class="headerlink" title="同步状态变量"></a>同步状态变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<span class="hljs-comment">//共享变量，使用volatile修饰保证线程可见性</span><br><br><span class="hljs-comment">//返回同步状态的当前值</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> state;<br>&#125;<br> <span class="hljs-comment">// 设置同步状态的值。</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newState)</span> </span>&#123; <br>        state = newState;<br>&#125;<br><span class="hljs-comment">//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类的继承关系"><a href="#类的继承关系" class="headerlink" title="类的继承关系"></a>类的继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 版本序列号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">3737899427754241961L</span>;<br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractOwnableSynchronizer</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-comment">// 独占模式下的线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;<br>    <br>    <span class="hljs-comment">// 设置独占线程 </span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> </span>&#123;<br>        exclusiveOwnerThread = thread;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取独占线程 </span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title">getExclusiveOwnerThread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> exclusiveOwnerThread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>transient：一个对象只要实现了Serilizable接口,这个对象就可以被序列化。当一个类的某些属性需要序列化，而其他属性不需要被序列化，比如一些敏感信息(如密码)，为了安全起见，不希望在网络操作中被传输，这些信息对应的变量就可以加上transient关键字。</p></blockquote><h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-comment">// 模式，分为共享与独占</span><br>    <span class="hljs-comment">// 共享模式</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br>    <span class="hljs-comment">// 独占模式</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;        <br>    <span class="hljs-comment">// 结点状态</span><br>    <span class="hljs-comment">// CANCELLED，值为1，表示当前的线程被取消</span><br>    <span class="hljs-comment">// SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark</span><br>    <span class="hljs-comment">// CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中</span><br>    <span class="hljs-comment">// PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行</span><br>    <span class="hljs-comment">// 值为0，表示当前节点在sync队列中，等待着获取锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;        <br><br>    <span class="hljs-comment">// 结点状态</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;        <br>    <span class="hljs-comment">// 前驱结点</span><br>    <span class="hljs-keyword">volatile</span> Node prev;    <br>    <span class="hljs-comment">// 后继结点</span><br>    <span class="hljs-keyword">volatile</span> Node next;        <br>    <span class="hljs-comment">// 结点所对应的线程</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;        <br>    <span class="hljs-comment">// 下一个等待者</span><br>    Node nextWaiter;<br>    <br>    <span class="hljs-comment">// 结点是否在共享模式下等待</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取前驱结点，若前驱结点为空，抛出异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>        <span class="hljs-comment">// 保存前驱结点</span><br>        Node p = prev; <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 前驱结点为空，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 前驱结点不为空，返回</span><br>            <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 无参构造方法</span><br>    Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>        Node(Thread thread, Node mode) &#123;    <span class="hljs-comment">// Used by addWaiter</span><br>        <span class="hljs-keyword">this</span>.nextWaiter = mode;<br>        <span class="hljs-keyword">this</span>.thread = thread;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span><br>        <span class="hljs-keyword">this</span>.waitStatus = waitStatus;<br>        <span class="hljs-keyword">this</span>.thread = thread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核心方法——acquire方法"><a href="#核心方法——acquire方法" class="headerlink" title="核心方法——acquire方法"></a>核心方法——acquire方法</h3><p>该方法以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，线程获取对象状态，看是否可以获得该对象的锁状态。如果可以获得，直接获得，返回。</p><p>如果不能获得，将线程封装成一个结点放到同步队列，不断尝试获取资源。</p><h3 id="核心方法——release方法"><a href="#核心方法——release方法" class="headerlink" title="核心方法——release方法"></a>核心方法——release方法</h3><p>以独占模式释放对象。</p><p><code>tryRelease</code>的默认实现是抛出异常，需要具体的子类实现，如果<code>tryRelease</code>成功，那么如果头结点不为空并且头结点的状态不为0，则释放头结点的后继结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// 释放成功</span><br>        <span class="hljs-comment">// 保存头结点</span><br>        Node h = head; <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// 头结点不为空并且头结点状态不为0</span><br>            unparkSuccessor(h); <span class="hljs-comment">//释放头结点的后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>ReentrantLock为可重入锁，相对于synchronized，它是API层面的互斥锁。</p><p>ReentrantLock 是基于AQS实现的。它有公平锁和非公平锁两种实现方式。</p><p>整个类的继承关系为：ReentrantLock继承了Lock类，在重写lock方法的时候调用了AQS的<code>acquire</code>方法，在<code>acquire</code>方法内部需要重写<code>tryAcquire</code>方法，ReentrantLock分别为FairSync和NonFairSync重写了<code>tryAcquire</code>方法。</p><p>从源码来看，FairSync与NonFairSync都是基于CAS操作实现可重入的，在实现上FairSync只是追加了一步判断：通过判断当前线程是否为同步队列的队头，来看是否有等待更久的线程，从而判断是否满足公平条件。</p><h2 id="ReentrantLock-amp-synchronized-区分"><a href="#ReentrantLock-amp-synchronized-区分" class="headerlink" title="ReentrantLock &amp; synchronized 区分"></a>ReentrantLock &amp; synchronized 区分</h2><p><img src="/img/2021/ReentrantLock&synchronized.png" alt="ReentrantLock &amp; synchronized.png"></p><h2 id="ReentrantLock-UML"><a href="#ReentrantLock-UML" class="headerlink" title="ReentrantLock UML"></a>ReentrantLock UML</h2><p><img src="/img/2021/ReentrantLock-UML.png" alt="ReentrantLock-UML"></p><ol><li>ReentrantLock实现了Lock接口；ReentrantLock 通过调用<code>lock</code>方法获得锁；<code>lock</code>方法里用的是AQS的<code>acquire</code>方法；AQS的<code>acquire</code>方法里调用了<code>tryAquire</code>方法；ReentrantLock需要重写<code>tryAquire</code>方法；</li><li>ReentrantLock包含了Sync对象；Sync继承于AQS；在Sync中实现了<code>FairSync</code>和<code>NonFairSync</code>；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    acquire(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对”1”的解释：它是设置“锁的状态”的参数也可以称为重入数。对于“独占锁”而言，锁处于可获取状态时，它的状态值是0；锁被线程初次获取到了，它的状态值就变成了1。由于ReentrantLock(公平锁/非公平锁)是可重入锁，所以“独占锁”可以被单个线程多此获取，每获取1次就将锁的状态+1。也就是说，初次获取锁时，通过acquire(1)将锁的状态值设为1；再次获取锁时，将锁的状态值设为2；依次类推…这就是为什么获取锁时，传入的参数是1的原因了。</p></blockquote><h2 id="NonFairSync"><a href="#NonFairSync" class="headerlink" title="NonFairSync"></a>NonFairSync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="hljs-comment"> * subclasses, but both need nonfair try for trylock method.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>    <span class="hljs-keyword">int</span> c = getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-keyword">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h2><p>公平锁就比非公平锁多了一步判断：看当前线程是否位于同步队列的队头，如果在队头，说明没有等待更久的线程，符合公平策略，可以进行独占；否则反之。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 公平锁</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-comment">// 版本序列化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="hljs-comment">        * recursive call or no waiters or is first.</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-comment">// 尝试公平获取锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取当前线程</span><br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-comment">// 获取状态</span><br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 状态为0</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="hljs-comment">// 公平锁比非公平锁就多了这一步判断！</span><br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123; <span class="hljs-comment">// 不存在已经等待更久的线程并且比较并且设置状态成功</span><br>                <span class="hljs-comment">// 设置当前线程独占</span><br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="hljs-comment">// 状态不为0，即资源已经被线程占据</span><br>            <span class="hljs-comment">// 下一个状态</span><br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 超过了int的表示范围</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            <span class="hljs-comment">// 设置状态</span><br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>hasQueuedPredecessors</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断&quot;当前线程&quot;是不是在CLH队列的队首，来返回AQS中是不是有比“当前线程”等待更久的线程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;<br>    Node t = tail; <br>    Node h = head;<br>    Node s;<br>    <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>        ((s = h.next) == <span class="hljs-keyword">null</span> || s.thread != Thread.currentThread());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.cnblogs.com/dwlsxj/p/reentrantlock-principle-nonfairsync.html">https://www.cnblogs.com/dwlsxj/p/reentrantlock-principle-nonfairsync.html</a></li><li><a href="https://yuanrengu.com/2020/7691e770">https://yuanrengu.com/2020/7691e770</a></li><li><a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html">https://www.pdai.tech/md/java/thread/java-thread-x-lock-ReentrantLock.html</a></li></ol><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h2><h3 id="线程池是干什么的？"><a href="#线程池是干什么的？" class="headerlink" title="线程池是干什么的？"></a>线程池是干什么的？</h3><p>线程池的本质是<strong>对任务和线程进行解耦和管理</strong>，减少在线程创建、销毁、调度等过程中的开销。</p><ol><li>每次new Thread新建对象性能差。 </li><li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 </li><li>缺乏更多功能，如定时执行、定期执行、线程中断。</li></ol><p>相比new Thread，线程池的好处在于：</p><ol><li>重用存在的线程，减少对象创建、消亡的开销，性能佳。 </li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 </li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ol><h3 id="Java是如何实现和管理线程池的"><a href="#Java是如何实现和管理线程池的" class="headerlink" title="Java是如何实现和管理线程池的?"></a>Java是如何实现和管理线程池的?</h3><p>从JDK 5开始，把工作单元与执行机制分离开来，工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p><h3 id="线程池的运行机制"><a href="#线程池的运行机制" class="headerlink" title="线程池的运行机制"></a>线程池的运行机制</h3><p>线程池内部是一个生产者消费者模型，将线程和任务解耦。线程池的运行包含两个部分：任务管理、线程管理。任务管理扮演生产者角色，线程管理扮演消费者角色。当任务提交后，后续流转为：1、直接申请线程执行该任务；2、缓冲到队列中等待线程执行；3、拒绝该任务。</p><p><img src="/img/2021/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="线程池的运行流程"></p><h3 id="线程池的生命周期"><a href="#线程池的生命周期" class="headerlink" title="线程池的生命周期"></a>线程池的生命周期</h3><p>线程池内线程的运行状态（runState）和线程数量（workerCount）由一个变量进行管理，高3位保存runState，低29位保存workCount。</p><p>运行状态：</p><ul><li>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务；</li><li>SHUTDOWN：关闭状态，不再接受新提交的任务，但可以处理阻塞队列中的任务</li><li>STOP：不接受新任务，也不处理阻塞队列中的任务</li><li>TIDYING：所有任务都已经终止，workerCount=0</li><li>TERMINATED：在terminated()方法执行完进入该状态</li></ul><p><img src="/img/2021/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程池生命周期"></p><h2 id="对任务的管理"><a href="#对任务的管理" class="headerlink" title="对任务的管理"></a>对任务的管理</h2><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><ol><li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>通过阻塞队列对任务进行管理。线程池对任务的管理的本质在于通过队列进行缓冲。</p><p><img src="/img/2021/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="线程池阻塞队列"></p><h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>任务执行有两种情况，一种是新创建线程执行任务，另一种是从阻塞队列中拿任务执行。前者用于初始化线程的时候，小于corePoolSize和workCount &lt; maximumPoolSize &amp;&amp; BlockQueue队满的时候。一般都是发生在第二种case。</p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><ol><li>丢弃任务并抛出异常</li><li>丢弃任务但不抛异常</li><li>丢弃队列最前面的任务，然后把新任务加到阻塞队列中</li><li>将任务交给main线程处理</li></ol><h2 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h2><p>worker线程继承AQS，但并非ReentrantLock，原因在于使用不可重入反应线程当前执行状态。 </p><h3 id="worker线程的构造方法"><a href="#worker线程的构造方法" class="headerlink" title="worker线程的构造方法"></a>worker线程的构造方法</h3><p>worker线程通过firstTask进行构造，firstTask可以有也可以没有，非空对应核心线程创建，空对应非核心线程创建。</p><h3 id="线程增加"><a href="#线程增加" class="headerlink" title="线程增加"></a>线程增加</h3><p>通过addWorker方法实现，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程。该方法只是新增一个线程，返回成功结果。</p><!--上个阶段是指？--><h3 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h3><p>线程回收是通过jvm的。</p><p>jvm的回收策略涉及对被回收对象的引用，而线程池做的就是保持对工作线程的引用。</p><p>worker被创建之后，分为核心线程和非核心线程。前者可以无限等待任务，后者需要限时获取任务。</p><p>worker获取不到任务的时候，就会消除对线程的引用，等待被回收。</p><blockquote><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p></blockquote><h3 id="worker线程执行任务过程"><a href="#worker线程执行任务过程" class="headerlink" title="worker线程执行任务过程"></a>worker线程执行任务过程</h3><p>通过runWorker方法执行任务，具体过程为，</p><ol><li>while循环不断通过getTast获取任务</li><li></li></ol><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="对于继承关系的解释"><a href="#对于继承关系的解释" class="headerlink" title="对于继承关系的解释"></a>对于继承关系的解释</h3><ol><li>顶层接口``Executor`提供了一种思想：将任务提交和任务执行进行解耦。</li><li><code>ExecutorService</code>接口增加了一些能力：<ul><li>扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法</li><li>提供了管控线程池的方法，比如停止线程池的运行</li></ul></li><li><code>AbstractExecutorService</code>将执行流程进行串联，保证下层的实现只需关注一个执行任务的方法即可。</li><li><code>ThreadPoolExecutor</code>实现最复杂的运行部分，一方面维护自身的生命周期，另一方面同时管理线程和任务。</li></ol><h3 id="入参解释"><a href="#入参解释" class="headerlink" title="入参解释"></a>入参解释</h3><ol><li>corePoolSize</li><li>maximumPoolSize</li><li>keepAliveTime：空闲线程存活时间</li><li>unit: 空闲线程存活时间单位</li><li>workQueue：工作队列<ul><li>ArrayBlockQueue</li><li>LinkedBlokingQueue</li><li>SynchronousQueue</li><li>PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂</li><li>handler：拒绝策略</li></ol><h3 id="不同类型的线程池"><a href="#不同类型的线程池" class="headerlink" title="不同类型的线程池"></a>不同类型的线程池</h3><p><em><strong>newFixedThreadPool</strong></em></p><p>线程池的线程数量达corePoolSize后，即使线程池没有可执行任务时，也不会释放线程。 </p><p>FixedThreadPool的工作队列为无界队列LinkedBlockingQueue(队列容量为Integer.MAX_VALUE), 这会导致以下问题: </p><ul><li>线程池里的线程数量不超过corePoolSize,这导致了maximumPoolSize和keepAliveTime将会是个无用参数 </li><li>由于使用了无界队列, 所以FixedThreadPool永远不会拒绝, 即饱和策略失效 ¶</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>newSingleThreadExecutor</strong></em></p><p>初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行. 由于使用了无界队列, 所以SingleThreadPool永远不会拒绝, 即饱和策略失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>newCachedThreadPool</strong></em></p><p>线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；</p><p>和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；</p><p>执行过程与前两种稍微不同: </p><ul><li>主线程调用SynchronousQueue的offer()方法放入task, 倘若此时线程池中有空闲的线程尝试读取 SynchronousQueue的task, 即调用了SynchronousQueue的poll(), 那么主线程将该task交给空闲线程. 否则执行(2) </li><li>当线程池为空或者没有空闲的线程, 则创建新的线程执行任务. </li><li>执行完任务的线程倘若在60s内仍空闲, 则会被终止. 因此长时间空闲的CachedThreadPool不会持有任何线程资源. </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                    <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程梳理</title>
    <link href="/2021/08/20/tech/JavaSE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/20/tech/JavaSE/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="并发三要素"><a href="#并发三要素" class="headerlink" title="并发三要素"></a>并发三要素</h2><p>Java并发的三要素：可见性、原子性、有序性。线程不安全即这三个性质有至少一个被破坏了。</p><p>这三个要素分别是什么意思？分别由什么来保障的？即这个东西没有保障才导致的现成安全问题。</p><p>接下来，我们先来介绍这三个要素是什么，然后说明是什么最终导致了这三个要素的破坏，进而使线程不安全。最后，再来说Java是如何保证线程安全的。</p><p>可见性：一个线程对共享变量的修改，别的线程立即可见。</p><blockquote><p>立即可见是说，不同的线程对应不同的cpu去使用共享变量去做运算，而共享变量是放在主存里的，所有线程对共享变量进行操作改变其值，都要写回主存，让其他线程可见。<br>这意味着，如果一个线程对共享变量的修改没有及时写回主存，让其他线程看到，而其他线程用了共享变量的旧值做了运算，就违背了可见性。</p></blockquote><p>在计算机中，可见性的破坏是由什么导致的呢？<br>答案是cpu缓存！<br>以下面代码为例，对于多线程编程，如果thread1使用的是cpu1，thread2使用的是cpu2，当thread1执行<code>i=10</code>时，计算机做的是把i的初始值先加载到cpu1的高速缓存中，然后再赋值为10，再写回主存。而如果thread2把i的值加载到它的高速缓存发生在cpu1把<code>i=10</code>写回主存之前，那j的值就还是0.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程1执行的代码</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>i = <span class="hljs-number">10</span>;<br> <br><span class="hljs-comment">//线程2执行的代码</span><br>j = i;<br></code></pre></td></tr></table></figure><p>原子性：一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>以经典的转账问题为例：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。如果只进行了第一个步骤，而因为某些原因，没有执行第二个步骤，就破坏了原子性。</p><p>有序性：程序执行的顺序按照代码的先后顺序执行。<br>但是计算机为了提高执行性能，编译器和处理器会对指令进行重排序。这就间接导致内存可见性的问题。</p><blockquote><p>重排序分为编译器优化重排序、指令级并行重排序、内存系统重排序，第一个属于编译器重排序，后两个属于处理器重排序。</p></blockquote><p>Java是如何解决并发问题的？<br>通过Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。<br>具体的方法有：volatile、synchronized 和 final 三个关键字，Happens-Before 规则。<br>接下来具体来说分别是如何保证三要素的。</p><p>原子性的保证：是通过synchronized和Lock来保证原子性的。（synchronized和Lock能够保证任一时刻只有一个线程执行该代码块）<br>原子操作：读取、赋值（必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">x = <span class="hljs-number">10</span>;        <span class="hljs-comment">//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span><br>y = x;         <span class="hljs-comment">//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span><br>x++;           <span class="hljs-comment">//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span><br>x = x + <span class="hljs-number">1</span>;     <span class="hljs-comment">//语句4： 同语句3</span><br></code></pre></td></tr></table></figure><p>可见性的保证：volatile关键字（当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。）<br>通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><p>有序性的保证：volatile只能保证一部分的有序性。而synchronized和Lock可以完全保证有序性。JMM层面是通过Happens-Before规则保证有序性的。<br>❓❓❓Happens-Before和前几种方法有什么关系，它具体是怎么实现的？</p><p>共享变量按照安全强度分为五个安全级别：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。<br>不可变：如String类这种被final修饰过的数据类型。<br>绝对线程安全：不管运行时环境如何，调用者都不需要任何额外的同步措施。<br>相对线程安全：对象调用的时候不作同步措施，但在程序连续执行调用的顺序上，要通过同步手段（加锁）保证调用的正确性。<br>线程兼容：对象本身并非线程安全的，在调用的时候就要通过同步手段保证线程安全。</p><blockquote><p>线程安全的类：绝大多数平常使用的类，比如HashMap、StringBuilder等。<br>线程不安全的类：JUC包下的类，如NonCurrentHashMap，<br>线程对立： 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。（在代码中很少出现，略）</p></blockquote><p>线程安全的实现方法：<br>互斥同步：synchronized 和 ReentrantLock。</p><h2 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h2><p><img src="/img/2021/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程生命周期"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> DemoThread());<br></code></pre></td></tr></table></figure><p>创建线程基本就用这个方法。只是传参的时候，要传一个Runnable Target，用Thread创建线程，也是要重写Runnable接口的run方法。</p><blockquote><p>Thread和Runnable的关系：Thread类是Runnable接口的实现类。</p></blockquote><p>当然也可以自定义一个线程类，直接implements Runnable接口，@Override run方法。</p><h3 id="线程生命周期中的方法调用"><a href="#线程生命周期中的方法调用" class="headerlink" title="线程生命周期中的方法调用"></a>线程生命周期中的方法调用</h3><p>参考：<a href="https://www.cnblogs.com/paddix/p/5381958.html">https://www.cnblogs.com/paddix/p/5381958.html</a></p><p>wait、notify、sleep、yield、join</p><blockquote><p>wait和notify是Object的方法，sleep、yield、join是Thread类方法。</p></blockquote><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>wait是将当前运行的线程挂起（进入阻塞状态），知道notify来唤醒该线程。</p><p>wait方法是通过monitor对象来实现的。</p><p>wait方法的使用要放在同步范围内，即：在synchronized修饰的代码块内</p><h4 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify/notifyAll"></a>notify/notifyAll</h4><p>notify表示持有对象锁的线程准备释放对象锁权限。</p><blockquote><p>调用wait方法后，线程会释放对monitor对象的所有权；</p><p>一个通过wait方法阻塞的线程，必须同时满足以下两个条件才能被唤醒：</p><ol><li>需要超时唤醒或调用了notify/notifyAll方法</li><li>线程唤醒后竞争到锁（monitor）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWait</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;START-------&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            wait(<span class="hljs-number">0</span>); <span class="hljs-comment">// wait使用</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;END-------&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span>  Test test = <span class="hljs-keyword">new</span> Test();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    test.testWait();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (test) &#123;<br>            test.notify(); <span class="hljs-comment">// notify使用</span><br>        &#125;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        System.out.println(<span class="hljs-string">&quot;分割线------------&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (test) &#123;<br>            test.notifyAll(); <span class="hljs-comment">// notifyAll使用</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>sleep方法和wait方法功能类似，但是调用起来更简单。这是说，<strong>wait方法依赖于同步，而sleep方法可以直接调用</strong>。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>yield是暂停当前线程（将Running状态改为Runnable状态），以便其他线程有机会执行。</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>join是父线程等待子线程执行完再执行，将异步执行的线程合并为同步执行。</p><p>join是通过wait方法将线程阻塞，如果join的线程还在执行，就把当前线程阻塞起来，直到join的线程执行完成，再执行当前线程。</p><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h2><p>synchronized可以锁对象，也可以锁一个类。</p><h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3><p>对象锁包括方法锁（默认锁对象为this，当前实例对象）和同步代码块锁（用户指定锁对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence); <span class="hljs-comment">// 两个线程抢同一个对象资源</span><br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">我是线程Thread-0</span><br><span class="hljs-comment">Thread-0结束</span><br><span class="hljs-comment">我是线程Thread-1</span><br><span class="hljs-comment">Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//指定锁的对象，然后接一个同步代码块，</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br>    <span class="hljs-comment">// 创建2把锁</span><br>    Object block1 = <span class="hljs-keyword">new</span> Object();<br>    Object block2 = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span><br>        <span class="hljs-keyword">synchronized</span> (block1) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (block2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*输出：</span><br><span class="hljs-comment">block1锁,我是线程Thread-0</span><br><span class="hljs-comment">block1锁,Thread-0结束</span><br><span class="hljs-comment">block2锁,我是线程Thread-0　　// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把</span><br><span class="hljs-comment">block1锁,我是线程Thread-1</span><br><span class="hljs-comment">block2锁,Thread-0结束</span><br><span class="hljs-comment">block1锁,Thread-1结束</span><br><span class="hljs-comment">block2锁,我是线程Thread-1</span><br><span class="hljs-comment">block2锁,Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//锁方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        method();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h3><p>锁静态方法或直接锁类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence1 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence2 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        method();<br>    &#125;<br><br>    <span class="hljs-comment">// synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence1);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence2);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">我是线程Thread-0</span><br><span class="hljs-comment">Thread-0结束</span><br><span class="hljs-comment">我是线程Thread-1</span><br><span class="hljs-comment">Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 锁类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedObjectLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence1 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br>    <span class="hljs-keyword">static</span> SynchronizedObjectLock instence2 = <span class="hljs-keyword">new</span> SynchronizedObjectLock();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 所有线程需要的锁都是同一把</span><br>        <span class="hljs-keyword">synchronized</span>(SynchronizedObjectLock.class)&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(instence1);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(instence2);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*输出：</span><br><span class="hljs-comment">我是线程Thread-0</span><br><span class="hljs-comment">Thread-0结束</span><br><span class="hljs-comment">我是线程Thread-1</span><br><span class="hljs-comment">Thread-1结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="synchronized的原理"><a href="#synchronized的原理" class="headerlink" title="synchronized的原理"></a>synchronized的原理</h2><h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p>synchronized的底层是使用操作系统的mutex lock实现的。</p><!--mutex lock是什么？--><blockquote><p>锁的内存语义是指：1、当线程释放锁时，JMM会把线程对应的本地内存中的共享变量刷到主存中；2、当线程获取锁时，JMM把线程的本地内存置为无效，从而使moter监视的临界区代码需要到主存读取共享变量。</p></blockquote><p>可见性的保证：一个共享变量执行lock操作会清空工作内存中改变量的值，使用前从主存load该变量的值。一个共享变量执行unlock操作前，把该变量的值write到主存中。</p><p>原子性的保证：持有同一个锁的两个同步代码块只能串行执行。</p><h3 id="synchronized锁"><a href="#synchronized锁" class="headerlink" title="synchronized锁"></a>synchronized锁</h3><p>结合synchronized的使用，这一部分涉及两个问题，一个是java如何实现代码块的同步的，另一个是synchronized如何实现线程对对象锁的持有和释放的。</p><p>第一个问题：</p><p>代码块和方法同步的实现原理：在JVM层面，是通过进入和退出monitor对象来实现的。通过在代码块开始和结束的地方加入monitorentor 和 monitorexit指令进行标识，当执行到monitorentor的时候，如果该对象没有被锁定或者该线程之前就具有该对象的锁，则锁计数器+1，当执行到monitorexit时，要对锁计数器-1，当锁计数器为0时，该线程释放对该对象的锁。</p><p>第二个问题：</p><p>synchronized用的锁存在对象头里。这个锁——监视器锁（Monitor）本质是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。</p><blockquote><p> 互斥锁的作用在于：用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。</p></blockquote><p>互斥锁的工作方式：</p><p><img src="/img/2021/mutex%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.jpeg" alt="mutex工作方式"></p><p>线程A获取对象的锁后，线程B如果再申请对象的锁，会进行自旋，直到A释放锁对象，B才能获取对象锁。</p><p>该过程涉及线程的阻塞和唤醒，在os层面对象用户态到核心态的转换，开销很大。因此在java1.6，对锁进行了优化。</p><h3 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h3><p>锁信息在java对象头的MarkWord里。</p><p><img src="/img/2021/java%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpeg" alt="java对象头"></p><h2 id="JVM锁优化"><a href="#JVM锁优化" class="headerlink" title="JVM锁优化"></a>JVM锁优化</h2><p>当程序初次进入synchronized代码块的时候，对象头里的锁状态由<strong>无锁</strong>转换为偏向锁。<strong>偏向锁</strong>表现为同一线程可重入（Mark Word里存有线程ID）。</p><p>当存在锁竞争时，偏向锁升级为<strong>自旋锁</strong>（轻量级锁）。</p><blockquote><p>偏向锁相对自旋锁只有一次CAS操作，效率极高。而自旋锁存在“忙等”，涉及多次CAS操作。</p></blockquote><p>当锁竞争严重时（自旋次数超过阈值），自旋锁将再次升级为<strong>重量级锁</strong>。</p><p><img src="/img/2021/%E9%94%81%E5%8D%87%E7%BA%A7.png" alt="锁升级"></p><p>在整个获得锁和释放锁的过程中，通过CAS操作修改对象头里的锁标志位。</p><blockquote><p>CAS是一种能够实现变量同步无锁算法。该算法涉及三个操作数，需要读写的内存值V。进行比较的值A（工作内存对主存V的拷贝副本），和要写入的新值B。当且仅当V = A时，CAS用B来更新V，否则不执行任何操作。</p><p>CAS存在的问题：ABA问题、自旋忙等、只能保证一个共享变量的原子操作。</p></blockquote><p><strong>锁粗化</strong>：当JVM检测到连续几条加锁和释放锁的操作，会对锁进行粗话，在更大范围内进行加锁和释放锁。</p><p><strong>锁消除</strong>：代码层面要求同步，但数据层面不涉及竞争，会删除不必要的加锁操作。</p><h2 id="synchronized与Lock"><a href="#synchronized与Lock" class="headerlink" title="synchronized与Lock"></a>synchronized与Lock</h2><p>synchronized和Lock的区别：</p><table><thead><tr><th></th><th>synchronized</th><th>Lock</th></tr></thead><tbody><tr><td>实现层面</td><td>Java关键字，在JVM层面实现加锁和解锁。</td><td>Lock时一个接口，在代码层面实现的加锁和解锁。</td></tr><tr><td>作用范围</td><td>代码块、方法上</td><td>代码块</td></tr><tr><td>释放锁的时机</td><td>异常时自动释放锁</td><td>需要在finally显示释放锁，不会自动释放</td></tr><tr><td>持有锁时间</td><td>线程拿不到锁一直自旋等待</td><td>可以设置超时时间</td></tr><tr><td>获取锁判断</td><td>不知道是否获取锁</td><td>可以通过tryLock进行判断</td></tr><tr><td>公平性</td><td>非公平</td><td>公平 / 非公平</td></tr><tr><td>中断</td><td>不可中断</td><td>可中断</td></tr></tbody></table><p>synchronized和ReentrantLock的对比：</p><table><thead><tr><th></th><th>synchronized</th><th>ReentrantLock</th></tr></thead><tbody><tr><td>锁实现机制</td><td>monitor机制（mutex lock）</td><td>依赖AQS</td></tr><tr><td>锁释放</td><td>自动释放</td><td>显示释放</td></tr><tr><td>锁类型</td><td>非公平锁</td><td>公平 / 非公平</td></tr><tr><td>条件队列</td><td>关联一个条件队列</td><td>关联多个条件队列</td></tr><tr><td>可重入性</td><td>可重入</td><td>可重入</td></tr><tr><td>灵活性</td><td>差</td><td>支持响应中断、超时、尝试获取锁</td></tr></tbody></table><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h2><p>volatile能保证可见性和有序性，以及单次读写的原子性。</p><p>volatile是修饰变量的。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="可见性的实现原理"><a href="#可见性的实现原理" class="headerlink" title="可见性的实现原理"></a>可见性的实现原理</h3><p>volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现。</p><blockquote><p>内存屏障，又称内存栅栏，是一个 CPU 指令（lock前缀指令）。</p></blockquote><p>如果对声明了 volatile 的变量进行<strong>写操作</strong>，JVM 就会向处理器发送一条 <strong>lock 前缀</strong>的指令，将这个变量所在缓存行的数据写回到系统内存。</p><p>lock 前缀的指令在多核处理器下会引发两件事情:</p><ul><li>将当前处理器缓存行的数据写回到系统内存。</li><li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li></ul><p>不同cpu缓存一致性的保证：</p><p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p><img src="/img/2021/volatile%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E7%90%86.png" alt="volatile可见性原理"></p><h3 id="有序性的实现原理"><a href="#有序性的实现原理" class="headerlink" title="有序性的实现原理"></a>有序性的实现原理</h3><p>volatile变量的有序性是基于Happens-Before原则实现的。</p><blockquote><p> volatile变量的写happens before volatile变量的读。</p></blockquote><p>利用JMM 提供的内存屏障阻止重排序</p><table><thead><tr><th><strong>内存屏障</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-初级&amp;高级特性梳理</title>
    <link href="/2021/08/19/tech/JavaSE/Java-%E5%88%9D%E7%BA%A7&amp;%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/19/tech/JavaSE/Java-%E5%88%9D%E7%BA%A7&amp;%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="OOP的三大特性"><a href="#OOP的三大特性" class="headerlink" title="OOP的三大特性"></a>OOP的三大特性</h2><p>面向对象的程序设计方法具有三个基本特征：封装、继承、多态。</p><p>封装：将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；</p><p>继承是面向对象实现软件复用的重要手段，当 子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；</p><p>多态：分为编译时多态和运行时多态:<br>    - 编译时多态主要指方法的重载<br>    - 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定，并且有三个条件：<br>      - 继承<br>      - 重写<br>      - 向上转型（父类引用指向子类对象）</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h2><p>泛型是jdk5引入的新特性，本质为了参数化类型，提供了类型安全检测机制，实现了一次编写模板，多次复用。<!--类型安全检测机制？--></p><p>以List为例，List的底层实现是Object[]，传不同的数据类型，要进行强制转换，这会导致容易产生类型转换错误等。如果对不同类型都编写一套模板显然太复杂，这时候泛型就可以解决以上问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T e)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>❗️❗️泛型<T>不是一种基本类型，不能通过<code>getClass()</code>方法获取Class类型。</p><h2 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h2><p>编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用<code>T</code>, <code>E</code> or <code>K</code>,<code>V</code>等被广泛认可的类型占位符。泛型方法的例子请参阅Java集合类框架。在函数返回类型，和入参类型需要使用泛型的地方都需要用占位符占位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> cache.put(key, value);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型的Java实现（擦拭法）"><a href="#泛型的Java实现（擦拭法）" class="headerlink" title="泛型的Java实现（擦拭法）"></a>泛型的Java实现（擦拭法）</h2><p>泛型只在编译阶段有效，在编译过程中会进行类型擦除，并在对象进入和离开方法的时候进行类型转换和类型检测，而泛型信息不会进入到运行时阶段。</p><p>Java语言的泛型实现方式是<strong>擦拭法（Type Erasure）</strong>。</p><blockquote><p>擦拭法是指，JVM完全屏蔽泛型，所有的类型转换工作都是编译器做的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// coding</span><br>Pair&lt;String&gt; p = <span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>String first = p.getFirst();<br>String last = p.getLast();<br><br><span class="hljs-comment">// jvm</span><br>Pair p = <span class="hljs-keyword">new</span> Pair(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>String first = (String) p.getFirst();<br>String last = (String) p.getLast();<br></code></pre></td></tr></table></figure><p>擦拭法决定了泛型<T>：</p><ol><li>不能是基本类型，例如：int；</li><li>不能获取带泛型类型的Class，例如：Pair<String>.class；</li><li>不能判断带泛型类型的类型，例如：x instanceof Pair<String>；</li><li>不能实例化T类型，例如：new T()。</li></ol><h2 id="extends-amp-super通配符"><a href="#extends-amp-super通配符" class="headerlink" title="extends &amp; super通配符"></a>extends &amp; super通配符</h2><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>❗️❗️向上转型是谁转？是外层的类型转，而不是&lt;&gt;里的类型转！</p><p>对于<code>ArrayList&lt;String&gt;</code>来说，向上转型的结果就是<code>List&lt;String&gt;</code>。</p><p>但是对于<code>ArrayList&lt;Integer&gt;</code>，<code>ArrayList&lt;Number&gt;</code>并不是其向上转型的结果！</p><p>如果想对<code>&lt;&gt;</code>里面的内容进行向上或向下类型转换，要怎么做？ 向上转-&gt;extends，向下转-&gt;super</p><h3 id="extends-上界通配符"><a href="#extends-上界通配符" class="headerlink" title="extends 上界通配符"></a>extends 上界通配符</h3><? extends Number>通配符的一个重要限制：方法参数签名setFirst(? extends Number)无法传递任何Number的子类型给setFirst(? extends Number)使用<? extends Number>通配符表示：1. 使用extends通配符表示可以读，不能写；2. 使用类似< T extends Number>定义泛型类时表示：泛型类型限定为Number以及Number的子类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// extends的作用是限制set，只get</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumOfList</span><span class="hljs-params">(List&lt;? extends Integer&gt; list)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>        Integer n = list.get(i);<br>        sum = sum + n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>### super 下界通配符使用<? super Integer>通配符表示：1. 允许调用set(? super Integer)方法传入Integer的引用；2. 不允许调用get()方法获得Integer的引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collections</span> </span>&#123;<br>    <span class="hljs-comment">// 把src的每个元素复制到dest中:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;src.size(); i++) &#123;<br>            T t = src.get(i);<br>            dest.add(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>`Collections.copy`的作用是把一个List的每个元素依次添加到另一个List中。它的第一个参数是`List<? super T>`，表示目标List，第二个参数`List<? extends T>`，表示要复制的List。我们可以简单地用for循环实现复制。在for循环中，我们可以看到，对于类型`<? extends T>`的变量src，我们可以安全地获取类型T的引用，而对于类型`<? super T>`的变量dest，我们可以安全地传入T的引用。这个`copy()`方法的定义就完美地展示了extends和super的意图：`copy()`方法内部不会读取dest，因为不能调用`dest.get()`来获取T的引用；`copy()`方法内部也不会修改src，因为不能调用`src.add(T)`。### ? 无边界通配符 <?><p>通配符既没有extends，也没有super，因此：</p><ol><li>不允许调用set(T)方法并传入引用（null除外）；</li><li>不允许调用T get()方法并获取T引用（只能获取Object引用）。</li></ol><p>无限定通配符&lt;?&gt;很少使用，可以用<T>替换，同时它是所有<T>类型的超类。</p><h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><blockquote><p>Q：在哪些地方可以使用泛型？泛型有哪些使用方式？</p></blockquote><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。</p><p><em><strong>泛型类</strong></em></p><p>泛型类，就是用泛型来定义类。通过泛型可以完成对一组类的操作对外开放相同的接口。</p><p>最典型的就是各种容器类，如：List、Set、Map。</p><p><em><strong>泛型接口</strong></em></p><p>泛型接口，就是用泛型来定义接口。泛型接口常被用在各种类的生成器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个泛型接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>泛型方法</strong></em></p><ol><li><p>基本用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 这才是一个真正的泛型方法。</span><br><span class="hljs-comment"> * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span><br><span class="hljs-comment"> * 这个T可以出现在这个泛型方法的任意位置.</span><br><span class="hljs-comment"> * 泛型的数量也可以为任意多个 </span><br><span class="hljs-comment"> *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class="hljs-comment"> *        ...</span><br><span class="hljs-comment"> *        &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">showKeyName</span><span class="hljs-params">(Generic&lt;T&gt; container)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;container key :&quot;</span> + container.getKey());<br>    <span class="hljs-comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span><br>    T test = container.getKey();<br>    <span class="hljs-keyword">return</span> test;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>泛型类中的泛型方法 </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenerateTest</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show_1</span><span class="hljs-params">(T t)</span></span>&#123;<br>        System.out.println(t.toString());<br>    &#125;<br><br>    <span class="hljs-comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span><br>    <span class="hljs-comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span><br>    <span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_3</span><span class="hljs-params">(E t)</span></span>&#123;<br>        System.out.println(t.toString());<br>    &#125;<br><br>    <span class="hljs-comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_2</span><span class="hljs-params">(T t)</span></span>&#123;<br>        System.out.println(t.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>可变参数的泛型方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMsg</span><span class="hljs-params">( T... args)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(T t : args)&#123;<br>        Log.d(<span class="hljs-string">&quot;泛型测试&quot;</span>,<span class="hljs-string">&quot;t is &quot;</span> + t);<br>    &#125;<br>&#125;<br>printMsg(<span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-number">222</span>,<span class="hljs-string">&quot;aaaa&quot;</span>,<span class="hljs-string">&quot;2323.4&quot;</span>,<span class="hljs-number">55.55</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li>静态泛型方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticGenerator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    ....<br>    ....<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span><br><span class="hljs-comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span><br><span class="hljs-comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span><br><span class="hljs-comment">          &quot;StaticGenerator cannot be refrenced from static context&quot;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(T t)</span></span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>泛型数组</strong></em></p><blockquote><p>不能创建一个确切的泛型类型的数组！原因在于JVM泛型擦除在运行时装入一个元素不会异常，但是在取值的时候可能会出现不一致的情况。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] ls = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;[<span class="hljs-number">10</span>];   <span class="hljs-comment">// not allowed !</span><br>List&lt;?&gt;[] ls = <span class="hljs-keyword">new</span> ArrayList&lt;?&gt;[<span class="hljs-number">10</span>];  <span class="hljs-comment">// allowed !</span><br>List&lt;String&gt;[] ls = <span class="hljs-keyword">new</span> ArrayList[<span class="hljs-number">10</span>]; <span class="hljs-comment">// alllowed !</span><br></code></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li>Array中可以用泛型吗?<br> Array是不可以使用泛型的。这是因为List可以提供编译期的类型安全保证，而Array却不能。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/s10461/article/details/53941091">https://blog.csdn.net/s10461/article/details/53941091</a></li><li></li></ol><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><p>反射是Java在运行时，可以动态地获取对象的所有属性和方法的一种机制。</p><p>反射通过Class类获取类的class对象；通过Constructor类反映类的构造方法；通过Field类反映类的属性；通过Method类反映类的方法。</p><blockquote><p>Class类是一个类（java.lang），其实例表示java运行时的类或接口。</p></blockquote><h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><h3 id="Class类对象的获取"><a href="#Class类对象的获取" class="headerlink" title="Class类对象的获取"></a>Class类对象的获取</h3><p>在类加载的时候，jvm会创建一个class对象。</p><p>获取class对象的方式的主要有三种：</p><ol><li>根据类名：类名.class </li><li>根据对象：对象.getClass() </li><li>根据全限定类名：Class.forName(全限定类名)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">classTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// 获取Class对象的三种方式</span><br>    logger.info(<span class="hljs-string">&quot;根据类名:  \t&quot;</span> + User.class);<br>    logger.info(<span class="hljs-string">&quot;根据对象:  \t&quot;</span> + <span class="hljs-keyword">new</span> User().getClass());<br>    logger.info(<span class="hljs-string">&quot;根据全限定类名:\t&quot;</span> + Class.forName(<span class="hljs-string">&quot;com.test.User&quot;</span>));<br>    <span class="hljs-comment">// 常用的方法</span><br>    logger.info(<span class="hljs-string">&quot;获取全限定类名:\t&quot;</span> + userClass.getName());<br>    logger.info(<span class="hljs-string">&quot;获取类名:\t&quot;</span> + userClass.getSimpleName());<br>    logger.info(<span class="hljs-string">&quot;实例化:\t&quot;</span> + userClass.newInstance());<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;init&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h3><p>获取<code>Constructor</code>对象是通过<code>Class</code>类中的方法获取的。</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>static Class&lt;?&gt;</td><td>forName(String className)</td><td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td></tr><tr><td>Constructor</td><td>getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、具有public访问权限的构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getConstructors()</td><td>返回所有具有public访问权限的构造函数的Constructor对象数组</td></tr><tr><td>Constructor</td><td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、所有声明的（包括private）构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getDeclaredConstructor()</td><td>返回所有声明的（包括private）构造函数对象</td></tr><tr><td>T</td><td>newInstance()</td><td>调用无参构造器创建此 Class 对象所表示的类的一个新实例。</td></tr></tbody></table><p><code>Constructor</code>类常用的API：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Class</td><td>getDeclaringClass()</td><td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td></tr><tr><td>String</td><td>getName()</td><td>以字符串形式返回此构造方法的名称。</td></tr><tr><td>Class&lt;?&gt;[]</td><td>getParameterTypes()</td><td>按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td></tr><tr><td>T</td><td>newInstance(Object… initargs)</td><td>使用此 Constructor对象表示的构造函数来创建新实例</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Constructor 的字符串，其中包括类型参数。</td></tr></tbody></table><h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><p>获取<code>Field</code>对象是通过<code>Class</code>类中的方法获取的。</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Field</td><td>getDeclaredField(String name)</td><td>获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td></tr><tr><td>Field[]</td><td>getDeclaredField()</td><td>获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td></tr><tr><td>Field</td><td>getField(String name)</td><td>获取指定name名称、具有public修饰的字段，包含继承字段</td></tr><tr><td>Field[]</td><td>getField()</td><td>获取修饰符为public的字段，包含继承字段</td></tr></tbody></table><p><code>Field</code>类常用的API：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>void</td><td>set(Object obj, Object value)</td><td>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td></tr><tr><td>Object</td><td>get(Object obj)</td><td>返回指定对象上此 Field 表示的字段的值</td></tr><tr><td>Class&lt;?&gt;</td><td>getType()</td><td>返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。</td></tr><tr><td>boolean</td><td>isEnumConstant()</td><td>如果此字段表示枚举类型的元素则返回 true；否则返回 false</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回一个描述此 Field（包括其一般类型）的字符串</td></tr><tr><td>String</td><td>getName()</td><td>返回此 Field 对象表示的字段的名称</td></tr><tr><td>Class&lt;?&gt;</td><td>getDeclaringClass()</td><td>返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td></tr><tr><td>void</td><td>setAccessible(boolean flag)</td><td>将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</td></tr></tbody></table><h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><p>获取<code>Method</code>对象是通过<code>Class</code>类中的方法获取的。</p><table><thead><tr><th></th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Method</td><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td></tr><tr><td>Method[]</td><td>getDeclaredMethod()</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td></tr><tr><td>Method</td><td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td></tr><tr><td>Method[]</td><td>getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td></tr></tbody></table><p><code>Method</code>类常用的API：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Object</td><td>invoke(Object obj, Object… args)</td><td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td></tr><tr><td>Class&lt;?&gt;</td><td>getReturnType()</td><td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td></tr><tr><td>Type</td><td>getGenericReturnType()</td><td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td></tr><tr><td>Class&lt;?&gt;[]</td><td>getParameterTypes()</td><td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td></tr><tr><td>String</td><td>getName()</td><td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td></tr><tr><td>boolean</td><td>isVarArgs()</td><td>判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Method 的字符串，包括类型参数。</td></tr></tbody></table><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>todo</p><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><em><strong>序列化</strong></em>是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。</p><p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口。</p><p>把一个Java对象变为byte[]数组，需要使用<code>ObjectOutputStream</code>，从一个字节流读取Java对象用<code>ObjectInputStream</code>。</p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>todo</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>todo</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="容器间的继承关系"><a href="#容器间的继承关系" class="headerlink" title="容器间的继承关系"></a>容器间的继承关系</h2><p><img src="/img/2021/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB.png" alt="Java集合框架体系"></p><p><img src="/img/2021/Java%E5%AE%B9%E5%99%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="Java容器继承关系图"></p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><ol><li>第一次put的时候，会触发resize操作，第一次resize默认的数组大小是16；</li><li>通过hash映射，得到当前key要put到的数组位置（数组下标是 arrlen &amp; hash(key) 得到的）；</li><li>如果当前数组里的位置为空，新建一个KV的node放到数组里；（node 包含的属性有key, value, next, hash）</li><li>如果数组里已经有数据，取出当前结点判断key与要put的key是否一致，如果一致说明要覆盖旧值，如果不一致，说明哈希冲突；</li><li>如果哈希冲突，需要对冲突的node进行类型判断，如果是红黑树，需要通过红黑树的插值方法完成put操作；否则是链表，通过拉链法完成插值；</li><li>拉链法插值的过程为：要遍历链表，如果找到node的key与当前put的node的key一致，进行覆盖；否则将node加到链表尾部；链表长度超过8要转成红黑树的操作；</li><li>哈希冲突判断完，接下来剩下两个判断操作；一个是在key相等时进行覆盖；另一个是如果因为put达到阈值要进行扩容。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-comment">// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span><br><span class="hljs-comment">// 第五个参数 evict 我们这里不关心</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span><br>    <span class="hljs-comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 数组该位置有数据</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 到这里，说明数组该位置上是一个链表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span><br>                    <span class="hljs-comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span><br>        <span class="hljs-comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            V oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩容分析"><a href="#扩容分析" class="headerlink" title="扩容分析"></a>扩容分析</h3><ol><li>在扩容代码里，主要有两个内容；1、针对capacity 和threshold 进行更新；2、进行数据迁移；</li><li>针对容量和阈值进行更新的时候，有两种情况；1、第一次put 数组初始化的hashmap；2、对有值的数组进行扩容；</li><li>对有值的数组进行扩容为一般情况，采取的扩容策略为将cap和thr分别扩大一倍（边界case：对&gt;=2^30的cap直接扩容到Integer.MAX_VALUE）；</li><li>如果是初始化的数组，就直接返回了；如果是已经有值的数组，需要进行数据迁移；</li><li>在数据迁移的时候，要将链表拆成两个链接。具体操作有两步；1、将数据迁移，用拉链法解决hash冲突；2、将两条链表分别挂在数组对应的下标上；</li><li>数据迁移时，遍历数组每一个元素：1、如果只有一个值，按key进行hash映射到新的地址就可以了；2、如果是红黑树，不展开；3、如果是链表，拿key的hash与oldcap做&amp;，将最高位为0or1作为两个链表其中的一个的区分，在新得到的位置用拉链法解决哈希冲突（如果需要的话）；</li><li>将链表挂载数组时，将低位链表挂在原位置上，将高位链表挂在原位置高一个oldcap的位置上。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 对应数组扩容</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 将数组大小扩大一倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-comment">// 将阈值扩大一倍</span><br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br><br>    <span class="hljs-comment">// 用新的数组大小初始化新的数组</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab; <span class="hljs-comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span><br><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 开始遍历原数组，进行数据迁移。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-comment">// 如果是红黑树，具体我们就不展开了</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <br>                    <span class="hljs-comment">// 这块是处理链表的情况，</span><br>                    <span class="hljs-comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span><br>                    <span class="hljs-comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-comment">// 第一条链表</span><br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span><br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><ol><li>根据key做hash与当前数组容量做&amp; 确定下标位置；</li><li>如果当前位置的元素的key和get的key一致，直接返回；</li><li>否则看当前元素类型，如果是红黑树，调用红黑树的查找方法查找；如果是链表，遍历拉链进行查找返回；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 判断第一个节点是不是就是需要的</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 判断是否是红黑树</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br><br>            <span class="hljs-comment">// 链表遍历</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>todo</p><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>todo</p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统知识点梳理</title>
    <link href="/2021/08/17/tech/CSBase/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/17/tech/CSBase/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="CAP-原则"><a href="#CAP-原则" class="headerlink" title="CAP 原则"></a>CAP 原则</h3><p>CAP定理又称CAP原则，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），最多只能同时三个特性中的两个，三者不可兼得。</p><ul><li><p>Consistency (一致性)：</p><p>  “all nodes see the same data at the same time”，即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p></li><li><p>Availability (可用性)：</p><p>  可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</p></li><li><p>Partition Tolerance (分区容错性)：</p><p>  即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</p></li></ul><h3 id="BASE-定理"><a href="#BASE-定理" class="headerlink" title="BASE 定理"></a>BASE 定理</h3><p>分布式系统不可能同时满足cap三个特性，最多只能同时满足其中的两个，分区容错性必不可少，因为总是假定网络不是可靠的，所以必须要在可用性和一致性之间做选择。</p><p>保证一致性：让系统暂停服务，等待数据同步完成。</p><p>保证可用性：同步过程中继续提供服务，读取的数据可能不一致。</p><p><em><strong>CA矛盾的原因</strong></em></p><p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性；如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p><h3 id="分布式一致性协议raft"><a href="#分布式一致性协议raft" class="headerlink" title="分布式一致性协议raft"></a>分布式一致性协议raft</h3><h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>在分布式系统中，为了保证负载均衡，可以对发送的信息进行hash映射，然而，如果节点增加或减少，将会使得系统所有的数据节点映射改变，给系统带来不稳定性。一致性哈希对2的32次方取模，节点增加或减少对系统的影响很小。若增加或减少节点，造成不命中，只需在哈希环上顺时针找到最近的一个节点即可。</p><p>由于哈希环节点可能稠密不同，为了保证负载均衡，可以对称增加服务器虚拟节点。</p><h3 id="HTTP和RPC的区别"><a href="#HTTP和RPC的区别" class="headerlink" title="HTTP和RPC的区别"></a>HTTP和RPC的区别</h3><table><thead><tr><th></th><th>rpc</th><th>http</th></tr></thead><tbody><tr><td>传输协议</td><td>tcp; http</td><td>http</td></tr><tr><td>传输效率</td><td>基于tcp或者http2效率会更高</td><td>基于http1.1会慢，基于http2再做简单封装就可以当rpc来用</td></tr><tr><td>性能消耗</td><td>基于thrift可以实现高效的二进制传输</td><td>大部分通过json实现，字节大小和序列化耗时都会降低性能。</td></tr><tr><td>负载均衡</td><td>自带了负载均衡策略</td><td>需要配置nginx</td></tr><tr><td>服务治理</td><td>自动通知，不影响上游</td><td>要做到事先通知，修改nginx配置</td></tr></tbody></table><h3 id="分布式系统一致性"><a href="#分布式系统一致性" class="headerlink" title="分布式系统一致性"></a>分布式系统一致性</h3><p>分布式系统一致性级别：强一致性，顺序一致性以及弱一致性。</p><p><em><strong>线性一致性</strong></em></p><p>在全局时钟范围内，所有数据的读写都是一致合理的。</p><p>这表现为：1、任何一次读都能读到最近一次写的数据；2、所有进程的操作顺序都和全局时钟下保持一致。</p><p><em><strong>顺序一致性</strong></em></p><p>进程的操作顺序是一致合理的，但在全局时钟范围内并不一致。</p><p><em><strong>最终一致性</strong></em></p><p>不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化，从而达到最终的一致性。</p><p><img src="/img/2021/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%80%E8%87%B4%E6%80%A7%E7%BA%A7%E5%88%AB.png" alt="分布式系统一致性级别"></p><p>最终一致性根据更新数据后各进程访问到数据的时间和方式的不同，可以继续分为：</p><ol><li>因果一致性（Casual Consistency）。如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问，遵守一般的最终一致性规则。</li><li>“读己之所写（read-your-writes）”一致性。当进程A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。</li><li>会话（Session）一致性。这是上一个模型的实用版本，它把访问存储系统的进程放到会话的上下文中。只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统的保证不会延续到新的会话。</li><li>单调（Monotonic）读一致性。如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。</li><li>单调写一致性。系统保证来自同一个进程的写操作顺序执行。要是系统不能保证这种程度的一致性，就非常难以编程了。</li></ol><p><em><strong>分布式系统一致性的解决方案</strong></em></p><p><a href="https://segmentfault.com/a/1190000022435560">各大厂解决思路</a></p><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><p>分布式存储除了传统意义上的分布式文件系统、分布式块存储和 分布式对象存储外，还包括分布式数据库和分布式缓存等。</p><p>以文件系统为例，常见的架构有中间控制节点架构（HDFS）、完全无中心架构（一致性哈希）。</p><blockquote><p>问到分布式存储，大概率就是要问一致性哈希算法了！</p></blockquote><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h3 id="大型网站系统架构"><a href="#大型网站系统架构" class="headerlink" title="大型网站系统架构"></a>大型网站系统架构</h3><p>“用户-负载均衡器-N台服务器-redis缓存集群-mysql集群”</p><p>前端限流（例如一个用户10秒内只能点击一次，异步处理，消息队列）；</p><p>负载均衡一般采用NGINX反向代理；</p><p>mysql读写分离，主库写，从库读，分库分表。</p><h3 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h3><h3 id="分布式锁（ZooKeeper）"><a href="#分布式锁（ZooKeeper）" class="headerlink" title="分布式锁（ZooKeeper）"></a>分布式锁（ZooKeeper）</h3><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p><a href="https://mingda.life/2021/08/05/tech/middleware/Redis%E6%A2%B3%E7%90%86/#Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F">参考Redis</a></p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h3 id="数据库主从一致性"><a href="#数据库主从一致性" class="headerlink" title="数据库主从一致性"></a>数据库主从一致性</h3><p>主从不一致是延时导致的。出于性能考虑，采用读写分离。</p><ol><li>半同步复制：主从同步完成之后，主库再返回写请求。主库写请求延时增加，吞吐量下降。</li><li>数据库中间件：加了中间件后，设置一个同步时间，如果</li></ol><h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><p><em><strong>漏桶算法</strong></em></p><p>业务组件处理速率恒定。</p><p><img src="/img/2021/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95.png" alt="漏桶算法"></p><p><em><strong>令牌桶算法</strong></em></p><p>业务组件会出现高峰，能短期处理些高发情况。</p><p><img src="/img/2021/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png" alt="令牌桶算法"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/140272240">https://zhuanlan.zhihu.com/p/140272240</a></li><li><a href="https://www.cnblogs.com/crazymakercircle/p/14375424.html">https://www.cnblogs.com/crazymakercircle/p/14375424.html</a></li><li><a href="https://blog.csdn.net/youanyyou/article/details/107075116">https://blog.csdn.net/youanyyou/article/details/107075116</a></li></ol><!--什么是分布式事务？对于分布式系统而言，需要保证分布式系统中的数据一致性，保证数据在子系统中始终保持一致，避免业务出现问题。分布式系统中对数要么一起成功，要么一起失败，必须是一个整体性的事务。分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，在分布式系统上一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务节点上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。举个例子：在电商网站中，用户对商品进行下单，需要在订单表中创建一条订单数据，同时需要在库存表中修改当前商品的剩余库存数量，两步操作一个添加，一个修改，我们一定要保证这两步操作一定同时操作成功或失败，否则业务就会出现问题。任何事务机制在实现时，都应该考虑事务的ACID特性，包括：本地事务、分布式事务。对于分布式事务而言，即使不能都很好的满足，也要考虑支持到什么程度。典型的分布式事务场景：1. 跨库事务跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同的业务数据。笔者见过一个相对比较复杂的业务，一个业务中同时操作了9个库。下图演示了一个服务同时操作2个库的情况：在这里插入图片描述2. 分库分表通常一个库数据量比较大或者预期未来的数据量比较大，都会进行水平拆分，也就是分库分表。如下图，将数据库B拆分成了2个库：在这里插入图片描述对于分库分表的情况，一般开发人员都会使用一些数据库中间件来降低sql操作的复杂性。如，对于sql：insert into user(id,name) values (1,"tianshouzhi"),(2,"wangxiaoxiao")。这条sql是操作单库的语法，单库情况下，可以保证事务的一致性。但是由于现在进行了分库分表，开发人员希望将1号记录插入分库1，2号记录插入分库2。所以数据库中间件要将其改写为2条sql，分别插入两个不同的分库，此时要保证两个库要不都成功，要不都失败，因此基本上所有的数据库中间件都面临着分布式事务的问题。3. 微服务化微服务架构是目前一个比较一个比较火的概念。例如上面笔者提到的一个案例，某个应用同时操作了9个库，这样的应用业务逻辑必然非常复杂，对于开发人员是极大的挑战，应该拆分成不同的独立服务，以简化业务逻辑。拆分后，独立服务之间通过RPC框架来进行远程调用，实现彼此的通信。下图演示了一个3个服务之间彼此调用的架构：在这里插入图片描述Service A完成某个功能需要直接操作数据库，同时需要调用Service B和Service C，而Service B又同时操作了2个数据库，Service C也操作了一个库。需要保证这些跨服务的对多个数据库的操作要不都成功，要不都失败，实际上这可能是最典型的分布式事务场景。分布式事务实现方案必须要考虑性能的问题，如果为了严格保证ACID特性，导致性能严重下降，那么对于一些要求快速响应的业务，是无法接受的。-->]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库知识点梳理</title>
    <link href="/2021/08/16/tech/CSBase/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/16/tech/CSBase/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h3 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h3><p>第一范式：(确保每列保持原子性)所有字段值都是不可分解的原子值。</p><p>第二范式：(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>第三范式：(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p>第四范式:要求把同一表内的多对多关系删除。</p><p>第五范式:从最终结构重新建立原始结构。</p><h3 id="关系型数据库-amp-非关系型数据库"><a href="#关系型数据库-amp-非关系型数据库" class="headerlink" title="关系型数据库 &amp; 非关系型数据库"></a>关系型数据库 &amp; 非关系型数据库</h3><p>关系型数据库的优势：</p><ol><li>复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li>事务支持：使得对于安全性能很高的数据访问要求得以实现。</li></ol><p>关系型数据库的性能瓶颈：</p><ol><li>在数据库表非常大的时候，不容易恢复；</li><li>扩展性差，需要复杂的技术实现。</li><li>大数据量下IO压力大；</li><li>表结构更改困难。</li></ol><p>非关系型数据库的优势：</p><ol><li>性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li>可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ol><p>其他：</p><ol><li>对于这两类数据库，对方的优势就是自己的弱势，反之亦然；</li><li>NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB；</li><li>对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</li></ol><p>什么时候会选择用nosql呢？</p><ol><li>数据库表schema经常变化<br> 比如在线商城，维护产品的属性经常要增加字段，这就意味着ORMapping层的代码和配置要改，如果该表的数据量过百万，新增字段会带来额外开销（重建索引等）。NoSQL应用在这种场景，可以极大提升DB的可伸缩性，开发人员可以将更多的精力放在业务层。</li><li>数据库表字段是复杂数据类型<br> 对于复杂数据类型，比如SQL Sever提供了可扩展性的支持，像xml类型的字段。很多用过的同学应该知道，该字段不管是查询还是更改，效率非常一般。主要原因是是DB层对xml字段很难建高效索引，应用层又要做从字符流到dom的解析转换。NoSQL以json方式存储，提供了原生态的支持，在效率方便远远高于传统关系型数据库。</li><li>高并发数据库请求</li><li>海量数据的分布式存储</li></ol><h2 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h2><h3 id="sql的执行顺序"><a href="#sql的执行顺序" class="headerlink" title="sql的执行顺序"></a>sql的执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><br>     <span class="hljs-operator">&lt;</span>select_list<span class="hljs-operator">&gt;</span><br> <span class="hljs-keyword">FROM</span><br>     <span class="hljs-operator">&lt;</span>left_table<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>join_type<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-operator">&lt;</span>right_table<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>join_condition<span class="hljs-operator">&gt;</span><br> <span class="hljs-keyword">WHERE</span><br>     <span class="hljs-operator">&lt;</span>where_condition<span class="hljs-operator">&gt;</span><br> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>     <span class="hljs-operator">&lt;</span>group_by_list<span class="hljs-operator">&gt;</span><br> <span class="hljs-keyword">HAVING</span><br>     <span class="hljs-operator">&lt;</span>having_condition<span class="hljs-operator">&gt;</span><br> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>     <span class="hljs-operator">&lt;</span>order_by_condition<span class="hljs-operator">&gt;</span><br> LIMIT <span class="hljs-operator">&lt;</span>limit number<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><img src="/img/2021/7-JOINS.png" alt="7-JOINS"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">from</span> A<br> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> B<br> <span class="hljs-keyword">on</span> A.Key <span class="hljs-operator">=</span> B.Key;<br> <br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">from</span> A<br> <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B<br> <span class="hljs-keyword">on</span> A.Key <span class="hljs-operator">=</span> B.Key;<br> <br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">from</span> A<br> <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> B<br> <span class="hljs-keyword">on</span> A.Key <span class="hljs-operator">=</span> B.Key;<br> <br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">from</span> A<br> <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B<br> <span class="hljs-keyword">on</span> A.Key <span class="hljs-operator">=</span> B.Key<br> <span class="hljs-keyword">where</span> B.Key <span class="hljs-keyword">is</span> <span class="hljs-keyword">NULL</span>;<br> <br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">from</span> A<br> <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> B<br> <span class="hljs-keyword">on</span> A.Key <span class="hljs-operator">=</span> B.Key<br> <span class="hljs-keyword">where</span> A.Key <span class="hljs-keyword">is</span> <span class="hljs-keyword">NULL</span>;<br> <br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">from</span> A<br> <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> B<br> <span class="hljs-keyword">on</span> A.Key <span class="hljs-operator">=</span> B.Key;<br> <br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">from</span> A<br> <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> B<br> <span class="hljs-keyword">on</span> A.Key <span class="hljs-operator">=</span> B.Key<br> <span class="hljs-keyword">where</span> A.Key <span class="hljs-keyword">is</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">or</span> B.key <span class="hljs-keyword">is</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a><em><strong>什么是索引</strong></em></h3><p>索引是一种能够快速获取数据的数据结构。</p><h3 id="索引是干什么的"><a href="#索引是干什么的" class="headerlink" title="索引是干什么的"></a><em><strong>索引是干什么的</strong></em></h3><p>索引是提高数据查询效率的。</p><p>主要通过索引依赖的数据结构。</p><p>InnoDB用的是B+树。</p><h3 id="为什么用B-树？"><a href="#为什么用B-树？" class="headerlink" title="为什么用B+树？"></a><em><strong>为什么用B+树？</strong></em></h3><p>采用什么样的索引需要考虑两个方面：</p><ol><li>InnoDB 需要支持的场景和功能需要在<strong>特定查询</strong>上拥有较强的性能；（综合考虑CRUD、排序、关联性能）</li><li>CPU 将磁盘上的数据加载到内存中需要花费大量的时间，要尽量减少IO操作次数；</li></ol><ul><li><p>Hash索引的优势在于：INSERT、DELETE、UPDATE操作的时间复杂度是O(1)的，而B+树的时间复杂度是O(logn)的。劣势在于：当有大量重复键值的情况下，会存在哈希碰撞的问题，降低查询效率；排序和范围查找要通过全表扫描，效率极低。</p><p>  ⭐️相较于Hash索引，B+树的优势有：</p><ul><li>利用索引可以完成<strong>排序</strong>；</li><li>支持<strong>范围查询</strong>；</li><li>支持<strong>最左匹配</strong>原则（联合索引）；</li></ul></li><li><p>B树和B+树最大的两点区别是：</p><ul><li>B树每个结点都存数据，B+树只在叶子结点存数据；</li><li>B树的叶子结点没有链表连接，而B+树的叶子结点构成了一个双向链表；</li></ul><p>  这就导致两点差别：</p><ul><li>在查询单个记录的时候，B+树的查询效率比较稳定，但低于B树；</li><li>涉及遍历操作的时候，B+树可以利用双向链表顺序查询（由树根自上而下在叶子结点层顺序遍历），而B树要通过树型查找，从磁盘读到内存会浪费大量时间（类似dfs树层上下相间跳来跳去）；</li></ul><p>  在关系型数据库中经常用到<strong>JOIN操作</strong>进行顺序匹配，因此选择了B+树。</p></li><li><p>红黑树基本都是存储在<strong>内存中</strong>才会使用的数据结构。在大规模数据数据存储的时候，显然不能将全部数据全部加载进内存，因此如果采用红黑树，就会造成<strong>频繁IO</strong>，效率低下。</p></li></ul><p><em><strong>B+树的叶子结点都存的什么？</strong></em></p><ul><li>创建的是聚集索引的时候，叶子结点存的是整行数据；</li><li>创建的是辅助索引的时候，叶子结点存的是主键的值；</li><li>如果查询走的是覆盖索引的话，叶子节点同时存了主键以及对应的整行数据。</li></ul><p><em><strong>聚集索引和辅助索引有什么区别？</strong></em></p><ul><li>由于主键唯一，聚集索引构建的B+树也是唯一的。经过树高次数的磁盘读取，可以直接获得整行的记录。</li><li>辅助索引可以构造多个索引树，包含两种类型：多个单列索引，单个多列索引。<ul><li>单列索引：通过辅助索引先查询主键，再进行回表，通过聚集索引查询整行记录。（此时比聚集索引的查询速度要慢。）</li><li>多列索引：这种情况下创建的是一种特殊的辅助索引，即<strong>覆盖索引</strong>（也属于<strong>联合索引</strong>）。这时候如果查询的是联合索引中列对应的记录，则不需要<strong>回表</strong>，直接在叶子结点查得。（此时和聚集索引的查询速度相同。）</li></ul></li></ul><!--todo: B树 & B+树 & 红黑树的结构--><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a><em><strong>最左匹配原则</strong></em></h3><p>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。</p><p>最左匹配原则按照创建联合索引的顺序进行匹配，和查询条件的顺序无关。</p><blockquote><p>如有索引(a, b, c, d)，查询条件c &gt; 3 and b = 2 and a = 1 and d &lt; 4与a = 1 and c &gt; 3 and b = 2 and d &lt; 4等顺序都是可以的，MySQL会自动优化为a = 1 and b = 2 and c &gt; 3 and d &lt; 4，依次命中a、b、c。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">table</span> T, index (a,b,c)<br><br><span class="hljs-comment">-- 全值匹配</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">-- Y</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> c<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> a<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">-- Y</span><br><br><span class="hljs-comment">-- 匹配左前缀</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">-- Y</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">-- N</span><br><br><span class="hljs-comment">-- 匹配列前缀</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> a <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;x%&#x27;</span>;<span class="hljs-comment">-- Y</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> a <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%x&#x27;</span>;<span class="hljs-comment">-- N</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> b <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;x%&#x27;</span>;<span class="hljs-comment">-- N</span><br><br><span class="hljs-comment">-- 匹配范围值</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> a <span class="hljs-keyword">between</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">-- Y</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> b <span class="hljs-keyword">between</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">-- N</span><br><br><span class="hljs-comment">-- 全值匹配 + 范围匹配</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> b <span class="hljs-keyword">between</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">-- Y</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> c <span class="hljs-keyword">between</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">-- N</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> a <span class="hljs-keyword">between</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">-- N</span><br></code></pre></td></tr></table></figure><h3 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a><em><strong>如何创建索引</strong></em></h3><h3 id="如何判断创建的索引是否生效？"><a href="#如何判断创建的索引是否生效？" class="headerlink" title="如何判断创建的索引是否生效？"></a><em><strong>如何判断创建的索引是否生效？</strong></em></h3><p>可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况。</p><h3 id="索引失效的原因"><a href="#索引失效的原因" class="headerlink" title="索引失效的原因"></a><em><strong>索引失效的原因</strong></em></h3><p>范围查询 + 没符合最左匹配</p><ul><li><p>单表查询时：</p><ul><li><p>查询得到的结果集占数据总量很大比例，mysql会认为全表扫描会优于索引，则不走索引。</p></li><li><p>在where条件后对索引字段加了函数转换或者运算逻辑（+、-、*、/、！、&lt;&gt;、%、like’%_’（%放在前面）、or、in (疑问、可能存在成本问题)、exist等）的处理，比如对时间戳字段进行日期格式化函数都会引起索引失效。</p></li><li><p>查询时where条件后的字段类型要与表结构中该字段类型一致，</p><p>  例：select * from userInfo where user_type=2 ，user_type在表结构中时字符类型，查询时没用有单引号包含起来则不走索引。</p></li></ul></li><li><p>多表关联查询时：</p><ul><li>在表结构设计阶段主表与关联表之间的关联字段的数据类型、数据长度、字段的编码格式以及字段的排序规则需要保持一致。</li></ul></li><li><p>联合索引时：</p><ul><li><p>没满足最左匹配原则：</p><p>  select * from userInfo where user_id=’001’ and user_name=’小张’ and user_type=’1’；这个时候是走了索引的，但是 select * from userInfo where  user_name=’小张’ and user_type=’1’；这时user_id没有在where条件内将不走索引。</p></li></ul></li></ul><h3 id="唯一索引和普通索引的区别是什么？"><a href="#唯一索引和普通索引的区别是什么？" class="headerlink" title="唯一索引和普通索引的区别是什么？"></a><em><strong>唯一索引和普通索引的区别是什么？</strong></em></h3><p>创建唯一索引的字段里的数据必须是唯一的，普通索引的字段的数据可以是重复的。这导致唯一索引的查询速度快于普通索引，而插入的速度慢于普通索引。</p><p>如：可以对学号建立唯一索引，但对成绩只能建立普通索引。</p><ul><li>查询速度快的原因：<ul><li>普通索引在找到满足条件的第一条记录后，还需要判断下一条记录，直到第一个不满足条件的记录出现；</li><li>唯一索引在找到满足条件的第一条记录后，直接返回，不用判断下一条记录了。</li></ul></li><li>插入速度慢的原因：<ul><li>在进行非聚簇索引的插入时，先判断插入的索引页是否在内存中。如果在，则直接插入；如果不在，则先放入Insert Buffer 中，然后再以一定频率和情况进行Insert Buffer和原数据页合并(merge)操作。这么做的优点是能将多个插入合并到一个操作中，就大大提高了非聚簇索引的插入性能。</li><li>InnoDB 从 1.0.x 版本开始引入了 Change Buffer，可以算是对 Insert Buffer 的升级。从这个版本开始，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。</li><li>唯一索引为了保证唯一性，需要将数据页加载进内存才能判断是否违反唯一性约束。但是，既然数据页都加载到内存了，还不如直接更新内存中的数据页，没有必要再使用Change Buffer。</li><li>唯一索引无法利用Change Buffer，普通索引可以利用Change Buffer，因此唯一索引插入速度慢。</li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的基本特性"><a href="#事务的基本特性" class="headerlink" title="事务的基本特性"></a>事务的基本特性</h3><ol><li>原子性（atomicity）：一系列的操作，要么都执行，要么都不执行；</li><li>隔离性（isolation）：每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务不可见；</li><li>持久性（durability）：一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来；</li><li>一致性（consistency）：数据库经由一个事务从一个状态转移到下一个状态；</li></ol><ul><li>通过数据库锁的机制，保障事务的隔离性；</li><li>通过 Redo Log（重做日志）来，保障事务的持久性；</li><li>通过 Undo Log （撤销日志）来，保障事务的原子性；</li><li>通过 Undo Log （撤销日志）来，保障事务的一致性；</li></ul><p><em><strong>Undo Log 如何保障事务的原子性的？</strong></em></p><p>具体的方式为：在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 Undo Log），然后进行数据的修改。如果出现了错误或者用户执行了 Rollback 语句，系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。</p><p><em><strong>Redo Log如何保障事务的持久性呢？</strong></em></p><p>具体的方式为：Redo Log 记录的是新数据的备份（和 Undo Log 相反）。在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到崩溃之前的状态。</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li><p>未提交读（read uncommitted）</p><p>  使用查询语句不会加锁，可能会读到未提交的行，会发生<strong>脏读（Dirty Read）</strong>。 </p></li><li><p>提交读（read committed）</p><p>  没有加行锁导致当其他事务修改某行数据时，当前事务多次读取该行时可能得到不同的结果。会发生<strong>不可重复读（Non-Repeatable Read）</strong>。</p><p>  采用Record Lock 解决了脏读问题，采用MVCC总是读取被锁定行的最新一份快照数据。</p></li><li><p>可重复读（repeatable read）</p><p>  多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生<strong>幻读（Phantom Read）</strong>。</p><p>  采用next-key lock 解决了脏读、不可重复读、幻读问题；采用MVCC，总是读取事务开始时的行数据版本。</p></li><li><p>可串行化（serializable）</p><p>  InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题，完全满足了事务的四大特性。<br>  因此也牺牲了并发性能。</p></li></ul><p><em><strong>幻读问题是如何解决的？</strong></em></p><p>InnoDB默认的隔离级别是可重复读，通过Next-Key Lock解决了幻读问题。</p><p>Next-key 锁是记录锁（record lock）和间隙锁（gap lock）的组合，锁定包含记录本身的一个范围，当查询的索引含有唯一属性的时候，next-key lock降级为record lock。</p><p>当可重复读级进行范围查询时，另一个事务进行插入操作时要进行等待。</p><p><em><strong>在不同的事务的隔离级别下，都对应什么数据库锁？</strong></em></p><ul><li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li><li>在Read Committed级别下，读操作需要加共享锁，但是在<a href="https://www.notion.so/MySQL-b3596328d1be455a8fd05a5ff5b8f063">语句</a>执行完以后释放共享锁；（语句级锁）</li><li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待<a href="https://www.notion.so/MySQL-b3596328d1be455a8fd05a5ff5b8f063">事务执行完毕</a>以后才释放共享锁。（事务级锁）</li><li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</li></ul><p><em><strong>不可重复读和幻读的区别是什么？</strong></em></p><ul><li>不可重复读指的是指当前读没有加行锁，导致其他事务修改某行数据的时候，当前事务多次读该行会得到不同的结果，区分点在于其他事务修改了数据；</li><li>幻读是指首次快照读后，其他事务在某行附近插入了新字段，当前事务再插入字段时会发生错误，区分点在于其他事务新增了字段。</li></ul><p><em><strong>RC,RR级别下的InnoDB快照读有什么不同？</strong></em></p><ul><li>RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的，而早于Read View创建的事务所做的修改均是可见。</li><li>在RC级别下的事务中，每次快照读都会新生成一个快照和Read View, 因此可以在RC级别下的事务中可以看到别的事务提交的更新。</li></ul><h3 id="redo-log、undo-log、binlog"><a href="#redo-log、undo-log、binlog" class="headerlink" title="redo log、undo log、binlog"></a>redo log、undo log、binlog</h3><p><strong>binlog</strong>（Binary Log）</p><p>二进制日志文件就是常说的binlog。二进制日志记录了MySQL所有修改数据库的操作，然后以二进制的形式记录在日志文件中，其中还包括每条语句所执行的时间和所消耗的资源，以及相关的事务信息。</p><p>默认情况下，二进制日志功能是开启的，启动时可以重新配置<code>--log-bin[=file_name]</code>选项，修改二进制日志存放的目录和文件名称。</p><p><strong>redo log</strong></p><p>重做日志用来实现事务的持久性，即事务ACID中的D。它由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），它是持久的。</p><p>InnoDB是事务的存储引擎，它通过Force Log at Commit机制实现事务的持久性，即当事务提交（COMMIT）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的COMMIT操作完成才算完成。这里的日志是指重做日志，在InnoDB存储引擎中，由两部分组成，即redo log和undo log。</p><p>redo log用来保证事务的持久性，undo log用来帮助事务回滚及MVCC的功能。redo log基本上都是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作。而undo log是需要进行随机读写的。</p><p><strong>undo log</strong></p><p>undo log有两个作用：提供回滚和多个行版本控制(MVCC).主要分为两种</p><p>undo log的记录伴随着redo log，undo log会记录事务执行过程中相反的一条语句，事务提交后可立即清除。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p><em><strong>MySQL什么时候用的MVCC？</strong></em></p><p>InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC。</p><p><em><strong>MVCC简介</strong></em></p><p>MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁（读采用快照读，而增删改用的是当前读，需要加锁），因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：</p><ol><li>隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等。</li><li>基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。</li><li>ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本。但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。</li></ol><p><em><strong>MVCC一般是用来干什么的？</strong></em></p><ul><li><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突（不能解决更新丢失问题），做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。</p><p>  不加锁地处理读写冲突，提高数据库并发性能。</p></li><li><p>用MVCC和锁的组合解决并发读写冲突 （具体是怎么实现的？）</p><ul><li>MVCC + 悲观锁 MVCC解决读写冲突，悲观锁解决写写冲突；</li><li>MVCC + 乐观锁 MVCC解决读写冲突，乐观锁解决写写冲突 这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题；</li></ul></li></ul><blockquote><p>数据库的并发场景有三种：读-读：不存在任何问题，也不需要并发控制；读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</p></blockquote><p><em><strong>MVCC的实现原理</strong></em></p><p>MVCC的实现原理主要是依赖记录中的隐式字段，回滚日志（undo log），读视图（read view）来实现的。</p><ul><li><p>隐式字段（仅前两个与MVCC有关）</p><ul><li>DB_TRX_ID（事务ID）：6byte，记录创建这条记录/最后一次修改该记录的事务ID</li><li>DB_ROLL_PT（回滚指针）：7byte，指向这条记录的上一个版本（存储于rollback segment里）</li><li>DB_ROW_ID（隐含的自增ID（隐藏主键））：6byte，如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li></ul></li><li><p>回滚日志</p><ul><li>insert undo log：代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li><li>update undo log：事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，==只有在快照读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除。== <!--没太懂--></li></ul><blockquote><p>purge 从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。 为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</p></blockquote></li><li><p>读视图</p><ul><li><p>read view 主要是用来做可见性判断的。</p><p>  当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p></li><li><p>read view 如何进行可见性判断的？/ 判断的条件是什么？/ 可见性算法是如何实现的？</p><ol><li>如果记录的事物ID比当前活跃事务的ID都小，说明读的记录为最新版本，因此可见；</li><li>如果记录的事务ID比当前活跃的事务的ID都大，说明相对当前活跃事务，记录对应的事务还未提交，因此不可见；</li><li>如果记录的事务ID在活跃事务ID的范围中：如果活跃事务ID列表中包含记录的事务ID，说明该记录的事务还在活跃状态中，尚未提交，因此不可见；反之则可见。</li></ol></li></ul></li></ul><p><img src="/img/2021/MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="MVCC实现原理"></p><p><em><strong>MVCC的增删改查是如何work的？</strong></em></p><ul><li>增：在新增记录的隐式字段中，记录事务ID设为当前事务ID，回滚指针初始化为null；</li><li>删：直接把该行的被删除版本号（记录的事务ID中的一个特殊的位）设置为当前的事务ID；</li><li>改：1. 对当前记录加行锁；2. 拷贝当前记录的副本到回滚日志中，如果发现该行记录已经存在在回滚日志中，就头插法插入到该链表中，没有则新建一个链表作为该链表的头指针；3. 插入一个新记录，事务ID为当前事务ID，回滚指针指向undo log该记录的副本地址；4. 提交事务，释放锁。</li><li>查：满足以下两个条件才会被返回：1. 记录的修改版本号要小于当前事务ID（确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据）；2. 记录的删除版本号要么为空，要么大于当前事务ID（确保查询出来的数据行记录在事务开启之前没有被删除）。</li></ul><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><p><img src="/img/2021/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81.png" alt="数据库锁"></p><p><em><strong>乐观锁</strong></em></p><p>乐观锁一般是指用户自己实现的一种锁机制，假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。乐观锁的实现方式一般包括使用版本号和时间戳。</p><p><em><strong>悲观锁</strong></em></p><p>悲观锁一般就是我们通常说的数据库锁机制，以下讨论都是基于悲观锁。 悲观锁主要表锁、行锁、页锁。在MyISAM中只用到表锁，不会有死锁的问题，锁的开销也很小，但是相应的并发能力很差。innodb实现了行级锁和表锁，锁的粒度变小了，并发能力变强，但是相应的锁的开销变大，很有可能出现死锁。同时inodb需要协调这两种锁，算法也变得复杂。InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。 表锁和行锁都分为共享锁和排他锁（独占锁），而更新锁是为了解决行锁升级（共享锁升级为独占锁）的死锁问题。 innodb中表锁和行锁一起用，所以为了提高效率才会有意向锁（意向共享锁和意向排他锁）。</p><p><em><strong>意向锁</strong></em></p><p>意向锁是用来增加表锁行锁读写效率的，属于表级锁。</p><p>场景：事务A拿到了表的行锁读，事务B想拿该表的表锁写。这时候B的写可能会影响到A的读。有了意向锁后，A想拿表的行锁读，先检测该表有没有表锁写，没有就开始读。当B想表锁写，发现有A有行锁读，会阻塞。</p><p>意向锁分为意向共享锁（IS）和意向排它锁（IX）。</p><p><em><strong>共享锁</strong></em></p><ol><li>加锁与解锁：当一个事务执行select语句时，数据库系统会为这个事务分配一把共享锁，来锁定被查询的数据。在默认情况下，数据被读取后，数据库系统立即解除共享锁。例如，当一个事务执行查询“SELECT * FROM accounts”语句时，数据库系统首先锁定第一行，读取之后，解除对第一行的锁定，然后锁定第二行。这样，在一个事务读操作过程中，允许其他事务同时更新accounts表中未锁定的行。</li><li>兼容性：如果数据资源上放置了共享锁，还能再放置共享锁和更新锁。</li><li>并发性能：具有良好的并发性能，当数据被放置共享锁后，还可以再放置共享锁或更新锁。所以并发性能很好。</li></ol><p><em><strong>排他锁</strong></em></p><ol><li>加锁与解锁：当一个事务执行insert、update或delete语句时，数据库系统会自动对SQL语句操纵的数据资源使用独占锁。如果该数据资源已经有其他锁（任何锁）存在时，就无法对其再放置独占锁了。</li><li>兼容性：独占锁不能和其他锁兼容，如果数据资源上已经加了独占锁，就不能再放置其他的锁了。同样，如果数据资源上已经放置了其他锁，那么也就不能再放置独占锁了。</li><li>并发性能：最差。只允许一个事务访问锁定的数据，如果其他事务也需要访问该数据，就必须等待。</li></ol><p><img src="/img/2021/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E4%BA%92%E6%96%A5%E6%80%A7.png" alt="数据库锁的互斥性"></p><p><em><strong>更新锁</strong></em> </p><p>更新锁在的初始化阶段用来锁定可能要被修改的资源，这可以避免使用共享锁造成的死锁现象。例如，对于以下的update语句：</p><p><code>UPDATE accounts SET balance=900 WHERE id=1</code></p><p>更新操作需要分两步：读取accounts表中id为1的记录 –&gt; 执行更新操作。</p><p>如果在第一步使用共享锁，再第二步把锁升级为独占锁，就可能出现死锁现象。例如：两个事务都获取了同一数据资源的共享锁，然后都要把锁升级为独占锁，但需要等待另一个事务解除共享锁才能升级为独占锁，这就造成了死锁。</p><p>更新锁有如下特征：</p><ol><li>加锁与解锁：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。</li><li>兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放置更新锁和共享锁，但是最多放置一把更新锁。这样，当多个事务更新相同的数据时，只有一个事务能获得更新锁，然后再把更新锁升级为独占锁，其他事务必须等到前一个事务结束后，才能获取得更新锁，这就避免了死锁。</li><li>并发性能：允许多个事务同时读锁定的资源，但不允许其他事务修改它。</li></ol><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="优化查询策略"><a href="#优化查询策略" class="headerlink" title="优化查询策略"></a>优化查询策略</h3><ol><li><p>使用索引</p><p> 索引可以提高查询的速度，但并不是使用带有索引的字段查询时索引都会起作用。</p><p> 索引不起作用的几种情况：</p><ol><li><p>使用LIKE关键字的查询语句</p><p> 在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。</p></li><li><p>使用多列索引的查询语句</p><p> MySQL可以为多个字段创建索引。一个索引可以包括16个字段。对于多列索引，只有查询条件中使用了这些字段中的第1个字段时索引才会被使用。</p></li><li><p>使用OR关键字的查询语句</p><p> 查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，查询中才使用索引。否则，查询将不使用索引。</p></li></ol></li><li><p>优化子查询</p><p> 使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作。</p><p> 子查询虽然可以使查询语句很灵活，但执行效率不高。执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表。然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。因此，子查询的速度会受到一定的影响。如果查询的数据量比较大，这种影响就会随之增大。</p><p> 在MySQL中，可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引，性能会更好。</p></li></ol><h3 id="表中含有上千万条数据怎么办？"><a href="#表中含有上千万条数据怎么办？" class="headerlink" title="表中含有上千万条数据怎么办？"></a>表中含有上千万条数据怎么办？</h3><p>建议按照如下顺序进行优化：</p><ol><li>优化SQL和索引；</li><li>增加缓存，如memcached、redis；</li><li>读写分离，可以采用主从复制，也可以采用主主复制；</li><li>使用MySQL自带的分区表，这对应用是透明的，无需改代码，但SQL语句是要针对分区表做优化的；</li><li>做垂直拆分，即根据模块的耦合度，将一个大的系统分为多个小的系统；</li><li>做水平拆分，要选择一个合理的sharding key，为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表。</li></ol><h3 id="慢查询优化的经验："><a href="#慢查询优化的经验：" class="headerlink" title="慢查询优化的经验："></a>慢查询优化的经验：</h3><ol><li><p>开启慢查询日志：</p><p> MySQL中慢查询日志默认是关闭的，可以通过配置文件<code>my.ini</code>或者<code>my.cnf</code>中的<code>log-slow-queries</code>选项打开，也可以在MySQL服务启动的时候使用<code>--log-slow-queries[=file_name]</code>启动慢查询日志。</p><p> 启动慢查询日志时，需要在<code>my.ini</code>或者<code>my.cnf</code>文件中配置<code>long_query_time</code>选项指定记录阈值，如果某条查询语句的查询时间超过了这个值，这个查询过程将被记录到慢查询日志文件中。</p></li><li><p>分析慢查询日志：</p><p> 直接分析mysql慢查询日志，利用<code>explain</code>关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。</p><p> 常见慢查询优化：</p><ol><li><p>索引没起作用的情况</p><ul><li>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不会起作用。只有“%”不在第一个位置，索引才会起作用。</li><li>MySQL可以为多个字段创建索引。一个索引可以包括16个字段。对于多列索引，只有查询条件中使用了这些字段中的第1个字段时索引才会被使用。</li><li>查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，查询中才使用索引。否则，查询将不使用索引。</li></ul></li><li><p>优化数据库结构</p><ul><li>对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li><li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</li></ul></li><li><p>分解关联查询</p><p> 很多高性能的应用都会对关联查询进行分解，就是可以对每一个表进行一次单表查询，然后将查询结果在应用程序中进行关联，很多场景下这样会更高效。</p></li><li><p>优化LIMIT分页</p><p> 当偏移量非常大的时候，例如可能是limit 10000,20这样的查询，这是mysql需要查询10020条然后只返回最后20条，前面的10000条记录都将被舍弃，这样的代价很高。优化此类查询的一个最简单的方法是尽可能的使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。对于偏移量很大的时候这样做的效率会得到很大提升。</p></li></ol></li></ol><h3 id="分表-amp-分区-amp-分库"><a href="#分表-amp-分区-amp-分库" class="headerlink" title="分表 &amp; 分区 &amp; 分库"></a>分表 &amp; 分区 &amp; 分库</h3><ol><li><p>分表：分表包含垂直切分和水平切分。</p><ul><li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。<ul><li>每个表的结构都不一样；</li><li>每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据；</li><li>所有表的并集是全量数据；</li><li>场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。</li><li>分析：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。</li></ul></li><li>水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。<ul><li>每个表的结构都一样；</li><li>每个表的数据都不一样，没有交集；</li><li>所有表的并集是全量数据；</li><li>场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。</li></ul></li></ul></li><li><p>分区：将大表进行分区，不同分区可以放置在不同存储设备上，这些分区在逻辑上组成一个大表，对客户端透明。</p><ul><li>分区方式：和水平切片是类似的，分区方式也和水平切片方式类似，如范围切片，取模切片等</li><li>数据库分区无法将分区跨库，更不能跨数据库服务器，但能保存在不同数据文件从而放置在不同存储设备上</li></ul></li><li><p>分库</p><ul><li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。<ul><li>每个库的结构都不一样；</li><li>每个库的数据也不一样，没有交集；</li><li>所有库的并集是全量数据；</li><li>场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。</li><li>分析：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。</li></ul></li><li>水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。<ul><li>每个库的结构都一样；</li><li>每个库的数据都不一样，没有交集；</li><li>所有库的并集是全量数据；</li><li>场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。</li></ul></li></ul></li></ol><p><img src="/img/2021/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.jpeg" alt="分库分表"></p><h3 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h3><p>MySQL中提供了EXPLAIN语句和DESCRIBE语句，用来分析查询语句，EXPLAIN语句的基本语法为：<code>EXPLAIN [EXTENDED] SELECT select_options</code></p><p>使用<code>EXTENED</code>关键字，EXPLAIN语句将产生附加信息。执行该语句，可以分析EXPLAIN后面SELECT语句的执行情况，并且能够分析出所查询表的一些特征。下面对查询结果进行解释：</p><ul><li>id：SELECT识别符。这是SELECT的查询序列号。</li><li>select_type：表示SELECT语句的类型。</li><li>table：表示查询的表。</li><li>type：表示表的连接类型。</li><li>possible_keys：给出了MySQL在搜索数据记录时可选用的各个索引。</li><li>key：是MySQL实际选用的索引。</li><li>key_len：给出索引按字节计算的长度，key_len数值越小，表示越快。</li><li>ref：给出了关联关系中另一个数据表里的数据列名。</li><li>rows：是MySQL在执行这个查询时预计会从这个数据表里读出的数据行的个数。</li><li>Extra：提供了与关联操作有关的信息。</li></ul><h3 id="高效插入数据策略"><a href="#高效插入数据策略" class="headerlink" title="高效插入数据策略"></a>高效插入数据策略</h3><p>影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。针对这些情况，可以分别进行优化。（为什么是这么因素导致的？）</p><p>对于InnoDB引擎的表，常见的优化方法如下：</p><ol><li><p>禁用唯一性检查</p><p> 插入数据之前执行<code>set unique_checks=0</code>来禁止对唯一索引的检查，数据导入完成之后再运行<code>set unique_checks=1</code>。</p></li><li><p>禁用外键（非主键）检查</p><p> 插入数据之前执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。</p></li><li><p>禁用自动提交</p><p> 插入数据之前禁止事务的自动提交，数据导入完成之后，执行恢复自动提交操作。</p></li></ol><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ol><li><a href="https://www.nowcoder.com/discuss/135748">https://www.nowcoder.com/discuss/135748</a></li><li><a href="https://www.huaweicloud.com/articles/8ac1dc6dfe005bdaf76f7d1d2136276a.html">https://www.huaweicloud.com/articles/8ac1dc6dfe005bdaf76f7d1d2136276a.html</a></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统知识点梳理</title>
    <link href="/2021/08/14/tech/CSBase/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/14/tech/CSBase/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><p>操作系统是管理硬件和软件的一种应用程序，它为计算机硬件和软件提供了一种中间层，使应用软件和硬件进行分离，让我们无需关注硬件的实现，把关注点更多放在软件应用上。</p><h3 id="操作系统是干什么的？"><a href="#操作系统是干什么的？" class="headerlink" title="操作系统是干什么的？"></a>操作系统是干什么的？</h3><p>管理计算机资源，这些资源包括 CPU、内存、磁盘驱动器、打印机等。<br>提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁。<br>为其他软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。</p><h3 id="用户态和核心态"><a href="#用户态和核心态" class="headerlink" title="用户态和核心态"></a>用户态和核心态</h3><p>用户态和内核态是操作系统的两种运行状态。</p><p><em><strong>内核态</strong></em></p><p> 处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</p><p><em><strong>用户态</strong></em></p><p> 处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</p><p><em><strong>为什么要有用户态和内核态？</strong></em></p><p> 这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p><p><em><strong>用户态和内核态是如何切换的？</strong></em></p><p>只能<code>系统调用</code>才能操作用户态与内核态的切换，而只有<code>操作系统</code>才能操作系统调用。</p><p>用户态 -&gt; 内核态 的工作流程：</p><ol><li>首先用户程序会调用 glibc 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li><li>glibc 库知道针对不同体系结构调用系统调用的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li><li>然后，glibc 库调用软件中断指令(SWI) ，这个指令通过更新 CPSR 寄存器将模式改为超级用户模式，然后跳转到地址 0x08 处。</li><li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li><li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 vector_swi()。</li><li>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 sys_call_table 的索引，调转到系统调用函数。</li><li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li></ol><p><img src="/img/2021/%E7%94%A8%E6%88%B7%E6%80%81-%3E%E5%86%85%E6%A0%B8%E6%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="用户态-&gt;内核态工作流程"></p><p><em><strong>内核</strong></em></p><p>内核是一个计算机程序，它是操作系统的核心，可以控制操作系统中所有的内容。内核通常是在 <code>boot loader</code>装载程序之前加载的第一个程序。</p><blockquote><p>boot loader又被称为引导加载程序，能够将计算机的操作系统放入内存中。在电源通电或者计算机重启时，BIOS会执行一些初始测试，然后将控制权转移到引导加载程序所在的主引导记录(MBR) 。</p></blockquote><h3 id="操作系统启动过程"><a href="#操作系统启动过程" class="headerlink" title="操作系统启动过程"></a>操作系统启动过程</h3><!--todo--><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p><em><strong>进程</strong></em></p><p>进程就是正在执行程序的实例，比如说 Web 程序就是一个进程，shell 也是一个进程，文章编辑器 typora 也是一个进程。</p><p><em><strong>进程表</strong></em></p><p>操作系统为了跟踪每个进程的活动状态，维护了一个进程表。在进程表的内部，列出了每个进程的状态以及每个进程使用的资源等。</p><p><em><strong>进程控制块（PCB）</strong></em></p><p>PCB是进程的唯一标识，系统通过PCB来控制和管理进程的状态。</p><p>PCB主要包含的信息：进程描述信息、进程控制和管理信息、资源分配清单、处理机相关信息。</p><blockquote><p>PCB里含有进程的标识信息、状态信息、资源的占有情况等。</p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><em><strong>线程的实现方式</strong></em></p><ol><li>用户级线程：线程的控制和管理发生在应用程序，内核不感知。而且一般从单线程开始，运行过程中派生出其他线程。</li><li>内核级线程：线程的控制和管理发生在内核，应用程序不感知。</li><li>组合方式：线程的创建、调度、同步都发生在用户空间，一个内核线程映射多个用户线程。</li></ol><p><em><strong>线程模型</strong></em></p><ol><li>多对一：所有用户线程都对应一个内核线程。<strong>线程管理在用户空间</strong>。优点是效率高，缺点是内核线程阻塞，所有用户线程都受到影响。</li><li>一对一：一个用户线程对应一个内核线程。<strong>线程管理在内核空间</strong>。有点是并发能力强，缺点是开销大，程序性能低。</li><li>多对多：少量内核线程映射多量的用户线程。取二者所长，弥补二者所短。</li></ol><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p><em><strong>进程和线程的区别</strong></em></p><p>资源和调度：进程是资源分配的最小单位；线程是cpu调度的最小单位。</p><p>并发：进程是用来实现各应用程序并发的，线程是为了提高并发性能的。（因为进程切换需要虚拟内存空间的切换，而线程可以共享进程资源，因此上下文切换的开销小。）</p><p>系统开销：进程的上下文切换开销大，而线程的上下文切换开销小。</p><p>地址空间：进程间相互独立，进程内的线程共享资源，并且对其他进程的线程不可见。</p><p>通信：进程间通信通过同步和互斥保证数据的一致性，线程可以直接读写数据。</p><h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>并发：一个cpu处理多个线程；<br>并行：多个cpu，每个cpu处理一个线程。</p><h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>IPC(Inter Process Communication)：进程间通信。</p><ul><li><p>共享内存</p><p>  多个进程可以直接在内核专门预留一块内存空间读写，是最快的IPC形式。</p><p>  需要同步机制（信号量）达到进程间的同步及互斥。</p><ul><li>信号量<ul><li>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</li><li>进程获得共享资源需要进行的操作：1、创建一个信号量，初始值为0或1；2、等待一个信号量：该操作测试信号量的值，如果小于0，就阻塞，也称为P操作；3、挂出一个信号量：该操作将信号量的值加1，也称为V操作。</li><li>信号量的操作都是原子的（PV原语，或wait、signal），是在内核中实现的。</li><li>信号量和互斥量之间的区别：互斥量用于线程的互斥，信号量用于线程的同步。</li></ul></li></ul></li><li><p>管道</p><p>  半双工通信方式，双方通信需要建立两个管道；</p><p>  是一个独立的文件系统，只存在在内存中；</p><p>  本质是一个内核缓冲区，可以认为是一个循环队列。进程以先进先出的方式从缓冲区存取数据，一端进程顺序写到队尾，一端进程从队头开始读数据，且每个数据只能被读一次；</p><p>  只能用于亲缘进程之间的通信。（非亲缘进程可以通过有名管道通信） </p></li><li><p>消息队列 </p><p>  消息队列是以消息（每个消息都被认为是一个管道，接收进程可以独立地接收含有不同管道的数据结构）为单位的链表，存放在内存中并由消息队列标识符标识，能提供不同进程间的全双工通信。</p><ul><li>消息队列 &amp; 管道 对比：<ul><li>管道是跟随进程的，进程结束之后，管道随之销毁；消息队列是跟随内核的，进程结束之后，消息队列还会存在，只有在操作系统关机之后才会销毁；</li><li>管道是文件，存储在磁盘上，消息队列是数据结构，存储在内存上，因此消息队列的性能比管道更高；</li><li>管道是流式存储，消息队列是数据块式存储。</li></ul></li></ul></li><li><p>信号</p><p>  信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p><p>  SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。</p></li><li><p>socket</p><p>  这种通信方式可以实现跨机器的进程通信。</p><p>  socket是对TCP/IP协议簇的接口抽象。</p><ul><li>socket通信的建立过程：<ul><li>服务端：<ol><li>服务器系统调用socket创建一个套接字；</li><li>服务器进程调用<code>bind</code>方法给套接字命名，并等待客户端连接到这个套接字；</li><li>系统调用<code>listen</code>来创建一个队列并将其用于存放来自客户的进入连接；</li><li>服务器通过系统调用<code>accept</code>来接受客户的连接，并创建新的套接字用于特定客户端的连接。</li></ol></li><li>客户端：<ol><li>客户端系统调用socket创建一个未命名套接字;</li><li>然后将服务器创建的命名套接字作为地址，调用<code>connect</code>与服务器进行连接；</li><li>建立连接后，就可以用套接字进行数据双向通信。</li></ol></li></ul></li></ul></li></ul><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="同步-amp-互斥"><a href="#同步-amp-互斥" class="headerlink" title="同步 &amp; 互斥"></a>同步 &amp; 互斥</h3><p><em><strong>临界资源</strong></em></p><p>一次仅允许一个进程使用的资源称为临界资源。</p><p><em><strong>临界区</strong></em></p><p>访问临界资源的代码块称为临界区。</p><p><em><strong>互斥</strong></em></p><p>互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p><p><em><strong>同步</strong></em></p><p>同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</p><p><em><strong>同步机制的四个原则</strong></em></p><p>同步机制的四个原则：空闲让进、忙则等待、有限等待、让权等待。</p><p><em><strong>实现临界区互斥的方法</strong></em></p><p>软件方法：peterson算法</p><p>硬件方法：中断屏蔽、硬件指令</p><h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><p><em><strong>生产者-消费者问题</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 临界区互斥信号量</span><br>semaphore empty = n; <span class="hljs-comment">// 空闲缓冲区</span><br>semaphore full = <span class="hljs-number">0</span>; <span class="hljs-comment">// 缓冲区初始化为空</span><br>Producer() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        data = produce(); <span class="hljs-comment">// 生产数据</span><br>        P(empty); <span class="hljs-comment">// 要用一个empty，p一下</span><br>        P(mutex); <span class="hljs-comment">// 进入临界区，互斥夹紧</span><br>        buffer.add(data); <span class="hljs-comment">// 将数据放到缓冲区</span><br>        V(mutex); <span class="hljs-comment">// 离开临界区，释放信号量，互斥夹紧</span><br>        V(full); <span class="hljs-comment">// 提供了一个full，v一下</span><br>    &#125;<br>&#125;<br>Consumer() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        P(full); <span class="hljs-comment">// 用full，p一下</span><br>        P(mutex); <span class="hljs-comment">// 进入临界区</span><br>        data = buffer.remove(); <span class="hljs-comment">// 消费一个data</span><br>        V(mutex); <span class="hljs-comment">// 离开临界区，释放信号量</span><br>        V(empty); <span class="hljs-comment">// 提供了一个empty，v一下</span><br>        consume(data); <span class="hljs-comment">// 消费数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程是共享资源抽象出的一组数据结构及在该数据结构是那个实施操作的一组过程所组成的资源管理程序。</p><p>管程包含的要素：</p><ol><li>管程的名称</li><li>内部的数据结构</li><li>对数据结构进行操作的一组过程（函数）</li><li>对内部共享数据的初始化操作</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">monitor Demo &#123;<br>    struct S &#123;<br>        ... // 共享数据结构<br>    &#125;<br>    conditon x; // 定义一个条件变量x<br>    init_code() &#123;<br>        ... // 对共享数据进行初始化<br>    &#125;<br>    take_away() &#123;<br>        if (S &lt;= 0) x.wait(); // 资源不够，在条件变量x上进行阻塞<br>        ... // 资源充足，分配资源，做一系列相应处理<br>    &#125;<br>    give_back() &#123;<br>        ... // 归还资源，做一系列相应处理<br>        if (有进程在等待) x.signal; //唤醒一个阻塞进程<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><em><strong>死锁产生的原因</strong></em></p><p>资源竞争和程序执行顺序不当</p><p><em><strong>死锁产生的必要条件</strong></em></p><ol><li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li><li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li><li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li><li>循环等待条件：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li></ol><p><em><strong>死锁的处理策略</strong></em></p><ol><li>死锁预防<ol><li>破坏互斥条件：一般不会破坏互斥的条件，但可以尽量做到尽可能少的进程可以请求资源。</li><li>破坏保持和等待条件：让进程在运行前一次申请完它需要的全部资源，会造成“饥饿”。</li><li>破坏不可抢占条件：cpu的中断等，</li><li>破坏循环等待条件：顺序资源分配法，给资源分配编号，每次申请比之前编号大的资源。</li></ol></li><li>死锁避免<ol><li>银行家算法</li></ol></li><li>死锁检测和解除<ol><li>检测方法：根据死锁定理，如果资源分配图可以被完全简化，说明不存在死锁，反之，则会死锁。</li><li>死锁解除的方法：资源剥夺；撤销进程；进程回退。</li></ol></li></ol><p><em><strong>银行家算法</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 进程集合</span><br><span class="hljs-keyword">static</span> HashSet&lt;Integer&gt; processSet;<br><span class="hljs-comment">// 当前可用资源，m代表资源总类，available[j] 代表第j类资源可用的数量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] available;<br><span class="hljs-comment">// 已分配资源, allocation[i][j] 代表进程i已经分配到的j资源的数量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] allocation;<br><span class="hljs-comment">// 资源最大请求数，need[i][j]代表进程i对j资源的最大请求数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] need;<br><span class="hljs-comment">// 资源总类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 银行家算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i 进程</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> j 资源类别</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k 进程申请资源数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Banker</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (k &gt;= need[i][j]) &#123;<br>            <span class="hljs-comment">// 抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &gt; available[j]) &#123;<br>            <span class="hljs-comment">// 阻塞进程i</span><br>            wait(i);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            available[j] -= k;<br>            allocation[i][j] += k;<br>            need[i][j] -= k;<br>            <span class="hljs-keyword">if</span> (!isSafe()) &#123;<br>                available[j] += k;<br>                allocation[i][j] -= k;<br>                need[i][j] -= k;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 为进程i分配资源</span><br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 处理异常</span><br>        log.error(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true: 存在安全序列 false: 不存在安全序列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSafe</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">while</span> (processSet.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Integer i: processSet) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (available[j] &gt;= need[i][j] - allocation[i][j]) &#123;<br>                    available[j] += allocation[i][j];<br>                    processSet.remove(i);<br>                    found = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (! found) <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进程的状态模型"><a href="#进程的状态模型" class="headerlink" title="进程的状态模型"></a>进程的状态模型</h2><h3 id="进程的五种状态"><a href="#进程的五种状态" class="headerlink" title="进程的五种状态"></a>进程的五种状态</h3><p>进程的五种状态：运行态、就绪态、阻塞态、创建态、结束态。</p><ol><li>运行态：进程在处理机上运行；</li><li>就绪态：进程除了处理机外获取了其他一切资源，等待处理机被调度执行；</li><li>阻塞态：进程正在等待某一事件而释放处理机资源；</li><li>创建态：进程正在被创建；</li><li>结束态：进程正从系统中消失。</li></ol><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p><em><strong>操作系统创建一个进程的过程</strong></em></p><ol><li>为新进程分配一个唯一标识号，并申请一个空白的PCB；</li><li>为进程分配内存空间等资源（体现在PCB），资源不足，则进入阻塞状态；</li><li>初始化PCB，主要包括初始化标志信息、处理机状态信息、处理机控制信息、进程优先级等；</li><li>将进程加入到就绪队列里，等待执行。</li></ol><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p><em><strong>进程终止的原因</strong></em></p><ol><li>正常结束</li><li>异常结束：存储区越界、非法指令、运行超时、IO故障等；</li><li>外界干扰，如操作系统干预、父进程终止等。</li></ol><p><em><strong>进程终止的过程</strong></em></p><ol><li>根据标示号，检索PCB，读出进程状态；</li><li>如果进程处于运行态，终止运行，释放处理机资源；</li><li>若进程有子进程，终止子进程；</li><li>将进程拥有的全部资源归还给父进程或操作系统；</li><li>将该PCB从所在队列中清除。</li></ol><h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><p><em><strong>阻塞的执行过程</strong></em></p><ol><li>找到进程标识对应的PCB；</li><li>如果进程状态为运行态，保护现场，转换状态为阻塞态，停止运行；</li><li>将PCB插入事件的等待队列，释放处理机资源。</li></ol><p><em><strong>唤醒的执行过程</strong></em></p><ol><li>在事件的等待队列中找到相应进程的PCB；</li><li>将其从等待队列中移除，并置进程状态为就绪态；</li><li>把PCB插入就绪队列，等待调度程序调度。</li></ol><h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><p><em><strong>进程切换的执行过程</strong></em></p><ol><li>保存处理机上下文，包括程序计数器及一些寄存器；</li><li>更新PCB信息；</li><li>把PCB移到相应的队列（就绪队列、阻塞队列）</li><li>选择另一个进程执行，并更新其PCB；</li><li>更新内存管理的数据结构</li><li>恢复处理机的上下文。</li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="影响调度程序性能的指标"><a href="#影响调度程序性能的指标" class="headerlink" title="影响调度程序性能的指标"></a>影响调度程序性能的指标</h3><ul><li>cpu使用率</li><li>等待时间</li><li>吞吐量：单位时间内完成进程的数量</li><li>响应时间：从提交作业到开始执行作业的时间</li><li>周转时间：从提交作业到完成作业的时间</li></ul><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>算法简单，效率低，非抢占，长作业有利，有利于cpu繁忙型作业，不利于IO繁忙型作业。</p><h3 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h3><p>对长作业不利（饥饿），不能保证紧迫性作业及时处理。</p><h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>优先级用于描述作业的紧迫程度。</p><p>分为抢占式和非抢占式。</p><p>IO型 &gt; CPU型；系统进程 &gt; 用户进程</p><h3 id="高响应比调度"><a href="#高响应比调度" class="headerlink" title="高响应比调度"></a>高响应比调度</h3><p>是先来先服务和短作业优先的平衡算法。</p><p><code>响应比 = （等待时间 + 要求服务时间）/ 要求服务时间</code></p><h3 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h3><h3 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h3><p>是对优先级和时间轮转的发展。</p><ol><li>设置多个就绪队列，赋予不同的优先级；</li><li>为就绪队列赋予时间片，优先级越高的就绪队列时间片越短；</li><li>新进程进入内存后，放到最高优先级的队列，按先来先服务等待调度，执行时间为分配的时间片时间；如果没有执行完就放到第二优先级的队列的队尾；</li><li>仅当第一优先级为空的时候，再来调度第二优先级队列里的进程。</li></ol><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><p><em><strong>程序装入内存要经过哪几步？</strong></em></p><ol><li>编译：由编译器将用户源代码编译成若干目标块；</li><li>链接：由链接程序将编译后的形成的一组目标块及所需的库函数链接在一起，形成一个完整的装入模块；</li><li>装入：由装入程序将装入模块装入内存运行。</li></ol><p><em><strong>程序的链接有哪几种方式？</strong></em></p><ol><li>静态链接：程序在运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。</li><li>装入时动态链接：装入内存时，边装入边链接。</li><li>运行时动态链接：程序执行中需要该模块时才进行链接。</li></ol><p><em><strong>程序的装入有哪几种方式？</strong></em></p><ol><li>绝对装入：逻辑地址和实际内存地址相同，直接把程序装入内存某个位置，只适用于单道程序环境。</li><li>静态重定位装入：将作业一次性装入内存，装入时对程序的指令和数据的修改，相对于起始位置进行重定位。</li><li>动态重定位装入：程序执行时，再把相对地址转为绝对地址。</li></ol><p><em><strong>覆盖 &amp; 交换</strong></em></p><p>覆盖和交换是多道程序下扩充内存的两种方法。</p><p>覆盖用在同一程序和进程中，交换技术用在不同进程之间。</p><p><em><strong>覆盖</strong></em></p><p>把用户空间分成一个固定区和若干个覆盖区，将经常活跃的部分放到固定区，将即将要访问的段放到覆盖区，其他段放在外存，在需要调用前，系统将其从外存调到覆盖区，替换覆盖区原有的段。</p><p><em><strong>交换</strong></em></p><p>把等待状态的程序从内存移到辅存，即<code>唤出</code>；把准备好竞争cpu资源的程序从辅存移到内存，即<code>唤入</code>。</p><blockquote><p>区别于换页，交换是针对等待资源的程序而言的。</p></blockquote><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="按需分页"><a href="#按需分页" class="headerlink" title="按需分页"></a>按需分页</h3><p>在操作系统中，进程是以页为单位加载到内存中的，按需分页是一种虚拟内存的管理方式。</p><p>当操作系统需要访问的页未在内存中，会出现<code>缺页异常</code>。操作系统才会将磁盘页面复制到内存中。</p><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p><em><strong>连续的分配管理方式</strong></em></p><ol><li>单一连续分配</li><li>固定分区分配</li><li>动态分区分配</li></ol><p><em><strong>非连续的分配管理方式</strong></em></p><ol><li>基于分页存储管理方式</li><li>基于分段存储管理方式 </li><li>段页式管理方式</li></ol><h3 id="空闲内存管理方式"><a href="#空闲内存管理方式" class="headerlink" title="空闲内存管理方式"></a>空闲内存管理方式</h3><p>操作系统在动态分配内存时，需要对空闲内存进行管理。一般采用了两种方式：位图和空闲链表。</p><p><em><strong>位图</strong></em></p><p>用1位（0/1）来表示一块内存区域的使用情况，以此来跟踪内存的使用情况。</p><p>位图的缺点是，很难通过位图来找到一块连续的确定大小的内存空间。</p><p><em><strong>空闲链表</strong></em></p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是一种基于非连续分配管理方式的内存分配的机制。</p><p><em><strong>虚拟内存的实现方式</strong></em></p><p>虚拟内存在软件层面使用的是非连续的分配管理方式。</p><p>需要的硬件方面的支持：</p><ol><li>一定容量的内存和外存；</li><li>页表机制（或段表机制），作为主要的数据结构；</li><li>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断；</li><li>地址变换机构，逻辑地址到物理地址的变换。</li></ol><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ol><li><p>最佳置换（OPT）算法</p><p>当调入新的一页而必须预先置换某个老页时，所选择的老页应是将来不再被使用，或者是在最远的将来才被访问。</p></li><li><p>先进先出（FIFO）算法：</p><p> 优先淘汰最早进入内存的页。</p><p> 但是会出现Belady异常（分配的物理块增大但页故障数不减反增）。</p><p> 效率不高，在按线性顺序访问地址空间时才是理想的。</p></li><li><p>最近最久未使用（LRU）算法</p><p> 该算法认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。</p><p> LRU算法需要为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰时选择页面字段最大的值进行淘汰。</p><p> LRU性能较好，但是需要寄存器和栈的硬件支持。</p><p> LRU是堆栈类的算法，而FIFO是基于队列实现的。</p></li><li><p>时钟（CLOCK）置换算法</p></li></ol><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><ol><li>固定分配局部置换：为每个进程分配一定数目的物理块，整个运行期不改变。缺页时候，从内存中唤出一页，唤进一页。</li><li>可变分配全局置换：为每个进程分配一定数目的物理块，操作系统维护一个空闲物理块的队列，缺页时，从队列中出队空闲的物理块，并进行换页。</li><li>可变分配局部置换：为每个进程分配一定数目的物理块，缺页时，从该进程的内存中换页，不会影响其他进程的运行。</li></ol><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>刚刚唤出的页马上又要唤入内存，刚刚唤入的页马上又要唤出，这种频繁的页面调度就称为抖动。</p><p>其原因在于频繁访问的页面数目多于可用的物理页数目。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件在磁盘，访问磁盘的速度远小于内存。 </p><h2 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h2><p>提高文件系统性能的方法：</p><ol><li><p>高速缓存</p><p> 最常见的减少访问磁盘次数的技术：缓冲区高速缓存(buffer cache)。</p><p> 高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</p></li><li><p>块提前读：直接将接下来可能用到的块先写到高速缓存中。</p></li><li><p>减少磁盘臂运动：把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数。</p></li><li><p>磁盘碎片整理</p></li></ol><h2 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h2><p><em><strong>影响磁盘快速读写的因素</strong></em></p><ol><li>寻道时间：活动头磁盘在读写信息前，将磁头移动到指定磁道所需要的时间。</li><li>延迟时间：磁头定位到某一磁道的扇区（块号）所需要的时间。</li><li>传输时间：从磁盘读写数据所需要的时间。</li></ol><p><em><strong>调度算法</strong></em></p><ol><li>先来先服务（FCFS）算法</li><li>最短寻找时间优先算法</li><li>扫描（电梯调度）算法</li><li>循环扫描算法</li></ol><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h2><ol><li>程序直接控制方式：cpu要不断检测外设状态，直到确定已经把数据读到寄存器中。cpu使用率低。</li><li>中断驱动方式：解决cpu等待io的问题，但数据从存储器到IO都要走cpu。</li><li>DMA方式：数据开始和结束传输的时候走cpu，其他时间都是dma芯片来管理控制数据的传输的。</li><li>通道控制方式：在dma技术之上发展的，把对一个数据块的读写单位扩展为对一个组数据块的读写，同时实现cpu、通道、io的并行操作，进一步提高系统的资源利用率。</li></ol><h3 id="DMA-直接内存访问"><a href="#DMA-直接内存访问" class="headerlink" title="DMA(直接内存访问)"></a>DMA(直接内存访问)</h3><p>CPU授权IO模块权限跳过CPU直接读写内存，整个过程由DMA的芯片管理，这样可以缓解总线上的拥塞。</p><p>DMA的特点：</p><ol><li>数据传送以数据块为基本单位</li><li>数据从设备直接送入主存，或者从主存直接输出到设备上</li><li>仅在传输数据的开始和结束的时候需要cpu的介入，而整个传输的过程只需要dma的芯片参与。</li></ol><h3 id="中断处理的过程"><a href="#中断处理的过程" class="headerlink" title="中断处理的过程"></a>中断处理的过程</h3><ol><li>关中断。CPU关闭中断，即不再接受其他外部中断请求。</li><li>保存断点。将发生中断处的指令地址压入堆栈，以使中断处理完后能正确的返回（注意，有可能保存中断处的指令地址，也有可能是中断处的指令的下一条指令的地址，具体情况视中断的类型）。</li><li>识别中断源。CPU识别中断的来源，确定中断类型号，从而找到相应的中断处理程序的入口地址</li><li>保存现场（以上三步一般由处理中断的硬件电路完成）。将发生中断处的有关寄存器（中断服务程序要使用的寄存器）以及标志寄存器的内容压入堆栈。</li><li>执行中断服务程序。转到中断服务程序入口开始执行，可在适时时刻重新开放中断，以便允许响应较高优先级的外部中断。</li><li>恢复现场并返回（后三步一般软件，即中断处理程序完成）。把“保护现场”时压入堆栈的信息弹回寄存器，然后执行中断返回指令，从而返回主程序继续运行。（IRET指令，无操作数，从栈顶弹出3个字，分别送入IP、CS和FLAGS寄存器）</li></ol><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>计算机程序，用来控制和操作连接到计算机的设备。</p><p>驱动程序提供了与硬件交互的软件接口，使操作系统或计算机程序可以直接访问硬件，而不需要了解硬件的具体构造。</p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络知识点梳理</title>
    <link href="/2021/08/12/tech/CSBase/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/12/tech/CSBase/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h1><p>七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>五层：物理层、数据链路层、网络层、运输层、应用层。</p><table><thead><tr><th>七层网络体系结构</th><th>任务</th><th>功能</th><th>传输单位</th><th>实现硬件</th><th>协议</th></tr></thead><tbody><tr><td>物理层</td><td>传比特流传比特流</td><td>为数据段设备提供传送数据通路为数据段设备</td><td>比特</td><td>集线器、中继器</td><td></td></tr><tr><td>数据链路层</td><td>将IP报文封装成帧</td><td>链路连接的建立、拆除和分离；帧定界和帧同步；差错检测</td><td>帧</td><td>交换机、网桥</td><td>PPP、STP、ARQ</td></tr><tr><td>网络层</td><td>将传输层的报文封装成分组；选择路由，将报文交付到目的主机。</td><td>为传输层提供服务；组包和拆包；路由选择；拥塞控制</td><td>数据段</td><td>路由器</td><td>ICMP、ARP、IP、IGMP、OSPF</td></tr><tr><td>传输层</td><td>负责主机中两个进程的通信</td><td>为端到端连接提供可靠的服务；为端到端连接提供流量控制、差错控制、服务质量管理等</td><td>报文段（TCP）、用户数据报（UDP）</td><td></td><td>TCP、UDP</td></tr><tr><td>会话层</td><td>不同主机各进程间的对话</td><td>管理主机间的会话进程，端到端服务。</td><td></td><td></td><td></td></tr><tr><td>表示层</td><td>负责处理两个内部数据表示结构不同的通信系统间交换信息的表示格式。</td><td>为数据加密和解密；为提高传输效率提供必需的数据压缩和解压。</td><td></td><td></td><td></td></tr><tr><td>应用层</td><td>提供系统与用户的接口</td><td>文件传输；访问和管理；电子邮件服务</td><td></td><td></td><td>FTP、SMTP、POP3、HTTP、DNS</td></tr></tbody></table><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p><em><strong>DNS的定义</strong></em></p><p>DNS的全称是domain name system，即域名系统。DNS是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的去访问互联网而不用去记住能够被机器直接读取的IP地址。</p><p>DNS要做的就是将域名解析成IP。</p><p><em><strong>DNS解析域名的过程</strong></em></p><ol><li>在浏览器中输入 <a href="http://www.baidu.com/">www.baidu.com</a> 域名，操作系统会先检查自己本地的hosts文件是否有这个域名的映射关系，如果有，就先调用这个IP地址映射，完成域名解析；</li><li>如果hosts文件中没有，则查询本地DNS解析器缓存，如果有，则完成地址解析；</li><li>如果本地DNS解析器缓存中没有，则去查找本地DNS服务器，如果查到，完成解析。</li><li>如果没有，则本地服务器会向根域名服务器发起查询请求。根域名服务器会告诉本地域名服务器去查询哪个顶级域名服务器；</li><li>本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地域名服务器去查找哪个权限域名服务器；</li><li>本地域名服务器向权限域名服务器发起查询请求，权限域名服务器告诉本地域名服务器<a href="http://www.baidu.com/">www.baidu.com</a> 所对应的IP地址；</li><li>本地域名服务器告诉主机<a href="http://www.baidu.com/">www.baidu.com</a> 所对应的IP地址。</li></ol><blockquote><p>主机向本地域名服务器的查询一般是采用递归查询，而本地域名服务器向根域名的查询一般是采用迭代查询。<br><em><strong>递归查询</strong></em>：主机向本地域名发送查询请求报文，而本地域名服务器不知道该域名对应的IP地址时，本地域名会继续向根域名发送查询请求报文，不是通知主机自己向根域名发送查询请求报文。<br><em><strong>迭代查询</strong></em>：本地域名服务器向根域名发出查询请求报文后，根域名不会继续向顶级域名服务器发送查询请求报文，而是通知本地域名服务器向顶级域名发送查询请求报文。</p></blockquote><p><em><strong>URI和URL的区别</strong></em></p><p><strong>URI(Uniform Resource Identifier)</strong> ：中文全称为统一资源标志符，主要作用是唯一标识一个资源。<br><strong>URL(Uniform Resource Location)</strong> ：中文全称为统一资源定位符，主要作用是提供资源的路径。<br>有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个人。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td></tr><tr><td>POST</td><td>传输实体主体</td></tr><tr><td>PUT</td><td>上传文件</td></tr><tr><td>DELETE</td><td>删除文件</td></tr><tr><td>HEAD</td><td>和GET方法类似，但只返回报文首部，不返回报文实体主体部分</td></tr><tr><td>PATCH</td><td>对资源进行部分修改</td></tr><tr><td>OPTIONS</td><td>查询指定的URL支持的方法</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td></tr><tr><td>TRACE</td><td>服务器会将通信路径返回给客户端</td></tr></tbody></table><p><em><strong>GET和POST的差别</strong></em></p><ul><li><p>作用</p><p>GET用于获取资源，POST用于传输实体主体。GET相当于SELECT，POST相当于CREATE。</p></li><li><p>参数位置</p><p>GET的参数放在URL中，POST的参数存储在实体主体中，并且GET方法提交的请求的URL中的数据做多是2048字节，POST请求没有大小限制。</p></li><li><p>安全性</p><p>GET方法因为参数放在URL中，安全性相对于POST较差一些。</p></li><li><p>幂等性</p><p>GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的。</p></li></ul><p><em><strong>POST和PUT的区别</strong></em></p><p>POST相当于CREATE，PUT相当于UPDATE。</p><p>二者都用于请求数据的更新和创建。</p><p>但二者最本质的区别在于POST不是幂等的，而PUT是幂等的。即PUT多次返回结果是一样的，但POST多次会返回不同的对象。POST由服务器来指定地址，而PUT是用户指定的。</p><p>比如一个用户要对一个账号反复修改密码，就要用PUT，而一个用户想要创建多个账号，就要用POST。</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ol><li><p>1XX：信息性状态码，表示接受的请求正在处理</p><p> 100 Continue：表示正常，客户端可以继续发送请求<br> 101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。</p></li><li><p>2XX：成功状态码，表示请求正常处理完毕</p><p> 200 OK：请求成功<br> 201 Created：已创建，表示成功请求并创建了新的资源<br> 202 Accepted：已接受，已接受请求，但未处理完成。<br> 204 No Content：无内容，服务器成功处理，但未返回内容。<br> 205 Reset Content：重置内容，服务器处理成功，客户端应重置文档视图。<br> 206 Partial Content：表示客户端进行了范围请求，响应报文应包含Content-Range指定范围的实体内容</p></li><li><p>3XX：重定向状态码，表示需要进行附加操作以完成请求</p><p> 301 Moved Permanently：永久性重定向<br> 302 Found：临时重定向<br> 303 See Other：和301功能类似，但要求客户端采用get方法获取资源<br> 304 Not Modified：所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。<br> 305 Use Proxy：所请求的资源必须通过代理访问<br> 307 Temporary Redirect： 临时重定向，与302类似，要求使用get请求重定向。</p></li><li><p>4XX：客户端错误码，服务器无法处理请求</p><p> 400 Bad Request：客户端请求的语法错误，服务器无法理解。<br> 401 Unauthorized：表示发送的请求需要有认证信息。<br> 403 Forbidden：服务器理解用户的请求，但是拒绝执行该请求。<br> 404 Not Found：服务器无法根据客户端的请求找到资源。<br> 405 Method Not Allowed：客户端请求中的方法被禁止<br> 406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求<br> 408 Request Time-out：服务器等待客户端发送的请求时间过长，超时</p></li><li><p>5XX：服务器错误码，服务器处理请求出错</p><p> 500 Internal Server Error：服务器内部错误，无法完成请求<br> 501 Not Implemented：请求方法不被服务器支持，或无法处理。<br> 502 Bad Gateway：服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。<br> 503 Service Unavailable：服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。<br> 504 Gateway Timeout：当服务器作为网关，不能及时得到响应时返回此错误代码。</p></li></ol><h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h3><table><thead><tr><th align="center"></th><th align="center">HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td align="center">端口</td><td align="center">80</td><td>443</td></tr><tr><td align="center">安全性</td><td align="center">无加密，安全性较差</td><td>有加密机制，安全性较高</td></tr><tr><td align="center">资源消耗</td><td align="center">较少</td><td>由于加密处理，资源消耗更多</td></tr><tr><td align="center">是否需要证书</td><td align="center">不需要</td><td>需要</td></tr><tr><td align="center">协议</td><td align="center">运行在TCP协议之上</td><td>运行在SSL协议之上，SSL运行在TCP协议之上</td></tr></tbody></table><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><em><strong>加密过程</strong></em></p><p>HTTPS使用混合加密方式，使用非对称加密来传输对称密钥来保证安全性，使用对称加密来保证通信的效率。</p><ol><li>客户端向服务端发起第一次握手请求，告诉服务端客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。</li><li>服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。</li><li>服务端将证书发给客服端。</li><li>客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。</li><li>客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。</li><li>服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。</li><li>通信双方可用对称密钥来加密解密信息。</li></ol><p><img src="/img/2021/https%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B.png" alt="https加密过程"></p><p><em><strong>各版本区别</strong></em></p><p><strong>HTTP 1.0和HTTP 1.1</strong></p><ol><li><p>长连接</p><p> HTTP 1.1支持长连接和请求的流水线操作。</p><p> 长连接是指不在需要每次请求都重新建立一次连接，HTTP 1.0默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大。</p><p> 请求的流水线操作是指客户端在收到HTTP的响应报文之前可以先发送新的请求报文，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。</p></li><li><p>管道化（假并行传输）</p><p> 当网络请求包含多个文本、图像、视频等资源时，HTTP1.1 支持并行发送。</p><p> 但对处理器而言，必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。</p><p> HTTP管道化可以把先进先出队列从客户端(请求队列)迁移到服务端(响应队列)，但其并没有解决队头阻塞的问题。</p></li><li><p>支持响应请求的某部分资源</p><p>服务端可以只响应客户端请求对象的一部分。在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分，返回的状态码为206。</p><p>而在HTTP 1.0中会存在浪费带宽的现象，主要是因为不支持断点续传功能，客户端只是需要某个对象的一部分，服务端却将整个对象都传了过来。</p><p>如此可以优化网络带宽。</p></li><li><p>增加缓存处理，支持断点续传</p><p> HTTP1.1还加入了缓存处理(强缓存和协商缓存)，新的字段如cache-control，支持断点传输，以及增加了Host字段(使得一个服务器能够用来创建多个Web站点)</p></li></ol><p><strong>HTTP2.0 新特性</strong></p><ol><li><p>二进制分帧</p><p> HTTP2.0通过在应用层和传输层之间增加一个二进制分层帧，突破了HTTP1.1解析是基于文本的性能限制，改进传输性能。</p></li><li><p>多路复用</p><p> 一条TCP连接可以承载任意流量的双向数据流，数据流会被拆分成帧，乱序发送，然后再根据每个帧头部的流标识符（stream_id）重新封装。</p><p> 现阶段浏览器的优化策略是，同时建立多个TCP的会话，实现真并行。</p><p> 对并行性能的分析：</p><pre><code> 1. 并行连接可能会因为充分利用客户端的带宽从而提高加载速度；  2. 在客户端带宽不充足的情况下，并不会提高加载速度，而且并行连接会产生额外的开销；  3. 浏览器做的渐进式并行加载会让用户感觉加载速度快了。</code></pre></li><li><p>header压缩</p><p> 在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，同时通信双方各自缓存一份header fields表，避免了header的重复传输。</p></li><li><p>服务端推送</p><p> 客户端在请求一个资源时，会把相关资源一起发给客户端，这样客户端就不需要再次发起请求。</p></li></ol><p><em><strong>HTTP3.0 新特性</strong></em></p><p>HTTP3.0是基于google的QUIC协议，而QUIC协议是使用UDP实现的。</p><p>QUIC协议特性：</p><ol><li><p>0-RTT ：传输层和加密层在0-RTT就能建立连接。</p><p> 缓存当前会话的上下文，下次恢复会话的时候，只需要将之前的缓存传递给服务器，验证通过，就可以进行传输了。</p></li><li><p>多路复用</p><p> QUIC基于UDP，一个连接上的多个stream之间没有依赖，即使丢包，只需要重发丢失的包即可，不需要重传整个连接。</p></li><li><p>移动端表现更好</p><p> QUIC在移动端的表现比TCP好，因为TCP是基于IP识别连接，而QUIC是通过ID识别链接。 无论网络环境如何变化，只要ID不便，就能迅速重新连上。</p></li><li><p>报文加密认证 </p><p> QUIC几乎所有报文头部都是经过认证的，报文Body都是经过加密的。</p><p> TCP协议头没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改、注入和窃听。</p></li><li><p>向前纠错机制 </p><p> 每个数据包除了它本身的内容之外还包括了其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。</p><p> 向前纠错牺牲了每个数据包可以发送数据的上限，但是优化了数据重传的时间消耗，提升了传输性能。</p></li></ol><p>参考链接：<a href="https://blog.csdn.net/gogzf/article/details/78287166">参考1</a>、<a href="https://network.51cto.com/art/202010/628901.htm">参考2</a>、<a href="https://juejin.cn/post/6844903976354185230#heading-0">参考3</a></p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>FTP协议就是用来传输文件的，而且仅仅用来传输文件。FTP的惟一工作就是确保文件正确的传输，除了校验发送和接收的文件是否一致以外，它不会像HTTP那样停下来翻译文件的内容。</p><p>FTP 使用两个并行的 TCP 连接来传输文件： </p><p>（1）控制连接（持久）：传输控制信息，如用户标识、口令、改变远程目录命令、文件获取上传 的命令；<br>（2）数据连接（非持久）：传输实际文件。 FTP 客户机发起向 FTP 服务器的控制连接，然后在该连接上发送用户标识和口令、改变远程目 录的命令。FTP服务器收到命令后，发起一个到客户机的数据连接，在该连接上准确地传送一个文件并关闭连接。 </p><p>有状态的协议：FTP服务器在整个会话期间保留用户的状态信息。服务器必须把特定的用户账号和控制连接联系起来。</p><h2 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h2><p><em><strong>在浏览器中输⼊url地址到显示主⻚的过程</strong></em></p><ol><li>对输入到浏览器的url进行DNS解析，将域名转换为IP地址。</li><li>和目的服务器建立TCP连接</li><li>向目的服务器发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析并渲染页面</li></ol><p><em><strong>cookie 和 session</strong></em></p><p>HTTP协议是无状态的，即服务器无法判断用户身份。Session和Cookie可以用来进行身份辨认。</p><p><strong>Cookie</strong></p><p>Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。</p><p><strong>Session</strong></p><p>Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。</p><p><strong>Token</strong></p><p>客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。</p><table><thead><tr><th align="center"></th><th align="center">存放位置</th><th align="center">占用空间</th><th align="center">安全性</th><th>应用场景</th></tr></thead><tbody><tr><td align="center">Cookie</td><td align="center">客户端浏览器</td><td align="center">小</td><td align="center">较低</td><td>一般存放配置信息</td></tr><tr><td align="center">Session</td><td align="center">服务端</td><td align="center">多</td><td align="center">较高</td><td>存放较为重要的信息</td></tr></tbody></table><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p><img src="/img/2021/TCP%E9%A6%96%E9%83%A8.webp" alt="TCP首部"></p><p><em><strong>TCP都有哪几种状态，分别都代表什么含义？</strong></em></p><ol><li>SYN：同步位，SYN = 1 表示连接请求；</li><li>FIN：终止位，FIN = 1 表示释放连接；</li><li>ACK：确认位，ACK = 1 表示确认号有效；</li><li>RST：复位位，RST = 1 表示TCP连接出现严重错误（主机崩溃等），需要重新建立连接；</li><li>PSH：推送位，PSH = 1 表示接收端要尽快交付任务，不要等到缓存满了再提交；</li><li>URG：紧急位，URG = 1 表示告诉系统该报文段为高优，需要加急传送。</li></ol><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p><img src="/img/2021/tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE.svg" alt="tcp状态转移图"></p><p><em><strong>三次握手</strong></em></p><table><thead><tr><th>握手</th><th>发送端</th><th>标志位</th><th>序号（seq）</th><th>确认号（ack）</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>client</td><td>SYN=1</td><td>x</td><td>-</td><td>CLOSE -&gt; SYN_SENT</td></tr><tr><td>2</td><td>server</td><td>SYN=1 ACK=1</td><td></td><td>x+1</td><td>CLOSE -&gt; SYN_RCVD</td></tr><tr><td>3</td><td>client</td><td>ACK=1</td><td>x+1</td><td>y+1</td><td>SYN_RCVD -&gt; ESTABLISHED</td></tr></tbody></table><p><img src="/img/2021/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.webp" alt="TCP三次握手"></p><p><em><strong>为什么是三次握手，不是两次？</strong></em></p><ol><li>server给client发送的ack丢失了，client认为没有建立连接，但server认为已经建立连接，server发送数据会浪费网络资源；</li><li>server接受到了一个失效的client发送的连接请求，会发送给client一个ack，但client不会发送数据，TCP连接也没有意义。</li></ol><p><em><strong>四次挥手</strong></em></p><ol><li>当客户端没有待发送的数据时，它会向服务端发送 FIN 消息，发送消息后会进入 FIN_WAIT_1 状态；</li><li>服务端接收到客户端的 FIN 消息后，会进入 CLOSE_WAIT 状态并向客户端发送 ACK 消息，客户端接收到 ACK 消息时会进入 FIN_WAIT_2 状态；</li><li>当服务端没有待发送的数据时，服务端会向客户端发送 FIN 消息；</li><li>客户端接收到 FIN 消息后，会进入 TIME_WAIT 状态并向服务端发送 ACK 消息，服务端收到后会进入 CLOSED 状态；</li><li>客户端等待两个最大数据段生命周期（Maximum segment lifetime，MSL）2的时间后也会进入 CLOSED 状态；</li></ol><table><thead><tr><th>挥手</th><th>发送端</th><th>标志位</th><th>序号（seq）</th><th>确认号（ack）</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>client</td><td>FIN=1</td><td>u</td><td></td><td>ESTABLISHED -&gt; FIN-WAIT-1</td></tr><tr><td>2</td><td>server</td><td>ACK=1</td><td>v</td><td>u+1</td><td>ESTABLISHED -&gt; CLOSE-WAIT <br />FIN-WAIT-1 - &gt; FIN-WAIT-2</td></tr><tr><td>3</td><td>server</td><td>FIN=1 ACK=1</td><td>w</td><td>u+1</td><td>CLOSE-WAIT -&gt; LAST-ACK</td></tr><tr><td>4</td><td>client</td><td>ACK=1</td><td>u+1</td><td>w+1</td><td>FIN-WAIT-2 -&gt; TIME-WAIT</td></tr></tbody></table><p><img src="/img/2021/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP四次挥手"></p><p><em><strong>为什么是四次挥手？</strong></em></p><ol><li>c-&gt;s-&gt;c-&gt;s ：TCP是全双工通信，第一次挥手是c不发数据了，第二次挥手是s对c不发数据的确认，第三次挥手是c收到s对c关闭连接的确认。但s还是可以单通道给c发数据的，并没有主动的释放连接。（而s对c的ack和s的FIN不能同时进行，因为如果s不主动FIN，c就会不停的给s发送FIN。）</li><li>c-&gt;s, s-&gt;c, s-&gt;c：s需要一个c对其FIN的确认，否则会超时重传。</li></ol><p><em><strong>TIME_WAIT持续两个MSL的作用</strong></em></p><ol><li>首先，可靠安全地关闭TCP连接。比如网络拥塞，如果主动关闭方最后一个ACK没有被被动关闭 方接收到，这时被动关闭方会对FIN进行超时重传，在这时尚未关闭的TIME_WAIT就会把这些尾巴 问题处理掉，不至于对新连接及其他服务产生影响。</li><li>其次，防止由于没有持续TIME_WAIT时间导致的新的TCP连接建立起来，延迟的FIN重传包会干扰新的连接。</li></ol><p><em><strong>为什么要TIME-WAIT？</strong></em></p><p>TIME_WAIT状态之所以存在,是为了保证网络的可靠性。由于TCP连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发FIN包的一方执行的是主动关闭，后发送FIN包的一方 执行的是被动关闭。主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留2MSL时长。如果 Server端一直没有向client端发送FIN消息(调用close() API)，那么这个CLOSE_WAIT会一直存在下去。</p><p><em><strong>TIME_WAIT占用的资源</strong></em></p><p>少量内存（大概4K）和一个文件描述符fd。</p><p><em><strong>有大量的TIME_WAIT状态怎么办？</strong></em></p><p>tcp是面向连接的，大量的timewait会导致连接数达到tcp端口上限，从而导致新建tcp失败，connect异常。</p><p>解决办法：1、客户端：http请求头，connection设置为keep-alive,保持存活一段时间（不需要再多建立tcp连接）；2、服务端：允许timewait的socket被重用，缩减timewait的时间。</p><p><em><strong>MSL、TTL及RTT的区别</strong></em></p><p>MSL(Maximum Segment Lifetime) ：报文最大生存时间，超过这个时间，报文就将在网络中被丢弃。在TCP第四次挥手进入TIME_WAIT后，要等待2MSL的时间。</p><p>TTL(time to live)：ip数据报可以经过的最大路由数，由源主机设置初始值时给定。每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。</p><p>RTT(round-trip time)：C/S往返所花时间。由TCP自适应算法计算动态给出，随着网络拥塞状态的变化而变化。</p><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><p>TCP是如何保证可靠传输的？</p><p>主要有校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。</p><p><em><strong>校验和</strong></em></p><p>具体步骤：</p><p>发送方将校验和报文段置0，加上12位的伪首部（伪首部 + 首部 + 数据），将拼接后的报文视为若干个16位的数据，按二进制反码计算这些16位数据的和，然后将结果的反码写到校验和报文段里。接收方拿到报文段，加上伪首部，做同样的操作，如果得到的为全1，则说明无差错。</p><blockquote><p>IP、UDP、TCP校验和计算方式相似，都是二进制反码运算求和再取反。区别在于IP只校验IP报文的首部，UDP和TCP校验首部和数据部分。</p></blockquote><p><em><strong>序列号</strong></em></p><p>TCP会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答(ACK报文)，并且这个ACK报文中带有相应的确认编号，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。</p><p><em><strong>重传</strong></em></p><p>超时重传 ：RTT超过RTO要进行重传。</p><blockquote><p>RTT（Round-Trip Time） ：TCP发送报文和收到确认的时间差。<br>RTO（Retransmission Time-Out） ：超时计时器设置的超时时间。</p></blockquote><p>冗余确认 ：利用序列号对缺失报文段进行计数，缩短超时周期，提高重传效率。</p><p><em><strong>停止等待协议</strong></em></p><p>每发完一个分组就停止发送，等待对方确认，在收到确认后再发下一个分组。</p><p>TCP默认使用累计确认，只确认第一个丢失包的序号位置。</p><blockquote><p>确认号(ack)：期望收到对方下一个报文段的数据的第一个字节的序号。</p></blockquote><p><em><strong>流量控制</strong></em></p><p>流量控制是匹配发送方的发送速率与接收方的读取速率。</p><p>TCP提供的是一种基于滑动窗口的控制机制。</p><p>接收方根据自己接收缓存的大小，动态调整接收窗口的大小通知发送方（通过调整TCP首部的“窗口”字段）；发送方根据当前网络拥塞程度确定拥塞窗口，取接受窗口和拥塞窗口的最小值作为发送窗口大小。</p><p><code>接收窗口 = 接收端缓存大小</code></p><p><code>发送窗口 = min&#123;接收窗口, 拥塞窗口&#125;</code></p><p>拥塞窗口：由发送方根据网络拥塞状态决定。</p><p><em><strong>拥塞控制</strong></em></p><p>拥塞控制的过程由四部分：慢开始、拥塞避免、快重传、快恢复。</p><p>慢开始：拥塞窗口初始值为1，然后指数增长，直到慢开始设定的门限。</p><p>拥塞避免：拥塞窗口达到慢开始门限后开始线性增长，直到网络阻塞，调整慢开始门限为网络拥塞时窗口的一半，重新从再慢开始。</p><p>快重传：当冗余确认超过预设值的时候，直接认为网络拥塞，相对拥塞避免，这是另一种认为网络拥塞的判决条件。</p><p>快恢复：快重传之后，将此时的发送窗口调整为拥塞窗口的一半，进行线性增长的发送数据。</p><blockquote><p>流量控制和拥塞控制的区别：流量控制是点对点的，是发生在TCP连接的两个socket之间，而拥塞控制是发生在全局网络的，在主机和路由器之间。</p></blockquote><p><img src="/img/2021/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B.webp" alt="拥塞控制过程"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><img src="/img/2021/UDP%E9%A6%96%E9%83%A8.webp" alt="UDP首部"></p><table><thead><tr><th align="center"></th><th align="center">是否面向连接</th><th align="center">可靠性</th><th align="center">传输形式</th><th align="center">传输效率</th><th align="center">消耗资源</th><th align="center">应用场景</th><th align="center">首部字节</th></tr></thead><tbody><tr><td align="center">TCP</td><td align="center">面向连接</td><td align="center">可靠</td><td align="center">字节流</td><td align="center">慢</td><td align="center">多</td><td align="center">文件/邮件传输</td><td align="center">20~60</td></tr><tr><td align="center">UDP</td><td align="center">无连接</td><td align="center">不可靠</td><td align="center">数据报文段</td><td align="center">快</td><td align="center">少</td><td align="center">视频/语音传输</td><td align="center">8</td></tr></tbody></table><p><em><strong>如何利用UDP进行可靠传输</strong></em></p><p>在弱网环境下，使用TCP连接的延迟很高，因此需要使用UDP保证数据传输能像TCP一样可靠。</p><p>传输层无法保证数据的可靠传输，只能通过应用层来实现。</p><p>可以从两个角度来实现：1）提供超时重传，避免数据丢失（保证不丢失）；2）提供确认序列号，可以对数据进行确认（保证不重复）和排序（保证有序）。</p><p>本端：首先在UDP数据报定义一个首部,首部包含确认序列号和时间戳,时间戳是用来计算RTT(数据报传输的往返时间),计算出合适的RTO(重传的超时时间)。然后以等-停的方式发送数据报,即收到对端的确认之后才发送下一个的数据报。当时间超时,本端重传数据报,同时RTO扩大为原来的两倍,重新开始计时。</p><p>对端:接受到一个数据报之后取下该数据报首部的时间戳和确认序列号,并添加本端的确认数据报首部之后发送给对端。根据此序列号对已收到的数据报进行排序并丢弃重复的数据报。</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP报文"><a href="#IP报文" class="headerlink" title="IP报文"></a>IP报文</h2><p><a href="/img/2021/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.png">IP数据包格式</a></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP协议的主要作用是实现在同一局域网内主机或路由器从IP地址到MAC地址的转换。是一个网络层的协议。</p><p><em><strong>ARP的工作流程</strong></em></p><ol><li>在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。</li><li>如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。</li><li>主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会向主机A以单播的方式发送一个带有自己MAC地址的响应分组。</li><li>主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。</li><li>如果主机A和主机B不在同一个局域网内，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。（主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中存的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。）</li></ol><blockquote><p>ARP解析的时候可能会涉及到路由的选择和转发算法。</p></blockquote><p><em><strong>IP地址 &amp; MAC地址</strong></em></p><p>网络层实现的是主机之间的通信，而链路层实现的是链路之间的通信，所以从下图可以看出，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变。</p><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p>ICMP（Intent Control Message Protocol）互联网控制报文协议：用于TCP/IP网络中发送控制消息，提供IP包废弃的各种问题反馈。</p><p>ICMP 报文是封装在 IP 包里面，是 IP 协议的助手，是<strong>网络层协议</strong>。</p><p><img src="/img/2021/ICMP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.jpg" alt="ICMP报文结构"></p><p>ICMP有两种报文格式：查询报文、差错报文。</p><h3 id="查询报文"><a href="#查询报文" class="headerlink" title="查询报文"></a>查询报文</h3><p>发送端主动发起请求，并且获取到应答。</p><p>典型的应用就是PING。</p><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>ping是ICMP(网际控制报文协议)中的一个重要应用，ping是<strong>应用层</strong>的协议（直接使用网络层的icmp，未走传输层）。ping的作用是测试两个主机的连通性。</p><p><em><strong>ping的工作过程</strong></em></p><ol><li>向目的主机发送多个ICMP回送请求报文</li><li>根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包往返时间及丢包率。</li></ol><p><em><strong>ping执行后都发生了什么？</strong></em></p><ol><li>ping 命令执行的时候，源主机首先会构建一个 ICMP 回送请求消息数据包。</li><li>ICMP 数据包内包含多个字段，最重要的是两个：第一个是类型，对于回送请求消息而言该字段为 8；另外一个是序号，主要用于区分连续 ping 的时候发出的多个数据包，每发出一个请求数据包，序号会自动加 1。</li><li>ICMP报文段作为IP报文的一部分，加上源ip地址和目的ip地址，拼接成ip数据包；</li><li>ip数据包通过ARP协议添加MAC头部，并转发到目的主机（中间可能涉及路由跳转）；</li><li>目的主机按MAC地址、IP数据包逐层解析；</li><li>响应阶段，目的主机会构建一个 ICMP 回送响应消息数据包，回送响应数据包的类型字段为 0，序号为接收到的请求数据包中的序号，然后再发送出去给源主机。</li></ol><h3 id="差错报文"><a href="#差错报文" class="headerlink" title="差错报文"></a>差错报文</h3><ol><li><p>终点不可达</p><p> A、网络不可达 — 代码为 0，<br> B、主机不可达 — 代码为 1.<br> C、协议不可达 — 代码为 2.<br> D、端口不可达 — 代码为 3.<br> E、需要分段 - 代码为 4.（ 必须把数据分段才能去到终点</p></li><li><p>源站抑制</p><p> 发送端发送大量数据时，可能会导致网络( 路由器 )过载，此时过载处可以向发送端发送源抑制的消息，让他降低发送速度。</p></li><li><p>时间超时</p><p> 网络包超过设置的在网络中的生存时间，还没有达到。</p></li><li><p>参数问题</p><p> 当目的主机或路由器收到的数据包的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</p></li><li><p>路由重定向</p><p> 定义数据包的路由规则。因为大部分的时候，路由规则是通过相关协议算法生成的，有些时候重新定义过之后，会让这个数据包绕的更远。</p></li></ol><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p>DHCP(Dynamic Host Configuration Protocol) 动态主机配置协议，用于给主机动态分配ip地址。</p><p>DHCP是应用层协议，基于UDP。</p><blockquote><p>应用层协议有两种工作方式：C/S方式和P2P方式，其他网络层的协议都没有这两种方式。</p></blockquote><p><em><strong>DHCP为什么是基于UDP的，不能是基于TCP的吗？</strong></em></p><p>由于DHCP客户机和服务器之间并没有彼此的ip，所以不能通过tcp协议进行socket连接。</p><p><em><strong>DHCP客户机和服务器是如何交互报文的？</strong></em></p><ol><li>客户机广播索要ip的消息；</li><li>服务器收到消息后，发出一个提供ip的消息；</li><li>客户机收到消息后，如果接受消息中的参数，再向服务器请求ip；</li><li>服务器收到请求消息后为客户机提供ip。</li></ol><p><em><strong>DHCP客户机和服务器之间为什么是广播不是单播？</strong></em></p><p>因为双方没有彼此的ip，必须通过广播传送参数和消息。</p><h2 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h2><p>NAT（Network Address Translation）网络地址转换，是内网（局域网）和外网（广域网）ip转换的协议。它的作用在于：1、整个内网只需要一个全球IP就可以全球互连，而内网IP是可重用的，因此可以节省IP资源的消耗；2、内网只用于LAN，不用于WAN，可以隐藏内部网络结构，提高网络安全性。</p><p>NAT协议通过NAT路由器实现的，NAT要通过NAT转换表，实现源ip地址或目的ip地址的转换。NAT转换表存放着{本地IP地址 : 端口}到{全球IP地址 : 端口}的映射。</p><p>内网ip网段：</p><ol><li>A类：10.0.0.0～10.255.255.255</li><li>B类：172.16.0.0～172.31.255.255</li><li>C类：192.168.0.0～192.168.255.255</li></ol><h2 id="CIDR协议"><a href="#CIDR协议" class="headerlink" title="CIDR协议"></a>CIDR协议</h2><!--todo--><p><a href="https://www.cnblogs.com/yezhi/articles/2689817.html">https://www.cnblogs.com/yezhi/articles/2689817.html</a></p><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><p>内部网关协议有rip，ospf等；外部网关协议有BGP等。</p><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>rip是一种分布式的基于距离向量的路由选择协议。属于<strong>应用层协议</strong>，<strong>基于UDP</strong>传输（端口号520）。</p><p><em><strong>rip规定</strong></em></p><ol><li>每个路由器都要维护从它自身到目的网路的距离记录（距离向量）；</li><li>经过一个路由，跳数就加1；</li><li>rip认为路由数最少的路径就是最短路径；</li><li>rip允许的最大路径长度时16，到了16就认为网络不可达（可见rip适合小型互联网）；</li><li>两个路由器之间要定期广播一次rip路由更新信息，以便动态维护；</li><li>早起rip只支持相同子网掩码的路由，但最新的rip支持变长子网掩码和CIDR。</li></ol><p><em><strong>rip特点</strong></em></p><ol><li>仅和邻近路由交换信息</li><li>按固定时间间隔（30s）交换的信息是当前路由的全部信息，即自己的路由表</li></ol><p>优点：简单、开销小、收敛过程快<br>缺点：限制了网络规模；网络规模大了之后，开销也大，因为每次交换彼此整个路由表；网络出现故障后，会出现慢收敛的情况。</p><blockquote><p>慢收敛：需要较长时间才能将此信息传达所有路由器。</p></blockquote><p><em><strong>rip工作原理</strong></em></p><p>算法：距离向量算法 </p><p>算法要点：设 X 是结点 A 到 B 的最短路径上的一个结点。若把路径 A到B 拆成两段路径 A到X 和 X到B，则每段路径 A到X 和 X到B 也都分别是结点 A到X 和结点 X到B 的最短路径。</p><p><a href="https://www.cnblogs.com/zhanghx/p/9761882.html">算法执行过程参考</a></p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p><em><strong>OSPF的特点</strong></em></p><ol><li>OSPF是网络层协议，直接用IP传数据；</li><li>OSPF使用泛洪法向所有路由器发送消息（与本路由器相邻的所有路由器的路由状态）；</li><li>只有当链路状态发生改变的时候才会发送消息；</li><li>不会出现慢收敛的情况。</li><li>可以实现负载均衡，当到同一目的网络的路径很多时，可以根据通信代价择优选择；</li></ol><p><em><strong>ospf工作原理</strong></em></p><p>每个路由器简历一个链路状态数据库。然后使用Dijkstra最短露尽该算法计算从自己到目的网络的最优路径，构造自己的路由表。当状态链路发生改变的时候，再更新路由表。</p><h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>BGP是应用层协议，基于TCP。</p><p>只需要找到一条可用的路由路径就返回。</p><p>工作原理：每个自治系统的管理员要选择至少一个路由器作为BGP发言人，然后各发言人之间建立tcp连接，交换路由信息，然后对于当前发言人，来选择一个较好的路由。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://juejin.cn/post/6844903662838349838">https://juejin.cn/post/6844903662838349838</a></li><li><a href="https://www.cnblogs.com/xiaolincoding/p/12571184.html">https://www.cnblogs.com/xiaolincoding/p/12571184.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Javax新特性梳理</title>
    <link href="/2021/08/11/tech/JavaSE/Javax%E6%96%B0%E7%89%B9%E6%80%A7%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/11/tech/JavaSE/Javax%E6%96%B0%E7%89%B9%E6%80%A7%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><em><strong>函数式编程</strong></em></p><p>Java8之前用的都是静态方法或实例方法，Java8新增了函数方法，即把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。</p><p>lambda表达式是函数式编程，lambda表达式的类型必须是函数式接口，被<code>@FunctionalInterface</code>注解修饰。<a href="https://blog.csdn.net/weixin_29131533/article/details/113082119">参考地址</a></p><blockquote><p>函数式编程是将函数(一段操作)作为一个基本单位进行传递。以前的Java中参数只能是具体的变量，函数式编程打破这一规范，可以将整个方法作为一个参数传递。</p></blockquote><p><em><strong>lambda表达式语法</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; &#123;&#125;()；(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;；<span class="hljs-comment">//小括号里无参数则留空()，有一个参数括号可以省略，多个参数用逗号隔开</span><br></code></pre></td></tr></table></figure><p><em><strong>FunctionalInterface（函数式接口）</strong></em></p><p>有且仅有一个抽象方法的接口。比如：<code>Comparator</code>、<code>Callable</code>、<code>Runnable</code> 等。</p><blockquote><p>虽然Comparator接口有很多方法，但只有一个抽象方法int compare(T o1, T o2)，其他的方法都是default方法或static方法。另外注意到boolean equals(Object obj)是Object定义的方法，不算在接口方法内。因此，Comparator也是一个FunctionalInterface。</p></blockquote><p><em><strong>方法引用</strong></em></p><p>方法引用：使用操作符 “ ::” 将方法名和对象或类的名字分隔开来。主要有：对象::实例方法 类::静态方法 类::构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String[] array = <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Lemon&quot;</span> &#125;;<br>        Arrays.sort(array, Main::cmp); <span class="hljs-comment">// 类::静态方法</span><br>        System.out.println(String.join(<span class="hljs-string">&quot;, &quot;</span>, array));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s1.compareTo(s2);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; names = List.of(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Tim&quot;</span>);<br>        List&lt;Person&gt; persons = names.stream().map(Person::<span class="hljs-keyword">new</span>).collect(Collectors.toList()); <span class="hljs-comment">// 类::构造方法</span><br>        System.out.println(persons);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person:&quot;</span> + <span class="hljs-keyword">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数；</li><li>lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获；</li><li>lambda表达式只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.</span><br>list.forEach((String s) -&gt; System.out.println(<span class="hljs-string">&quot;*&quot;</span> + s + <span class="hljs-string">&quot;*&quot;</span>));<br><span class="hljs-comment">// 3.</span><br>List&lt;Integer&gt; primes = Arrays.asList(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;);<br><span class="hljs-keyword">int</span> factor = <span class="hljs-number">2</span>;<br>primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;); <span class="hljs-comment">// run</span><br>primes.forEach(element -&gt; &#123; factor++; &#125;); <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><h2 id="Steam"><a href="#Steam" class="headerlink" title="Steam"></a>Steam</h2><h3 id="Steam-的特点"><a href="#Steam-的特点" class="headerlink" title="Steam 的特点"></a>Steam 的特点</h3><table><thead><tr><th align="left"></th><th align="left">java.io</th><th>java.util.stream</th></tr></thead><tbody><tr><td align="left">存储</td><td align="left">顺序读写的<code>byte</code>或<code>char</code></td><td>顺序输出的任意Java对象实例</td></tr><tr><td align="left">用途</td><td align="left">序列化至文件或网络</td><td>内存计算／业务逻辑</td></tr></tbody></table><table><thead><tr><th align="left"></th><th align="left">java.util.List</th><th>java.util.stream</th></tr></thead><tbody><tr><td align="left">元素</td><td align="left">已分配并存储在内存</td><td>可能未分配，实时计算</td></tr><tr><td align="left">用途</td><td align="left">操作一组已存在的Java对象</td><td>惰性计算</td></tr></tbody></table><blockquote><p> 惰性计算：一个<code>Stream</code>转换为另一个<code>Stream</code>时，实际上只存储了转换规则，并没有任何计算发生。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> result = createNaturalStream() <span class="hljs-comment">// 创建Stream</span><br>             .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">// 任意个转换</span><br>             .map(n -&gt; n * n) <span class="hljs-comment">// 任意个转换</span><br>             .limit(<span class="hljs-number">100</span>) <span class="hljs-comment">// 任意个转换</span><br>             .sum(); <span class="hljs-comment">// 最终计算结果</span><br></code></pre></td></tr></table></figure><h3 id="Steam-的创建"><a href="#Steam-的创建" class="headerlink" title="Steam 的创建"></a>Steam 的创建</h3><p><em><strong>Stream.of()</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br>        <span class="hljs-comment">// forEach()方法相当于内部循环调用，</span><br>        <span class="hljs-comment">// 可传入符合Consumer接口的void accept(T t)的方法引用：</span><br>        stream.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>基于数组或Collection</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;String&gt; stream1 = Arrays.stream(<span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span> &#125;);<br>        Stream&lt;String&gt; stream2 = List.of(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>).stream();<br>        stream1.forEach(System.out::println);<br>        stream2.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>基于Supplier</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Stream&lt;Integer&gt; natual = Stream.generate(<span class="hljs-keyword">new</span> NatualSupplier());<br>        <span class="hljs-comment">// 注意：无限序列必须先变成有限序列再打印:</span><br>        natual.limit(<span class="hljs-number">20</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NatualSupplier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        n++;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><blockquote><p>Map就是把一个Stream转换为另一个Stream。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; s = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);<br></code></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><blockquote><p>reduce是一个聚合方法，它可以把一个Stream的所有元素按照聚合函数聚合成一个结果，即一个 Java对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// acc 是上一层计算的结果，0是acc的初始化值</span><br>        <span class="hljs-keyword">int</span> sum = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>).reduce(<span class="hljs-number">0</span>, (acc, n) -&gt; acc + n);<br>        System.out.println(sum); <span class="hljs-comment">// 45</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><blockquote><p>所谓filter()操作，就是对一个Stream的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的Stream。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)<br>                .filter(n -&gt; n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>                .forEach(System.out::println); <span class="hljs-comment">// 1 3 5 7 9</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出集合"><a href="#输出集合" class="headerlink" title="输出集合"></a>输出集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输出为List</span><br>Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;  &quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br>List&lt;String&gt; list = stream.filter(s -&gt; s != <span class="hljs-keyword">null</span> &amp;&amp; !s.isBlank()).collect(Collectors.toList());<br>System.out.println(list);<br><br><span class="hljs-comment">// 输出为Map</span><br>Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;APPL:Apple&quot;</span>, <span class="hljs-string">&quot;MSFT:Microsoft&quot;</span>);<br>Map&lt;String, String&gt; map = stream<br>        .collect(Collectors.toMap(<br>                <span class="hljs-comment">// 把元素s映射为key:</span><br>                s -&gt; s.substring(<span class="hljs-number">0</span>, s.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>)),<br>                <span class="hljs-comment">// 把元素s映射为value:</span><br>                s -&gt; s.substring(s.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>) + <span class="hljs-number">1</span>)));<br>System.out.println(map);<br><br><span class="hljs-comment">// 输出为数组</span><br>List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br>String[] array = list.stream().toArray(String[]::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>秋招面试问题整理</title>
    <link href="/2021/08/10/work/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2021/08/10/work/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="华为-数通产品"><a href="#华为-数通产品" class="headerlink" title="华为-数通产品"></a>华为-数通产品</h1><h2 id="一面（2021-08-09-15-00-16-30）"><a href="#一面（2021-08-09-15-00-16-30）" class="headerlink" title="一面（2021-08-09 15:00 - 16:30）"></a>一面（2021-08-09 15:00 - 16:30）</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>面向对象有哪些特性？分别在java里是如何体现的，举例说明？</li><li>你在开发过程中用的Java的哪个版本？Java8有哪些新特性？在实践中你是如何运用的？</li><li>Map容器，输入c:1,a:2,b:3，按输入顺序输出，用什么类型的Map？（LinkedHashMap）</li><li>HashMap是线程安全的吗？Java是如何保证线程安全的？synchronized的工作原理？（AQS的工作原理没问）</li><li>HashMap的key是唯一的吗？Java如何比较两个key是否唯一？</li><li>以排序为例，如何用泛型重写？</li><li>定义一个泛型的步骤是怎样的？</li><li>为什么要用泛型？</li><li>用过反射吗？怎么用的？</li><li>Spring 是怎么实现AOP的？</li></ol><h3 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h3><ol><li>前后端分离的项目中，前后端都分别是部署在哪的？</li><li>前端（Vue框架）是如何给后端发送数据的？</li><li>后端部署远程服务的时候，用的jar包还是source code？maven对这两种方式是如何部署的？</li></ol><h3 id="手撕代码"><a href="#手撕代码" class="headerlink" title="手撕代码"></a>手撕代码</h3><p> <em><strong>题目</strong></em></p><p> 两个岛屿间的最短路径</p><p> 是lc中的岛屿数量问题的变形，该题中限制一个二维矩阵中有且只有两个岛屿，试返回两个岛屿之间的最短路径？</p><p> <em><strong>面试记录</strong></em></p><p> 考虑到返回的最小值的两个岛可能来自同一片岛屿，所以一上来要对每个岛所属的岛屿类型进行明确；</p><p> step1. 对二维矩阵进行遍历，用dfs算法为同一个岛屿上的岛进行类型标记；</p><p> step2. 再对二维矩阵进行遍历，如果当前格子是一个岛，分别对其上下左右进行dfs，如果旁边的格子也是岛，说明它们来自同一片岛，不进入dfs，如果不是岛，则进入dfs；</p><p> step3. dfs函数中，先对i, j做边界校验；然后对当前各自做校验，如果当前格子是一个岛，判断岛的类型，并与最初的岛的类型做比较，不同的话，更新最小值。如果当前格子不是一个岛，再对它的上下左右进行dfs。</p><h3 id="反思总结"><a href="#反思总结" class="headerlink" title="反思总结"></a>反思总结</h3><p> 一面总体感觉，面试官更侧重对Java基础和工程经验的考察。然后第一部分准备的不够充分，第二部分是目前的短板，需要后续准备中分别补齐。</p><p> 问的内容比较全面，但在深度上不是很深，只要对相关知识点，做下准备，能把问的问题接住就行，不需要过多的展开。</p><h2 id="二面（2021-08-09-16-30-18-00）"><a href="#二面（2021-08-09-16-30-18-00）" class="headerlink" title="二面（2021-08-09 16:30 - 18:00）"></a>二面（2021-08-09 16:30 - 18:00）</h2><h3 id="实习项目"><a href="#实习项目" class="headerlink" title="实习项目"></a>实习项目</h3><ol><li>数据封装的时候，可选字段是如何处理的？有没有校验机制？</li><li>用过哪几种线程池，在实际开发中，什么场景下使用的？</li><li>数据库中一张表很大的时候，是如何处理的？</li></ol><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>Spring 的IoC 和 AOP？</li><li>Spring容器初始化时是如何装载Bean的？Application Contest|Bean Factory（Bean的生命周期）?</li><li>JVM Java堆的内存是如何划分的？（新生代 老年代）</li><li>JVM 新生代和老年代的比例一般是多少？</li><li>JVM 调优经验？</li></ol><h3 id="手撕代码-1"><a href="#手撕代码-1" class="headerlink" title="手撕代码"></a>手撕代码</h3><p> <em><strong>题目</strong></em></p><p> <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></p><p> <em><strong>面试记录</strong></em></p><p> 这道题之前做过，思路上还是很快就知道解法的。但是好久没刷了，在实现的时候遇到了巨大的阻碍。好在面试官给了积极的提示，但是在最初给出提示之后，后来在我实现卡住的时候，也没有继续提示。</p><p> 当时心态很爆炸，想直接放弃的。但一想从面试官给提示的感觉来看，他还是希望我能做出来的，如果放弃了，很可能因为这一点把我pass掉。</p><p> 这个时候我静下心重新捋了下过程，根据dfs的入参，和递归调用的特性，把整个代码写出来了。</p><h3 id="反思总结-1"><a href="#反思总结-1" class="headerlink" title="反思总结"></a>反思总结</h3><p> 手撕代码环节面试官给出了一个非常宝贵的建议：一定要养成面向接口编程的好习惯。一个问题拿来，先对问题进行步骤拆解，具体实现的时候，一定要分清代码层次。</p><p> 以该题为例，写dfs()的时候，在传参确定前序中序数组的左右边界的时候花费了很长时间，并且写的代码耦合度高，如果后期维护排查出问题，不利于修改。因此一个好的做法是，再新建一个工具函数专门用来解决左右边界的确定，这样如果因为左右边界出错，只需要修改工具函数即可。</p><p> 通过这道题和面试官的交流，我认为考察角度有：1. 根据提示，是否有能力把问题独立解决出来，而不是因为这道题之前做过，现在忘了，就不能当作一个新的问题解决；2. 编程习惯考察，代码耦合程度是否较低，写出来的代码是否利于后期维护和排查问题；3. 对于面向接口编程，结构化编程的理解和应用。</p><h2 id="三面（2021-08-10-16-00-16-45）"><a href="#三面（2021-08-10-16-00-16-45）" class="headerlink" title="三面（2021-08-10 16:00 - 16:45）"></a>三面（2021-08-10 16:00 - 16:45）</h2><p><em><strong>主管综面</strong></em></p><ol><li>实习期间认为有哪些成长？</li><li>你经历的最大的问题和挑战是什么？</li><li>从内心上是如何感受和看待这些困难的？</li><li>工作岗位分布在北京、南京、武汉、东莞，你的意向是什么？</li></ol><p><em><strong>反问环节</strong></em></p><ol><li>团队主要的工作职责？（做供应链产品开发）</li><li>团队的组织架构大致是怎样的，一个小组多少人？</li><li>上下班双休加班情况（周三鼓励健身、周五鼓励早下班，其他工作日弹性制（区间一小时），满足8小时就可，上班时间看城市，晚上九点有班车）</li><li>有哪些定期的学习分享（mentor制，半年试用期，有一个答辩。平时会有技术栈专题的技术分享交流，团队有专门的架构师，负责产品升级迭代）</li><li>半年试用期答辩的后果和影响？（淘汰制，5% - 10%，主要淘汰不适应华为工作环境的人）</li><li>升职加薪周期（基本两年升一级，优秀的一年一级，非常优秀的一年两级）</li><li>户口问题（看北京给的指标，每年也都不一样，需要进一步和hr沟通；工作以后排队拿户口，但过程比较复杂）</li></ol><h1 id="腾讯-WXG微信支付"><a href="#腾讯-WXG微信支付" class="headerlink" title="腾讯-WXG微信支付"></a>腾讯-WXG微信支付</h1><h2 id="一面（2021-08-19-16-00-17-30）"><a href="#一面（2021-08-19-16-00-17-30）" class="headerlink" title="一面（2021-08-19 16:00 - 17:30）"></a>一面（2021-08-19 16:00 - 17:30）</h2><h3 id="算法题（1、2选一道，3、4选一道，40min）"><a href="#算法题（1、2选一道，3、4选一道，40min）" class="headerlink" title="算法题（1、2选一道，3、4选一道，40min）"></a>算法题（1、2选一道，3、4选一道，40min）</h3><ol><li><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/">旋转矩阵</a></li><li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为K的子数组</a></li><li><a href="https://blog.csdn.net/m0_38062470/article/details/115179259">用拉链法实现hash，接口：插入、查找，删除</a></li><li><a href="https://www.cnblogs.com/CherishFX/p/4643940.html">实现大根堆的构建方法和弹出堆顶方法</a></li></ol><h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>事务ACID分别指什么？具体解释一下</li><li>事务的隔离级别</li><li>数据库锁</li><li>多副本保持同步一致性的级别有哪些？（分布式系统一致性级别）</li><li>tcp中TIMEOUT发生在什么时候，它起到什么作用？存在哪些问题？如何优化？</li><li>tcp流量控制 &amp; 拥塞控制的方法</li><li>udp和tcp的区别</li><li>进程间通信方式</li><li>协程</li><li>哈希冲突的解决方式</li></ol><h3 id="反思总结-2"><a href="#反思总结-2" class="headerlink" title="反思总结"></a>反思总结</h3><p><em><strong>复盘</strong></em></p><p>我选的是第二题和第四题，第二题用的前缀和，算法复杂度略高，面试官期待用滑动窗口解法，不过我可以大致说一下思路，他说他知道我明白他的意思了。</p><p>第四题悄悄百度了一下，按照链接里的demo写的。但是面试官要求写一个类，里面实现两个方法，这个需求沟通没有完全落实。</p><p>堆排序的实现算法之前已经写过，当成了一个模板，不过一直没有人问，等这次真的有人问起来了，还没完全派上用场。好在之前捋过思路，就算按照demo抄一遍，也能口述出整体过程。</p><p>通过这次面试能看出来，1、基础常考问题一定要烂熟于心；2、算法题做的漂亮才是王道。</p><p><em><strong>一些细节反思</strong></em></p><p>算法题写的还是混乱，还是停留在实现算法层面，能不能accept都是一回事，但是对面试官一定是不友好的。一定要在提交之前，对代码进行重构，加好注释！！！</p><p>回答问题的时候，要直问直答！学习的时候喜欢追根溯源，横纵建立联系。但是面试的时候一定不要卖关子，面试官问什么，直接上来先回答出答案。但通常答案都是一两句话，很难算得上充分详实。这个时候需要对答案进行补充。补充思路大概有以下几种：1、对答案的细节点进行解释说明；2、场景举例说明；3、对所考察知识点相关知识点进行展开（将提前整理的知识体系思维导图进行展开说，说枝不说叶——只讲联系，不讲细节）。</p><p><em><strong>一些套路</strong></em></p><p>很难对所有的问题在短时间内进行充分的响应，有时候需要调用自己提前整理好的资料。这时候需要为找资料续一些时间。一个想到的办法是，可以对面试官的问题进行确认和复述，得到面试官的确认后，可以再问下，您这个问题是说**那块的内容吧？这个时候面试官一般都会确认，如果不是的话，也会引导你他想问的点。以上整个这块的时间完全够global search了。。</p><h1 id="百度-ACG智慧城市"><a href="#百度-ACG智慧城市" class="headerlink" title="百度-ACG智慧城市"></a>百度-ACG智慧城市</h1><h2 id="一面（2021-08-23-10-00-11-30）"><a href="#一面（2021-08-23-10-00-11-30）" class="headerlink" title="一面（2021-08-23 10:00 - 11:30）"></a>一面（2021-08-23 10:00 - 11:30）</h2><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><ol><li>实习期间工作内容和工作流程？</li><li>工作的时候使用工具平台过程中遇到了问题是怎么解决的？</li></ol><h3 id="基础知识-3"><a href="#基础知识-3" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>synchronized 和 ReentrantLock的区别？ </li><li>ReentranLock 在释放锁的时候做了哪些操作？</li><li>可重入性在源码是如何体现的？</li><li>Java容器的继承关系</li><li>HashMap底层实现原理？</li><li>讲一下HashMap的put的实现过程？</li><li>TreeMap底层实现原理？（我说没看过TreeMap源码，面试官把问题改成了如果让我设计一个排序的Map，要怎么设计？）</li></ol><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><p>用快排实现链表排序：<a href="https://leetcode-cn.com/problems/sort-list/">排序链表</a></p><h3 id="反思总结-3"><a href="#反思总结-3" class="headerlink" title="反思总结"></a>反思总结</h3><p>一个比较强烈的感受就是，面试官很喜欢问重点知识点的原理实现的流程。如果能把一个闭环的流程说清楚，面试官就会很满意，至于源码中实现的细节不会过问。</p><p>这里提供了一个很好的学习思路，也是面试中一个考察点：在基础知识面够（抛出一个简单常见的基本问题你得能接得住）的基础上，在表达陈述的时候，一定要流程化，不要东一个点，西一个点，尽量做到让整个表述完整，让一个小白听完也知道大概是怎么回事。</p>]]></content>
    
    
    <categories>
      
      <category>工作沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM梳理</title>
    <link href="/2021/08/07/tech/JavaSE/JVM%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/07/tech/JavaSE/JVM%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM包含四个部分：Class loader(类装载)、Execution engine(执行引擎)；Runtime data area(运行时数据区)、Native Interface(本地接口)。</p><ul><li>Class loader(类装载)：装载class文件到method area。</li><li>Execution engine（执行引擎）：将字节码命令解释给操作系统。</li><li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li><li>Runtime data area(运行时数据区域)：JVM的内存，存数据。</li></ul><p><em><strong>JVM执行过程</strong></em></p><ol><li>编译器把Java代码转成字节码，类加载器把字节码加载到内存（**<u>运行时数据区</u>**的方法区）中；</li><li>通过解析器**<u>执行引擎</u>**，将字节码翻译成OS底层指令，交由CPU执行；</li><li>整个过程中需要调用其他语言的**<u>本地库接口</u>**来实现程序功能。</li></ol><p><img src="/img/2021/jvm%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="jvm结构图"></p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>类的生命周期：加载、连接（验证、准备、解析）初始化。</p><p>###加载</p><p>加载过程加载的是.class 文件。</p><p><em><strong>加载过程</strong></em></p><ol><li>通过一个类的全限定名来获取其定义的二进制字节流；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ol><p><em><strong>加载方式</strong></em></p><ol><li>隐式加载：通过写程序new一个对象</li><li>显示加载：通过反射，class.forname()方法等</li></ol><p><img src="/img/2021/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p><p>这一步用<strong>类加载器</strong>来实现。</p><p><em><strong>连接</strong></em></p><ul><li><em><strong>验证</strong></em>：检查加载的 class 文件的正确性；</li><li><em><strong>准备</strong></em>：给类中的静态变量分配内存空间；</li><li><em><strong>解析</strong></em>：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li></ul><p><em><strong>初始化</strong></em></p><p>对静态变量和静态代码块执行初始化工作。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。</p><ol><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ol><p><img src="/img/2021/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="类加载器的层次"></p><h3 id="类加载机制-1"><a href="#类加载机制-1" class="headerlink" title="类加载机制"></a>类加载机制</h3><p><em><strong>双亲委派模型</strong></em></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。 </p><p>双亲委派模型不是一种强制性约束，也就是你不这么做也不会报错怎样的，它是一种JAVA设计者推荐使用类加载器的方式。Java历史上，有三次没有使用双亲委派模型的案例。</p><p><em><strong>双亲委派模型的代码实现</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name)<span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-comment">// 首先判断该类型是否已经被加载</span><br>            Class c = findLoadedClass(name);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                         <span class="hljs-comment">//如果存在父类加载器，就委派给父类加载器加载</span><br>                        c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span><br>                        c = findBootstrapClass0(name);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                 <span class="hljs-comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span><br>                    c = findClass(name);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (resolve) &#123;<br>                resolveClass(c);<br>            &#125;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br><br></code></pre></td></tr></table></figure><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>逻辑结构：什么时候回收？能回收什么？用什么回收？怎么回收的？</p><h3 id="垃圾回收原理机制"><a href="#垃圾回收原理机制" class="headerlink" title="垃圾回收原理机制"></a>垃圾回收原理机制</h3><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p><p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p><h3 id="判断一个对象是否可以被回收"><a href="#判断一个对象是否可以被回收" class="headerlink" title="判断一个对象是否可以被回收"></a>判断一个对象是否可以被回收</h3><p>两种策略：计数器算法和可达性分析算法</p><p><em><strong>计数器算法</strong></em></p><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 </p><p>该算法的缺陷是：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p><p><em><strong>可达性分析算法</strong></em></p><p>通过 GC Roots 作为起始点进行搜索，能够遍历到的对象都是存活的，遍历不到的对象可被回收。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p><em><strong>强引用</strong></em></p><p>发生 gc 的时候不会被回收。不会被gc回收。</p><p><em><strong>软引用</strong></em></p><p>有用但不是必须的对象，在发生内存溢出之前会被回收。（按内存走的）</p><p><em><strong>弱引用</strong></em></p><p>有用但不是必须的对象，在下一次GC时会被回收。（按gc周期走的）</p><p><em><strong>虚引用</strong></em></p><p>无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><em><strong>标记清除算法</strong></em></p><p>标记无用对象，然后进行清除回收。</p><p>缺点：标记无用对象，然后进行清除回收。</p><p><em><strong>标记复制算法</strong></em></p><p>每次移动存货对象到另一半区，然后清理可回收对象。主要用于回收新生代对象。</p><p>缺点：内存空间使用效率低</p><p><em><strong>标记整理算法</strong></em></p><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><em><strong>分代收集算法</strong></em></p><p>将内存进行切块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用: 复制算法 老年代使用: 标记 - 清除 或者 标记 - 整理 算法。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><em><strong>CMS收集器</strong></em></p><p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</p><p>执行过程：</p><ol><li>初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 </li><li>并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 </li><li>重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 </li><li>并发清除: 不需要停顿。</li></ol><p>缺点：：</p><ol><li>吞吐量低（主要体现在第二阶段）</li><li>无法处理浮动垃圾：浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。</li><li>标记 - 清除算法导致的空间碎片</li></ol><p><em><strong>G1收集器</strong></em></p><p>G1 可以直接对新生代和老年代一起回收。G1基于“标记 - 整理”算法实现。</p><p>G1收集器引入 Region 的概念，通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p>执行过程：</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><ol><li>对象优先在 Eden 分配</li><li>大对象直接进入老年代</li><li>长期存活的对象进入老年代</li><li></li></ol><h3 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h3><p>Minor GC: 发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 </p><p>Full GC: 发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。 </p><p><em><strong>Minor Gc 的触发条件</strong></em></p><p>当 Eden 区的空间耗尽时 Java 虚拟机便会触发一次 Minor GC。</p><p><em><strong>Full Gc的触发条件</strong></em></p><ol><li>调用 System.gc()</li><li>老年代空间不足</li></ol><p><em><strong>减少Full Gc次数的措施</strong></em></p><ol><li>增加方法区的空间; </li><li>增加老年代的空间; </li><li>减少新生代的空间; </li><li>禁止使用System.gc()方法; （会产生STW）</li><li>使用标记-整理算法,尽量保持较大的连续内存空间; </li><li>排查代码中无用的大对象。</li></ol><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka梳理</title>
    <link href="/2021/08/07/tech/middleware/Kafka%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/07/tech/middleware/Kafka%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p><em><strong>一般什么时候用消息队列</strong></em></p><p>消息队列一般主要解决应用耦合、异步消息、流量削锋等问题。</p><p><em><strong>消息队列的通信方式</strong></em></p><p>消息队列（Message Queue）是一种进程间通信或同一进程的不同线程间的通信方式。</p><p><em><strong>消息中间件选型</strong></em></p><table><thead><tr><th align="left">特性</th><th align="left">ActiveMQ</th><th align="left">RabbitMQ</th><th align="left">RocketMQ</th><th align="left">Kafka</th><th align="left">redis/db</th></tr></thead><tbody><tr><td align="left"><strong>单机吞吐量</strong></td><td align="left">万级，吞吐量比RocketMQ和Kafka要低不止一个数量级</td><td align="left">万级，吞吐量比RocketMQ和Kafka要低不止一个数量级</td><td align="left">十万级，RocketMQ也是可以支撑高吞吐的一种MQ</td><td align="left">百万级别，Kafka最大优点就是吞吐量大，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td><td align="left"></td></tr><tr><td align="left"><strong>优势</strong></td><td align="left">非常成熟，功能强大，在业内大量公司和项目中都有应用</td><td align="left">erlang语言开发，性能极好、延时很低，吞吐量万级、MQ功能完备，管理界面非常好，社区活跃；互联网公司使用较多</td><td align="left">接口简单易用，阿里出品有保障，吞吐量大，分布式扩展方便、社区比较活跃，支持大规模的Topic、支持复杂的业务场景，可以基于源码进行定制开发</td><td align="left">超高吞吐量，ms级的时延，极高的可用性和可靠性，分布式扩展方便</td><td align="left"></td></tr><tr><td align="left"><strong>可用性</strong></td><td align="left">高，基于主从架构实现可用性</td><td align="left">高，基于主从架构实现可用性</td><td align="left">非常高，分布式架构</td><td align="left">非常高，Kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td><td align="left"></td></tr><tr><td align="left"><strong>功能支持</strong></td><td align="left">MQ领域的功能及其完备</td><td align="left">基于erlang开发，所以并发性能极强，性能极好，延时低</td><td align="left">MQ功能较为完备，分布式扩展性好</td><td align="left">功能较为简单，主要支持加单MQ功能</td><td align="left"></td></tr><tr><td align="left">支持协议</td><td align="left">STOMP</td><td align="left">AMQP，XMPP, SMTP,STOMP</td><td align="left">基于TCP/IP自定义的协议</td><td align="left">基于TCP/IP自定义的协议</td><td align="left"></td></tr><tr><td align="left"><strong>消息可靠性</strong></td><td align="left">有较低的概率丢失数据</td><td align="left">-</td><td align="left">经过参数优化配置，可以做到零丢失</td><td align="left">经过参数配置，消息可以做到零丢失</td><td align="left"></td></tr><tr><td align="left"><strong>时效性</strong></td><td align="left">ms级</td><td align="left">微秒级，这是rabbitmq的一大特点，延迟是最低的</td><td align="left">ms级</td><td align="left">延迟在ms级以内</td><td align="left"></td></tr><tr><td align="left"><strong>劣势</strong></td><td align="left">偶尔有较低概率丢失消息，社区活跃度不高</td><td align="left">吞吐量较低，erlang语音开发不容易进行定制开发，集群动态扩展麻烦</td><td align="left">接口不是按照标准JMS规范走的，有的系统迁移要修改大量的代码，技术有被抛弃的风险</td><td align="left">有可能进行消息的重复消费</td><td align="left"></td></tr><tr><td align="left"><strong>应用</strong></td><td align="left">主要用于解耦和异步，较少用在大规模吞吐的场景中</td><td align="left">都有使用</td><td align="left">用于大规模吞吐、复杂业务中</td><td align="left">在大数据的实时计算和日志采集中被大规模使用，是业界的标准</td><td align="left"></td></tr><tr><td align="left">开发语言</td><td align="left">java</td><td align="left">Erlang</td><td align="left">java</td><td align="left">Scala/Java</td><td align="left"></td></tr><tr><td align="left"><strong>Topic数量对吞吐量的影响</strong></td><td align="left">-</td><td align="left">-</td><td align="left">Topic可以达到几百、几千个的级别，吞吐量会有小幅度的下降。这是RocketMQ的一大优势，可在同等数量机器下支撑大量的Topic</td><td align="left">Topic从几十个到几百个的时候，吞吐量会大幅下降。所以在同等机器数量下，Kafka尽量保证Topic数量不要过多。如果支撑大规模Topic需要增加更多的机器</td><td align="left"></td></tr></tbody></table><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h2><p><em><strong>Kafka都有哪些特性？</strong></em> </p><table><thead><tr><th>分布式</th><th>高性能</th><th>持久性和扩展性</th></tr></thead><tbody><tr><td>多分区</td><td>高吞吐</td><td>数据可持久化</td></tr><tr><td>多副本</td><td>低延迟</td><td>容错性</td></tr><tr><td>多订阅者</td><td>高并发</td><td>支持水平扩展</td></tr><tr><td>基于ZooKeeper调度</td><td>时间复杂度O(1)</td><td>消息自动平衡</td></tr></tbody></table><p><em><strong>Kafka的使用场景</strong></em></p><ul><li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、HBase、Solr等。</li><li>消息系统：解耦和生产者和消费者、缓存消息等。</li><li>实时计算：比如spark streaming和 Flink等流式处理</li><li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li><li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li></ul><p><em><strong>Kafka为什么速度快？</strong></em></p><ol><li><p>顺序写磁盘</p></li><li><p>使用了零拷贝技术</p></li><li><p>分区机制（以Partition为单元顺序写）</p></li></ol><p><em><strong>ZooKeeper是如何管理Kafka的</strong></em></p><p>Kafka 集群中有一个 broker 会被选举为 Controller，负责管理集群 broker 的上下线，所有topic的分区副本分配和leader选举等工作。 Controller的管理工作都是依赖于 Zookeeper的。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>Kafka是基于发布者-订阅者模式的消息队列组件。</p><p><em><strong>消费者组</strong></em></p><p>Kafka按消费者组来消费消息，每个消息只能被Consumer Group中的一个Consumer消费，不同Consumer可以消费同一消息。</p><p><em><strong>消息状态</strong></em></p><p>在Kafka中，消息是否被消费的状态保存在Consumer中，Broker不会关心消息是否被消费或被谁消费，Consumer会记录一个offset值（指向partition中下一条将要被消费的消息位置），如果offset被错误设置可能导致同一条消息被多次消费或者消息丢失。</p><blockquote><p>如此可能会导致的问题：重复消费，消息丢失。</p></blockquote><p><em><strong>消息持久化</strong></em></p><p>Kafka会把消息持久化到本地文件系统中，并且具有极高的性能。<!--依赖的什么思想得说明一下--></p><p><em><strong>批量发送</strong></em></p><p>Kafka支持以消息集合为单位进行批量发送，以提高效率。</p><p><em><strong>Push &amp; Pull</strong></em></p><p>Kafka采用的是拉模式。</p><p><em><strong>分区机制</strong></em></p><p>Kafka的Broker端支持消息分区，Producer可以决定把消息发到哪个Partition，在一个Partition中消息的顺序就是Producer发送消息的顺序，一个Topic中的Partition数是可配置的，Partition是Kafka高吞吐量的重要保证。</p><p><img src="/img/2021/Kafka%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%AE%80%E5%9B%BE.jpg" alt="Kafka工作流程简图"></p><h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><p><img src="/img/2021/Kafka%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.jpg" alt="Kafka拓扑结构"></p><p><em><strong>Topic &amp; Partition &amp; Offset</strong></em></p><p>Topic在逻辑上可以被认为是一个Queue，Kafka中每条消息都必须指定一个Topic，一个Topic中的消息可以分布在集群中的多个Broker中，Consumer根据订阅的Topic到对应的Broker上去拉取消息。为了提升整个集群的吞吐量，物理上一个Topic可以分成多个Partition，每个Partition在磁盘上对应一个文件夹，该文件夹下存放了这个Partition的所有消息文件和索引文件。假设有topic1和topic2两个Topic，且分别有13个和19个分区，则整个集群会生成32个文件夹。</p><p>“RECORD”部分就是Kafka的消息格式，一条完整的消息包含RECORD、offset以及message size。其中offset用来标识它在Partition中的偏移量，这个offset是逻辑值，而非实际物理偏移值，message size表示消息的大小。</p><blockquote><p>这里要注意，因为Kafka读取消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高Kafka性能无关。</p><p>同时，因为offet由Consumer控制，所以Kafka Broker是无状态的，它不需要标记消息是否被消费过，也不需要通过Broker去保证同一个Consumer Group只有一个Consumer能消费某一条消息，因此也就不需要锁机制，从而保证了Kafka的高吞吐率</p></blockquote><p><img src="/img/2021/%E6%B6%88%E6%81%AF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpg" alt="消息文件格式"></p><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>Producer发送消息到Broker时，会根据Paritition机制选择将消息存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就实现了负载均衡。如果一个Topic对应一个文件，那这个文件所在的机器I/O将会成为这个Topic的性能瓶颈，而有了Partition后，不同的消息可以并行写入不同的Partition中，极大的提高了吞吐率。</p><p>所谓的Partition机制也就是Poducer消息partitioning策略，具体有以下几种策略：</p><p><em><strong>轮询策略</strong></em></p><p>轮询策略是Kafka Java客户端生产者的默认策略，轮询策略的负载均衡表现非常优秀，总能保证消息最大限度地被平均分配到所有分区上，默认情况下它是最合理的分区策略。</p><p><em><strong>随机策略</strong></em></p><p>随机策略默认从Partition列表中随机选择一个。</p><p><em><strong>按消息键保序策略</strong></em></p><p>Kafka允许为每条消息定义消息键，简称为Key（Key可以是一个有明确业务含义的字符串：客户代码、部门编号、业务ID、用来表征消息的元数据等）。一旦消息被定义了Key，可以保证同一个Key的所有消息都进入到相同的分区里，由于每个分区下的消息处理都是顺序的，所以这个策略被称为按消息键保序策略。</p><h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><p>Producer在生产消息的时候就涉及消息发送策略，而涉及到消息消费策略是发生在：1. 同一个Consumer Group内新增消费者；2. 消费者离开当前所属的Group； 3. 订阅的主题新增Partition。</p><p><em><strong>Range策略</strong></em></p><p>对于一个topic，对分区进行排序，然后range平均分配给Consumer Group，余的几个partitions交给前面几个Consumer Group消费。</p><p>这样带来的问题是，如果topic很多，总是前几个Consumer Group 额外消费。</p><p><em><strong>RoundRobin策略</strong></em></p><p>把所有topic的partition排序之后轮询分配给Consumer Group，这样带来的好处是负载均衡。但这种策略要保证两个前提：1. 一个消费者组消费的topic得是相同的；2. 每个topic的实例个数也是相同的</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>Kafka的高可用是说，在一个或多个Broker宕机后，其他Broker及所有Partition都能继续提供服务，且存储的消息不丢失。</p><h3 id="消息备份机制"><a href="#消息备份机制" class="headerlink" title="消息备份机制"></a>消息备份机制</h3><p><em><strong>消息备份</strong></em></p><p>Kafka的一个高可用特性体现在允许Partition存在多个副本（Replica）。</p><p>生产者直接将消息发送给Partition的leader，然后follower周期性地向leader请求同步数据。</p><p>Kafka在分配leader和follower的时候，要让leadr平均分配在不同的broker上，同一个partition的leader和follower不能在同一个broker上。</p><p><img src="/img/2021/Kafka%E6%B6%88%E6%81%AF%E5%A4%87%E4%BB%BD.jpg" alt="Kafka消息备份"></p><p><em><strong>ISR</strong></em></p><p>ISR(In-Sync Replicas)指的是一个Partition中与Leader“保持同步”的Replica列表(实际存储的是副本所在Broker的BrokerId)，这里的保持同步不是指与Leader数据保持完全一致，只需在replica.lag.time.max.ms（默认值为500）时间内与Leader保持有效连接。</p><p><em><strong>Acks</strong></em></p><p>生产者发送消息中包含acks字段，该字段代表Leader应答生产者前Leader收到的应答数。</p><ol><li>ack = 0：生产者无需等待服务端的任何确认，消息被添加到生产者套接字缓冲区后就视为已发送，因此acks=0不能保证服务端已收到消息，使用场景较少；</li><li>ack = 1：Leader将消息写入本地日志后无需等待Follower的消息确认就做出应答。如果Leader在应答消息后立即宕机且其他Follower均未完成消息的复制，则该条消息将丢失；</li><li>ack = all：Leader将等待ISR中的所有副本确认后再做出应答，因此只要ISR中任何一个副本还存活着，这条应答过的消息就不会丢失。acks=all是可用性最高的选择，但等待Follower应答引入了额外的响应时间。Leader需要等待ISR中所有副本做出应答，此时响应时间取决于ISR中最慢的那台机器。</li></ol><p><em><strong>LEO &amp; HW</strong></em></p><p>Kafka Replicas 中有两个重要的概念。</p><p><strong><u>LEO(log end offset)</u></strong> ：即日志末端偏移，指向了副本日志中下一条消息的位移值(即下一条消息的写入位置)</p><p>**<u>HW(high watermark)</u>**，即已同步消息标识，因其类似于木桶效应中短板决定水位高度，故取名高水位线</p><ol><li>消费者仅可消费各分区Leader高水位线以下的消息；</li><li>Leader的HW值由ISR中的所有备份的LEO最小值决定(Follower在发送FetchRequest时会在PartitionFetchInfo中会携带Follower的LEO)</li><li>对于任何一个副本对象而言其HW值不会大于LEO值</li></ol><p><img src="/img/2021/Kafka-HW&LEO.jpg" alt="Kafka-HW&amp;LEO"></p><h3 id="数据一致性的保障"><a href="#数据一致性的保障" class="headerlink" title="数据一致性的保障"></a>数据一致性的保障</h3><p>follower 故障：follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后， follower 会读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重新加入 ISR 了。<br>leader 故障：leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性， 其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader同步数据。<br>注意： 这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p><em><strong>Controller</strong></em></p><p>Kafka需要在集群所有Broker中选出一个Controller负责各Partition的<strong>Leader选举</strong>以及<strong>Replica的重新分配</strong>。</p><p>Kafka使用ZooKeeper存储Broker、Topic等状态数据，Kafka集群中的Controller和Broker会在ZooKeeper指定节点上注册Watcher(事件监听器)，以便在特定事件触发时，由ZooKeeper将事件通知到对应Broker。</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="批量发送消息"><a href="#批量发送消息" class="headerlink" title="批量发送消息"></a>批量发送消息</h3><p><em><strong>Partition</strong></em></p><p>Kafka的消息是一个一个的键值对，键可以设置为默认的null。键有两个用途，可以作为消息的附加信息，也可以用来决定该消息被写入到哪个Partition。</p><p>Kafka通过将Topic划分成多个Partition，Producer将消息分发到多个本地Partition的消息队列中，每个Partition消息队列中的消息会写入到不同的Leader节点。消息经过路由策略，被分发到不同的Partition对应的本地队列，然后再批量发送到Partition对应的Leader节点。</p><p><img src="/img/2021/Kafka%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.jpg" alt="Kafka批量发送消息"></p><p><em><strong>消息路由</strong></em></p><p>Round Robin：Producer将消息均衡地分配到各Partition本地队列上，是最常用的分区策略。</p><p>散列：Kafka对消息的key进行散列，根据散列值将消息路由到特定的Partition上，键相同的消息总是被路由到相同的Partition上。</p><p>自定义分区策略：Kafka支持自定义分区策略，可以将某一系列的消息映射到相同的Partition。</p><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><ol><li>Kafka采用顺序IO读写磁盘；</li><li>通过索引文件提高对磁盘的查询效率；</li></ol><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>数据通过DMA拷贝到内核态Buffer后，直接通过DMA拷贝到NIC Buffer，无需CPU拷贝，这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件-网络发送由一个sendfile调用完成，整个过程只有两次上下文切换，没有cpu数据拷贝，因此大大提高了性能。</p><p>Linux 2.4+内核通过sendfile系统调用，提供了零拷贝。</p><p>Kafka的数据传输通过TransportLayer来完成，其子类PlaintextTransportLayer通过Java NIO的FileChannel的transferTo()和transferFrom()方法实现零拷贝。transferTo()和transferFrom()并不保证一定能使用零拷贝，实际上是否能使用零拷贝与操作系统相关，如果操作系统提供sendfile这样的零拷贝系统调用，则这两个方法会通过这样的系统调用充分利用零拷贝的优势，否则并不能通过这两个方法本身实现零拷贝。</p><p><img src="/img/2021/%E9%9B%B6%E6%8B%B7%E8%B4%9D1.jpg" alt="cpu四次拷贝"></p><p><img src="/img/2021/%E9%9B%B6%E6%8B%B7%E8%B4%9D2.jpg" alt="零拷贝"></p><h2 id="一些常见问题的解决方案"><a href="#一些常见问题的解决方案" class="headerlink" title="一些常见问题的解决方案"></a>一些常见问题的解决方案</h2><h3 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h3><p><em><strong>producer丢消息</strong></em></p><ol><li>在发送过程中发生网络抖动，导致消息没有发送到broker；</li><li>消息本身不合规（消息太大）导致broker拒收。</li></ol><p>解决方案：发送端增加重试机制。</p><p><em><strong>broker丢消息</strong></em></p><ol start="3"><li>follower没来得及完全同步leader的数据，leader下线了，重新选举的follower信息不完全。</li></ol><p>解决方案：</p><ul><li>通过设置，保证每个partition 的副本至少要2个以上；</li><li>通过设置，保证leader至少与一个follower 正确同步数据；</li><li>ack = all，所有副本同步完之后，才认为是写入成功。</li></ul><p><em><strong>consumer丢消息</strong></em></p><ol start="4"><li>consumer自动提交了offset，让broker认为该offset已经被消费，但在处理消息时机器宕机了，导致这条消息没有真正被处理。</li></ol><p>解决方案：关闭自动更新offset，等到数据被处理后再手动跟新offset。</p><h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p>重复消费的原因在于：已经消费了数据，但是offset没来得及提交。</p><ol><li>强行kill线程，导致消费后的数据，offset没有提交（消费系统宕机、重启等）</li><li>设置offset为自动提交，关闭kafka时，如果在close之前，调用 consumer.unsubscribe() 则有可能部分offset没提交，下次重启会重复消费。</li><li>消费后的数据，当offset还没有提交时，partition就断开连接。比如，通常会遇到消费的数据，处理很耗时，导致超过了Kafka的session timeout时间（0.10.x版本默认是30秒），那么就会reblance重平衡，此时有一定几率offset没提交，会导致重平衡后重复消费。</li><li>当消费者重新分配partition的时候，可能出现从头开始消费的情况，导致重发问题。</li><li>当消费者消费的速度很慢的时候，可能在一个session周期内还未完成，导致心跳机制检测报告出问题。</li><li>并发很大，可能在规定的时间（session.time.out默认30s）内没有消费完，就会可能导致reblance重平衡，导致一部分offset自动提交失败，然后重平衡后重复消费</li></ol><p>解决方案：</p><ol><li>提高消费者处理速度，或增加timeout值；</li><li>引入消息去重机制：生产端生产消息时，加入唯一id，消费端保存最近消费记录，消费的时候通过redis查询去重再消费；</li></ol><h3 id="数据积压"><a href="#数据积压" class="headerlink" title="数据积压"></a>数据积压</h3><p>数据积压导致来不及消费怎么办？</p><p>解决方案：</p><ol><li>先修复 consumer的问题,确保其恢复消费速度,然后将现有 consumer都停掉。</li><li>新建一个 topic, partition是原来的10倍,临时建立好原先10倍的 queue数量</li><li>然后写一个临时的分发数据的 consumer程序,这个程序部署上去消费积压的数据,消费之 后不做耗时的处理,直接均匀轮询写入临时建立好的10倍数量的 queue。</li><li>接着临时征用10倍的机器来部署 consumer,每一批 consumer消费一个临时 queue的数 据。这种做法相当于是临时将 queue资源和 consumer资源扩大10倍,以正常的10倍速度 来消费数据。</li><li>等快速消费完积压数据之后,得恢复原先部署的架构,重新用原先的 consumer机器来消费消息。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加密算法梳理</title>
    <link href="/2021/08/05/tech/algorithm/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/05/tech/algorithm/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>对称加密指加密和解密使用同一密钥。</p><p>对称加密过程：采用单秘钥加密，发送方将发送数据分割成固定大小的块，经过秘钥和加密算法加密后发送。接收方收到报文后，结合解密算法使用相同的密钥解密得出原始数据。N个用户需要N*(N-1)/2个不同的密钥。</p><p>优点：效率高，算法简单，系统开销小，适合加密大量数据。</p><p>缺点：安全性差（密钥泄露），扩展性差（通信双方要协商密钥，密钥生成过多不易于管理）。</p><p>常见的对称加密算法：DES、AES、sm4</p><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><p>非对称加密指的是加密和解密使用不同的密钥，一把公开的公钥，一把私有的私钥。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。</p><p>N个用户，需要2N个密钥。</p><p>非对称加密过程：甲使用乙的公钥并结合相应的非对称算法将明文加密发送给乙，乙结合自己的私钥和非对称算法解密得到明文。</p><p>优点：更安全</p><p>缺点：算法复杂度高，加密之后报文冗长，适合对少量数据加密，增加了网络传输成本。</p><p>RSA算法 sm2算法</p><table><thead><tr><th></th><th>SM2</th><th>RSA</th></tr></thead><tbody><tr><td>算法结构</td><td>椭圆曲线</td><td>可逆模幂运算</td></tr><tr><td>计算复杂度</td><td>指数级</td><td>亚指数级</td></tr><tr><td>存储空间</td><td>192-256bit</td><td>2048-4096bit</td></tr><tr><td>秘钥生成速度</td><td>比RSA快百倍以上</td><td>慢</td></tr><tr><td>加解密速度</td><td>较快</td><td>一般</td></tr></tbody></table><h2 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h2><p>单向加密算法只能对数据加密，不能解密。特点为定长输出，雪崩效应（少量消息位的变化会引起信息摘要的许多位的变化）。</p><p>单向加密常用于验证数据完整性、数字摘要、数字签名等。</p><p>加密过程：发送方对明文进行加密发送，接收方对同样的明文进行加密，比对。</p><p>常见的单向加密算法：MD5、sm3</p><h2 id="CA认证"><a href="#CA认证" class="headerlink" title="CA认证"></a>CA认证</h2><!--TODO-->]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis梳理</title>
    <link href="/2021/08/05/tech/middleware/Redis%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/05/tech/middleware/Redis%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis基本数据结构有：String、List、Hash、Set、SortedSet</p><h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>操作复杂度：在SortedSet中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为<strong>logN</strong>。</p><p>SortedSet底层采用字典+跳跃表两种数据结构，来保存有序集元素。字典是通过哈希表来实现的。</p><p><img src="/img/2021/zset%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="zset数据结构"></p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis支持RDB持久化、AOF持久化、RDB-AOF混合持久化这三种持久化方式。</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p><em><strong>概要</strong></em></p><ol><li>RDB持久化是Redis默认的持久化方式；</li><li>工作原理是周期性地以快照的形式将数据持久化到硬盘中；</li><li>通过BGSAVE命令操作。 <!--bgsave怎么用再看一下--></li></ol><p><em><strong>持久化过程</strong></em></p><ol><li><code>bgsave</code>命令让父进程fork一个子进程（进行一个判断，如果父进程已经有了一个子进程就直接返回）；</li><li>父进程fork完了之后处理其他任务，同时，子进程将父进程内存中的数据写到.rdb文件持久化到硬盘中；（os通过CopyOnWrite解决数据更新引发的冲突）</li><li>子进程持久化完了之后，通知父进程更新.rdb文件。</li></ol><p><img src="/img/2021/RDB%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="RDB持久化过程"></p><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p><em><strong>概要</strong></em></p><ol><li>AOF持久化以独立日志的方式，记录每次写入的命令；</li><li>AOF持久化的实时性更好，但存在大量的冗余命令，需要通过重写机制压缩日志，恢复速度慢。</li></ol><p><em><strong>持久化过程</strong></em></p><ol><li>命令写入后，通过append到一个buffer中保证实时性，再同步到一个旧AOF文件中；</li><li>重写过程和RDB持久化过程类似，只是最后父进程写到一个buffer里，同步到一个新AOF文件中；</li><li>最后用新的AOF文件把旧的AOF文件替换掉，重启服务时再把新文件load进来。</li></ol><p><img src="/img/2021/AOF%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="AOF持久化过程"></p><h3 id="RDB-AOF混合持久化"><a href="#RDB-AOF混合持久化" class="headerlink" title="RDB-AOF混合持久化"></a>RDB-AOF混合持久化</h3><p>混合持久化的过程为：在AOF重写时，先执行<code>bgsave</code>生成RDB，再将后处理的命令追加到rdb结尾。</p><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>Redis的主从复制是为了提升分布式系统的可用性和读写性能的。Redis通过SLAVEOF命令或slaveof配置让一个server复制另一个server的数据集和状态。Redis采用异步复制机制。</p><p>主从复制的优点：</p><ol><li>master可以关闭持久化机制，减少IO性能损耗；</li><li>slave能提高读请求处理效率；</li><li>容灾性比较好</li></ol><blockquote><p>主从复制和集群概念上的区别：主从复制是一个master和若干个slave，一个master挂了可以从slave推选新的master，slave可以用提供故障恢复、分担读流量、备份数据；集群是数据量较大时，数据根据key根据哈希计算出slot在多个分片中进行分区（partition），客户端对key的请求会被转发到持有那个key的分片上。分片由一个master和若干个slave组成，他们之间又通过主从复制机制来同步数据。可以理解为集群是主从复制和分区的集合。</p></blockquote><h3 id="主从复制的使用"><a href="#主从复制的使用" class="headerlink" title="主从复制的使用"></a>主从复制的使用</h3><p>主从复制的开启，完全是在 slave 发起的，不需要我们在 master 做任何事情。slave 开启主从复制，有三种方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 配置文件，在从服务器的配置文件中加入：</span><br>slaveof &lt;masterip&gt; &lt;masterport&gt;<br><br><span class="hljs-meta">#</span><span class="bash">启动命令，Redis server 启动命令后加入：</span><br>--slaveof &lt;masterip&gt; &lt;masterport&gt;<br><br><span class="hljs-meta">#</span><span class="bash"> 客户端命令 Redis server 启动后，直接通过客户端执行命令：</span><br>slaveof &lt;masterip&gt; &lt;masterport&gt;，则该 Redis 实例成为 slave。<br></code></pre></td></tr></table></figure><h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3><p>主从复制过程可分为三个阶段：复制初始化、数据同步和命令传播。</p><p><em><strong>初始化阶段</strong></em></p><ol><li>执行完slaveof命令后，slave根据master地址发起socket连接，master收到socket连接之后将连接信息保存，连接建立；</li><li>slave向master发送PING命令，结果如果返回PONG则说明master可用，否则说明master处理其他任务在阻塞中，slave断开连接并重试；</li></ol><p><em><strong>数据同步阶段</strong></em></p><ol><li>master和slave相互确认连接信息后，slave向master发送psync命令；</li><li>主库收到该命令后判断是进行增量同步还是全量同步，然后根据策略进行数据的同步；</li><li>当master有新的写操作时候，此时进入复制第三阶段。</li></ol><p><em><strong>命令传播阶段</strong></em></p><ol><li>数据同步之后，master和slave通过心跳机制检测彼此是否挂了，每隔10smaster向slave发送PING命令判断slave是否在线，slave每隔1s发送replconf ack命令。</li><li>slave发送的命令除了判断master是否在线外，还汇报了自己的复制偏移量，让master根据当前同步情况发布未同步数据的命令。</li></ol><p><em><strong>全量复制</strong></em></p><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。</p><p>发生全量复制的时候，master会在后台启动一个线程，把同步数据生成一份RDB文件，同时将新收到客户端的写命令缓存到内存中，RDB文件生成完之后发送给slave，等slave同步完RDB文件之后，再把写命令发给slave进行同步。过程中如果发生网络故障，会自动重连，master只会复制给slave部分缺少的数据。</p><p><em><strong>增量复制</strong></em></p><p>增量复制发生在正常工作时master发生的写操作同步到slave的过程。增量复制的过程为：master每执行一个写命令就向slave发送相同的写命令，slave接受并执行。</p><h2 id="Redis集群模式"><a href="#Redis集群模式" class="headerlink" title="Redis集群模式"></a>Redis集群模式</h2><h3 id="集群模式原理"><a href="#集群模式原理" class="headerlink" title="集群模式原理"></a>集群模式原理</h3><p>大规模数据存储系统都会面临的一个问题就是如何横向拓展。当你的数据集越来越大，一主多从的模式已经无法支撑这么大量的数据存储，于是你首先考虑将多个主从模式结合在一起对外提供服务。</p><p>Redis采用的是一种去中心化的集群模式。集群通过分片进行数据共享，分片内采用一主多从的形式进行副本复制，并提供复制和故障恢复功能。</p><blockquote><p>主从复制相当于一棵树，集群相当于是一个森林。</p></blockquote><p><em><strong>Redis集群模式原理</strong></em></p><p>以下图为例，一主一从构成一个分片，之间通过异步进行复制，一个机房的master挂掉，会推选另一个机房的slave为master，继续提供服务。每个master负责一部分的slot，客户端通过key做映射取模得到对应的slot，连接到对应的分片，写请求一律走master， 读请求根据路由选择规则找到对应的分片节点。</p><p><img src="/img/2021/Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.jpg" alt="Redis集群模式"></p><h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>跟大多数分布式系统一样，Redis Cluster 的节点间通过持续的 heart beat 来保持信息同步，不过 Redis Cluster 节点信息同步是内部实现的，并不依赖第三方组件如 Zookeeper。集群中的节点持续交换 PING、PONG 数据，消息协议使用 Gossip，这两种数据包的数据结构一样，之间通过 type 字段进行区分。</p><p>Redis通过<strong>哨兵机制</strong>保证高可用。</p><p><em><strong>哨兵机制的工作原理</strong></em></p><ol><li>Redis Sentinel（哨兵）是一个分布式架构，它包含若干个哨兵节点和数据节点。</li><li>每个哨兵节点会对数据节点和其余的哨兵节点进行监控，当发现节点不可达时，会对节点做下线标识。</li><li>如果被标识的是主节点，它就会与其他的哨兵节点进行协商，当多数哨兵节点都认为主节点不可达时，它们便会选举出一个哨兵节点来完成自动故障转移的工作，同时还会将这个变化实时地通知给应用方。</li></ol><p><em><strong>通信过程</strong></em></p><p>Redis集群中的每个节点会定期向其他节点发送PING，如果超过规定时间（node_timeout）没有收到PONG，就会标记为疑似下线状态（PFAIL）。在PING的时候，会广播其他节点当前节点知道的其他节点的信息（包括疑似挂了的节点），当其他节点收到这些疑似挂了的节点之后，会做失效报告（failure report）。如果当前节点已经PFAIL了某个节点，并且大部分节点认为PFAIL的节点PFAIL了，那么当前节点就改PFAIL为FAIL并广播出去。</p><h3 id="故障迁移"><a href="#故障迁移" class="headerlink" title="故障迁移"></a>故障迁移</h3><p>Redis引入了一个<em>epoch</em>的概念。在Redis集群中主要有两种epoch：<em>curentEpoch</em> 和 <em>configEpoch</em>。</p><p><em><strong>currentEpoch</strong></em></p><p>这是一个集群状态相关的概念，可以当做记录集群状态变更的递增版本号。每个集群节点，都会通过 server.cluster-&gt;currentEpoch 记录当前的 currentEpoch。</p><p>集群节点创建时，不管是 master 还是 slave，都置 currentEpoch 为 0。当前节点接收到来自其他节点的包时，如果发送者的 currentEpoch（消息头部会包含发送者的 currentEpoch）大于当前节点的currentEpoch，那么当前节点会更新 currentEpoch 为发送者的 currentEpoch。因此，集群中所有节点的 currentEpoch 最终会达成一致，相当于对集群状态的认知达成了一致。</p><p><em><strong>currentEpoch的作用</strong></em></p><p>currentEpoch 作用在于，当集群的状态发生改变，某个节点为了执行一些动作需要寻求其他节点的同意时，就会增加 currentEpoch 的值。目前 currentEpoch 只用于 slave 的故障转移流程，这就跟哨兵中的sentinel.current_epoch 作用是一模一样的。当 slave A 发现其所属的 master 下线时，就会试图发起故障转移流程。首先就是增加 currentEpoch 的值，这个增加后的 currentEpoch 是所有集群节点中最大的。然后slave A 向所有节点发起拉票请求，请求其他 master 投票给自己，使自己能成为新的 master。其他节点收到包后，发现发送者的 currentEpoch 比自己的 currentEpoch 大，就会更新自己的 currentEpoch，并在尚未投票的情况下，投票给 slave A，表示同意使其成为新的 master。</p><p><em><strong>configEpoch</strong></em></p><p>这是一个集群节点配置相关的概念，每个集群节点都有自己独一无二的 configepoch。所谓的节点配置，实际上是指节点所负责的槽位信息。</p><p> 每一个 master 在向其他节点发送包时，都会附带其 configEpoch 信息，以及一份表示它所负责的 slots 信息。而 slave 向其他节点发送包时，其包中的 configEpoch 和负责槽位信息，是其 master 的 configEpoch 和负责的 slot 信息。节点收到包之后，就会根据包中的 configEpoch 和负责的 slots 信息，记录到相应节点属性中。</p><p><em><strong>configEpoch的作用</strong></em></p><p>configEpoch 主要用于解决不同的节点的配置发生冲突的情况。举个例子就明白了：节点A 宣称负责 slot 1，其向外发送的包中，包含了自己的 configEpoch 和负责的 slots 信息。节点 C 收到 A 发来的包后，发现自己当前没有记录 slot 1 的负责节点（也就是 server.cluster-&gt;slots[1] 为 NULL），就会将 A 置为 slot 1 的负责节点（server.cluster-&gt;slots[1] = A），并记录节点 A 的 configEpoch。后来，节点 C 又收到了 B 发来的包，它也宣称负责 slot 1，此时，如何判断 slot 1 到底由谁负责呢？</p><p>这就是 configEpoch 起作用的时候了，C 在 B 发来的包中，发现它的 configEpoch，要比 A 的大，说明 B 是更新的配置。因此，就将 slot 1 的负责节点设置为 B（server.cluster-&gt;slots[1] = B）。在 slave 发起选举，获得足够多的选票之后，成功当选时，也就是 slave 试图替代其已经下线的旧 master，成为新的 master 时，会增加它自己的 configEpoch，使其成为当前所有集群节点的 configEpoch 中的最大值。这样，该 slave 成为 master 后，就会向所有节点发送广播包，强制其他节点更新相关 slots 的负责节点为自己。</p><blockquote><p>slave在发现从属master下线后，通过增加currentEpoch计数，向其他节点拉起投票，其他节点在currentEpoch更新机制下会投票给slave，从而选举其成为master。</p></blockquote><h2 id="Redis淘汰策略"><a href="#Redis淘汰策略" class="headerlink" title="Redis淘汰策略"></a>Redis淘汰策略</h2><p>当写入数据将导致超出maxmemory限制时，Redis会采用maxmemory-policy所指定的策略进行数据淘汰。</p><p>按照「数据范围」分为volatile淘汰和allkeys淘汰，按照「淘汰算法」分为随机淘汰、LRU淘汰、LFU淘汰。</p><p>LRU：按最近最少使用原则淘汰。（未被淘汰的key可能是不常使用但刚刚使用的key）</p><p>LFU：先按照使用次数淘汰，使用次数相同的key再使用LRU淘汰。（Redis4.0支持）</p><p><img src="/img/2021/Redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.png" alt="Redis淘汰策略"></p><h2 id="Redis过期策略"><a href="#Redis过期策略" class="headerlink" title="Redis过期策略"></a>Redis过期策略</h2><p>Redis支持两种过期策略：定期删除和惰性删除。</p><p><em><strong>定期删除</strong></em></p><p>Redis会将设置了过期时间的key放到一个独立的字典中，并对该字典进行每秒10次的过期扫描。<br>过期扫描不会遍历字典中所有的key，而是采用了一种简单的贪心策略。该策略的删除逻辑如下：</p><ol><li>从过期字典中随机选择20个key；</li><li>删除这20个key中已过期的key；</li><li>如果已过期key的比例超过25%，则重复步骤1。</li></ol><p><em><strong>惰性删除</strong></em></p><p>客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。</p><h3 id="缓存穿透、缓存击穿、缓存雪崩"><a href="#缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩"></a>缓存穿透、缓存击穿、缓存雪崩</h3><p><em><strong>缓存穿透</strong></em></p><p>客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。</p><p>解决方案：</p><ol><li>缓存空对象：存储层未命中后，仍然将空值存入缓存层，客户端再次访问数据时，缓存层会直接返回空值。</li><li>布隆过滤器：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，若请求的数据不存在则直接返回空值。</li></ol><p><em><strong>布隆过滤器</strong></em></p><p>布隆过滤器可以用很低的代价，估算出数据是否真实存在。</p><p>布隆过滤器的核心包括两部分：</p><ol><li>一个大型的位数组；</li><li>若干个不一样的哈希函数，每个哈希函数都能将哈希值算的比较均匀。</li></ol><p>布隆过滤器的工作原理：</p><ol><li>添加key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置，并将位数组中这个位置的值设置为1。</li><li>询问key时，每个哈希函数都利用这个key计算出一个哈希值，再根据哈希值计算一个位置。然后对比这些哈希函数在位数组中对应位置的数值：<ul><li>如果这几个位置中，有一个位置的值是0，就说明这个布隆过滤器中，不存在这个key。</li><li>如果这几个位置中，所有位置的值都是1，就说明这个布隆过滤器中，极有可能存在这个key。之所以不是百分之百确定，是因为也可能是其他的key运算导致该位置为1。</li></ul></li></ol><p><em><strong>缓存击穿</strong></em></p><p>一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。</p><p>解决方案：</p><ol><li>永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。</li><li>加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。</li></ol><p><em><strong>缓存雪崩</strong></em></p><p>在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成<strong>数据库宕机</strong>。可能是<strong>缓存中有大量数据同时过期</strong>，也可能是<strong>Redis节点发生故障</strong>，导致大量请求无法得到处理。</p><p>解决方案：</p><ol><li>避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。</li><li>启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息/空值/错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是直接返回。</li><li>构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。</li></ol><h2 id="Redis性能分析"><a href="#Redis性能分析" class="headerlink" title="Redis性能分析"></a>Redis性能分析</h2><p><em><strong>Redis性能高的原因</strong></em></p><ol><li>Redis是单线程的，可以避免线程切换的性能损耗；</li><li>Redis大部分操作是在内存中完成的；</li><li>Redis采用了IO多路复用机制，使其在IO操作中能并发处理大量的请求，实现高吞吐；</li><li>Redis使用了高效的数据结构（如：在zset中使用跳表）</li><li>Redis是C语言编写的，执行效率高</li></ol><p><em><strong>关于单线程的解释</strong></em></p><p>Redis在键值对操作时，是单线程操作。涉及持久化、异步、集群数据同步等操作时，需要依赖其他线程来执行。Redis的底层其实并不完全是单线程的。</p><p><em><strong>IO多路复用</strong></em> <!-- 留着开一个IO多路复用的专题来写--></p><h2 id="TODO："><a href="#TODO：" class="headerlink" title="TODO："></a>TODO：</h2><ul><li>IO多路复用</li><li>关于跳表结构操作细节的掌握</li><li>redis的API的使用</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>美团实习需求梳理</title>
    <link href="/2021/08/05/tech/project/%E7%BE%8E%E5%9B%A2%E5%AE%9E%E4%B9%A0%E9%9C%80%E6%B1%82%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/05/tech/project/%E7%BE%8E%E5%9B%A2%E5%AE%9E%E4%B9%A0%E9%9C%80%E6%B1%82%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="充电宝微信客诉"><a href="#充电宝微信客诉" class="headerlink" title="充电宝微信客诉"></a>充电宝微信客诉</h1><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>用户在使用充电宝业务时，通过微信发起诉讼，微信侧要求美团侧在24小时内进行回复响应，否则默认给用户退款。美团侧客诉服务之前都是通过太平洋系统调取微信侧工单线下回访解决客诉问题的，此方案大量消耗人工资源，此需求核心价值在于为及时响应微信侧请求，减少经济损失，形成线上自动化的回复处理。</p><h2 id="产品方案"><a href="#产品方案" class="headerlink" title="产品方案"></a>产品方案</h2><p>由于需求紧急，产品方案排了两期。一期方案为网管侧直接对微信侧做同步响应，回复消息写死。<!-- 二期方案后续补上 --></p><p><img src="/img/2021/%E5%BE%AE%E4%BF%A1%E5%AE%A2%E8%AF%89%E4%B8%80%E6%9C%9F%E4%BA%A7%E5%93%81%E6%96%B9%E6%A1%88.jpg" alt="微信客诉一期产品方案"></p><p><img src="/img/2021/%E5%BE%AE%E4%BF%A1%E5%AE%A2%E8%AF%89%E4%BA%8C%E6%9C%9F%E4%BA%A7%E5%93%81%E6%96%B9%E6%A1%88.jpg" alt="微信客诉二期产品方案"></p><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><h3 id="一期技术方案"><a href="#一期技术方案" class="headerlink" title="一期技术方案"></a>一期技术方案</h3><p>首先，要创建回调地址，在上线前告诉微信侧请求美团网关侧的回调地址。</p><p>其次，要写一个controller，实现微信侧「通知回调」接口，处理微信侧的回调请求。</p><p>在这个处理controller里，要实现微信侧提供的「提交回复」接口。</p><!--微信客诉一期技术方案图重新画 --><h3 id="一期技术实现"><a href="#一期技术实现" class="headerlink" title="一期技术实现"></a>一期技术实现</h3><h4 id="创建回调地址"><a href="#创建回调地址" class="headerlink" title="创建回调地址"></a>创建回调地址</h4><p><a href="https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter10_2_2.shtml">参考文档</a></p><p>在当时我的实现思路是，在controller新增了一个创建回调地址的方法，然后拿postman去请求这个controller，然后利用这个controller请求微信侧的「创建回调地址」接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/newCallbackUrl&quot;, method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">newCallbackUrl</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    String requestUrl = <span class="hljs-string">&quot;https://api.mch.weixin.qq.com/v3/merchant-service/complaint-notifications&quot;</span>;<br>    String callbackUrl = <span class="hljs-string">&quot;https://paygate-staging-yf.pay.st.meituan.com/paygate/notify/complaint/app&quot;</span>;<br>    Short payType = PayType.PAY_TYPE_WXPAYSCORE_APP; <br>    WxConfig wxConfig = WxConfig.wxConfigMap.get(payType + <span class="hljs-string">&quot;&quot;</span>); <br>    <br>    Map&lt;String, String&gt; requestMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    requestMap.put(<span class="hljs-string">&quot;url&quot;</span>, callbackUrl);<br>    String requestMsg = JSON.toJSONString(requestMap);<br>    <span class="hljs-keyword">long</span> timestamp = WxPayUtil.getCurrentTimestamp();<br>    String nonce = WxPayUtil.generateNonceStr();<br>    String signature = SignUtil.signRSA(requestMsg, HttpRequestTypeEnum.POST, requestUrl, timestamp, nonce, wxConfig.getPrivateKey());<br>    HttpResponseModel responseModel = HttpUtils.httpPost(requestUrl, requestMsg, wxConfig.getPlatformCertificateNo(), WxPayScoreServiceImpl.getAuthorization(wxConfig, signature, timestamp, nonce), <span class="hljs-keyword">new</span> HashMap&lt;&gt;(), <span class="hljs-keyword">null</span>);<br>    <br>    Map&lt;String, String&gt; header = responseModel.getHttpHeader();<br>    String ret = JSON.toJSONString(header);<br>    String responseData = responseModel.getResponseData();<br>    ret += (<span class="hljs-string">&quot;\n&quot;</span> + responseData);<br>    System.out.println(responseData);<br>    response.setStatus(<span class="hljs-number">200</span>);<br>    response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>    response.getWriter().write(responseData);<br>    response.getWriter().flush();<br>    response.getWriter().close();<br>    <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="业务线处理函数"><a href="#业务线处理函数" class="headerlink" title="业务线处理函数"></a>业务线处理函数</h4><p>微信提供了若干种支付方式：JSAPI、APP、H5、Native、小程序等。由于充电宝业务只接入了Native和小程序两个接口。所以在处理的时候，要分别进行响应处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/app/complaint&quot;, method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">app</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    response.setStatus(<span class="hljs-number">500</span>);<br>    Short payType = PayType.PAY_TYPE_WXPAYSCORE_APP;<br>    doProcess(payType, request, response);<span class="hljs-comment">//APP</span><br>&#125;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/applets/complaint&quot;, method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applets</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    response.setStatus(<span class="hljs-number">500</span>);<br>    Short payType = PayType.PAY_TYPE_WXPAYSCORE_APPLETS;<br>    doProcess(payType, request, response);<span class="hljs-comment">//小程序</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="处理函数"><a href="#处理函数" class="headerlink" title="处理函数"></a>处理函数</h4><p>整个处理部分包含了三个部分：</p><ol><li>加签</li><li>响应回调请求</li><li>调用回复接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doProcess</span><span class="hljs-params">(Short payType, HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    WxConfig wxConfig = WxConfig.wxConfigMap.get(payType + <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        String reqContext = WxUtil.parseReqByte(request);<br>        Map&lt;String, Object&gt; reqMap = <span class="hljs-keyword">new</span> Gson().fromJson(reqContext, HashMap.class);<br>        log.info(<span class="hljs-string">&quot;WxPayComplaint request payType:&#123;&#125;, data:&#123;&#125;&quot;</span>, payType, reqMap);<br>        <span class="hljs-keyword">if</span> (reqMap == <span class="hljs-keyword">null</span> || reqMap.size() &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        Map&lt;String, String&gt; reqWxResource = (Map&lt;String, String&gt;) reqMap.get(<span class="hljs-string">&quot;resource&quot;</span>);<br>        String notifyContext = WxPayUtil.decryptToString(wxConfig.getApiKey(), String.valueOf(reqWxResource.get(<span class="hljs-string">&quot;associated_data&quot;</span>)),<br>                String.valueOf(reqWxResource.get(<span class="hljs-string">&quot;nonce&quot;</span>)), String.valueOf(reqWxResource.get(<span class="hljs-string">&quot;ciphertext&quot;</span>)));<br>        Map&lt;String, String&gt; notifyContextMap = WxUtil.jsonStrToMap(notifyContext);<br>        String msgId = String.valueOf(reqMap.get(<span class="hljs-string">&quot;id&quot;</span>));<br>        String complaintID = notifyContextMap.get(<span class="hljs-string">&quot;complaint_id&quot;</span>);<br>        String complainedMchId = wxConfig.getMchId();<br>        String actionType = notifyContextMap.get(<span class="hljs-string">&quot;action_type&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;msgId:&#123;&#125;,complaintId:&#123;&#125;,actionType:&#123;&#125;&quot;</span>, msgId, complaintID, actionType);<br>        <br>        response.setStatus(<span class="hljs-number">200</span>);<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>, <span class="hljs-string">&quot;No-cache&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);<br>        response.setDateHeader(<span class="hljs-string">&quot;Expires&quot;</span>, <span class="hljs-number">0</span>);<br>        Map&lt;String, String&gt; responseMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        responseMap.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;SUCCESS&quot;</span>);<br>        responseMap.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;成功&quot;</span>);<br>        response.getWriter().write(<span class="hljs-keyword">new</span> Gson().toJson(responseMap));<br>        response.getWriter().flush();<br>        response.getWriter().close();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;CREATE_COMPLAINT&quot;</span>.equals(actionType) || <span class="hljs-string">&quot;CONTINUE_COMPLAINT&quot;</span>.equals(actionType)) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>                <span class="hljs-keyword">if</span> (submitResponse(complaintID, complainedMchId, wxConfig)) <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;wxComplaint response notify error: &#123;&#125;&quot;</span>, ExceptionUtils.getStackTrace(e));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="回复接口实现"><a href="#回复接口实现" class="headerlink" title="回复接口实现"></a>回复接口实现</h4><p><a href="https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter10_2_14.shtml">参考文档</a></p><p>根据微信侧提供的接口文档，必传参数包括商户id和回复内容，这里的商户id是从微信侧回调报文中获取的，回复内容是写死的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">submitResponse</span><span class="hljs-params">(String complaintID, String complainedMchid, WxConfig wxConfig)</span> <span class="hljs-keyword">throws</span> SendException </span>&#123;<br>    String responseContent = <span class="hljs-string">&quot;您的反馈已经收到，我们将尽快联系您处理。&quot;</span>;<br>    String suffixUrl = String.format(WxConstants.COMPLAINTS_RESPONSE_URI_SUFFIX, complaintID);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">long</span> timestamp = WxPayUtil.getCurrentTimestamp();<br>        Map&lt;String, String&gt; requestMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        requestMap.put(<span class="hljs-string">&quot;complainted_mchid&quot;</span>, complainedMchid);<br>        requestMap.put(<span class="hljs-string">&quot;response_content&quot;</span>, responseContent);<br>        String requestMsg = <span class="hljs-keyword">new</span> Gson().toJson(requestMap);<br>        String nonce = WxPayUtil.generateNonceStr();<br>        String signature = SignUtil.signRSA(requestMsg, HttpRequestTypeEnum.POST, suffixUrl, timestamp, nonce, wxConfig.getPrivateKey());<br>        <span class="hljs-comment">// 打印 发送的报文</span><br>        HttpResponseModel responseModel = HttpUtils.httpPost(WxPayUtil.url + suffixUrl, requestMsg, wxConfig.getPlatformCertificateNo(),<br>                WxPayScoreServiceImpl.getAuthorization(wxConfig, signature, timestamp, nonce), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (responseModel != <span class="hljs-keyword">null</span> &amp;&amp; responseModel.getHttpStatusCode() == <span class="hljs-number">204</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;submitResponse success&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;submitResponse error&quot;</span>);<br>            <span class="hljs-keyword">if</span> (responseModel != <span class="hljs-keyword">null</span>) &#123;<br>                log.info(<span class="hljs-string">&quot;submitResponse return: \n httpStatusCode:&#123;&#125;, httpHeader: &#123;&#125;, responseData: &#123;&#125;&quot;</span>,<br>                        responseModel.getHttpStatusCode(), <span class="hljs-keyword">new</span> Gson().toJson(responseModel.getHttpHeader()), responseModel.getResponseData());<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;submit response error:&#123;&#125;&quot;</span>, ExceptionUtils.getStackTrace(e));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="签名方式"><a href="#签名方式" class="headerlink" title="签名方式"></a>签名方式</h3><p>微信侧约定的签名方式是RSA加密。</p><p>整个给微信侧签名过程是怎样的？<br>参考：<a href="https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_0.shtml">签名方案</a>、<a href="https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_0.shtml">验签方案</a></p><h1 id="单车接入支付宝代扣"><a href="#单车接入支付宝代扣" class="headerlink" title="单车接入支付宝代扣"></a>单车接入支付宝代扣</h1><h2 id="项目背景-1"><a href="#项目背景-1" class="headerlink" title="项目背景"></a>项目背景</h2><p>微信侧要下线单车场景自动续费做产品升级，考虑到用户量较大，美团临时新增支付宝代扣功能。</p><h2 id="产品方案-1"><a href="#产品方案-1" class="headerlink" title="产品方案"></a>产品方案</h2><p>之前美团已经将打车业务接入到支付宝代扣能力建设中，根据和支付宝侧沟通，单车场景接入只需要在签约接口新增子商户字段，此行为不影响其他支付退款接口。</p><p><img src="/img/2021/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BB%A3%E6%89%A3%E7%AD%BE%E7%BA%A6%E6%B5%81%E7%A8%8B%EF%BC%88%E5%85%A8%E9%93%BE%E8%B7%AF%EF%BC%89.jpg" alt="支付宝代扣签约流程（全链路）"></p><h2 id="技术方案-1"><a href="#技术方案-1" class="headerlink" title="技术方案"></a>技术方案</h2><p>通过thrift文件声明一个子商户对象，其中包含若干字段。通过thrift文件生成工具导出为java文件，给上游提供SDK。</p><p>在开发过程中，涉及签约接口的部分，要将新添加的字段封装到reqMap中，为请求下游数据封装做铺垫。</p><h3 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h3><h4 id="为什么要用RPC框架？"><a href="#为什么要用RPC框架？" class="headerlink" title="为什么要用RPC框架？"></a>为什么要用RPC框架？</h4><p>对于RPC的解释：</p><blockquote><p>RPC为远程调用服务，调用远端的服务的就像直接在本地调用，本质上来说是一种c/s服务。</p></blockquote><p>在c/s架构服务中，分布式系统采用http通信和采用RPC框架通信的对比分析：</p><ol><li>从网络资源消耗角度来说，如果业务量庞大，需要反复握手，会有额外的网络开销，RPC框架可以选择合适的通信协议，减少网络开销；</li><li>从代码开发角度来说，网络通信代码相对冗余，RPC可以类似本地调用一样，写起来简单方便；</li><li>RPC框架一般会有服务注册中心模块，通过该模块，可以实现服务的负载和故障迁移。</li></ol><h4 id="thrift的优势有哪些？"><a href="#thrift的优势有哪些？" class="headerlink" title="thrift的优势有哪些？"></a>thrift的优势有哪些？</h4><ol><li>提供了多种数据序列化方式,常用的binary、json数据序列化格式；</li><li>支持代码自动生成:可以根据thrift文件定义协议,然后自动生成客户端代码；</li><li>支持跨语言调用，公司内部使用多种语言，如java、php等，RPC框架可以考虑使用thrift。</li></ol><h1 id="DCEP"><a href="#DCEP" class="headerlink" title="DCEP"></a>DCEP</h1><h2 id="接口组织结构"><a href="#接口组织结构" class="headerlink" title="接口组织结构"></a>接口组织结构</h2><h3 id="基础服务接口"><a href="#基础服务接口" class="headerlink" title="基础服务接口"></a>基础服务接口</h3><p>基础服务接口包含支付、支付查询、退款、退款查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.meituan.pay.paygw.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IBaseService</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">pay</span><span class="hljs-params">(Map&lt;String, String&gt; reqMap)</span></span>;<br>    <br>    <span class="hljs-function">String <span class="hljs-title">payQuery</span><span class="hljs-params">(Map&lt;String, String&gt; reqMap)</span></span>;<br>    <br>    <span class="hljs-function">String <span class="hljs-title">refund</span><span class="hljs-params">(Map&lt;String, String&gt; reqMap)</span></span>;<br>    <br>    <span class="hljs-function">String <span class="hljs-title">refundQuery</span><span class="hljs-params">(Map&lt;String, String&gt; reqMap)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dcep通道当前扩展的子接口"><a href="#dcep通道当前扩展的子接口" class="headerlink" title="dcep通道当前扩展的子接口"></a>dcep通道当前扩展的子接口</h3><p>dcep扩展的子接口有：开通白名单、发红包、钱包开立状态查询、发红包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.meituan.pay.paygw.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAllowListService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IBaseService</span></span>&#123;<br>    <br>    <span class="hljs-function">AllowListRespVo <span class="hljs-title">supportAllowList</span><span class="hljs-params">(AllowListReqVo allowListReqVo, AllowListRespVo allowListRespVo)</span></span>;<br>    <br>    <span class="hljs-function">RedPctRespVo <span class="hljs-title">supportRedPct</span><span class="hljs-params">(RedPctReqVo redPctReqVo, RedPctRespVo respVo)</span></span>;<br>    <br>    <span class="hljs-function">WalletStateQueryRespVo <span class="hljs-title">walletStateQuery</span><span class="hljs-params">(WalletStateQueryReqVo walletStateQueryReqVo, WalletStateQueryRespVo respVo)</span></span>;<br>    <br>    <span class="hljs-function">RedPctQueryRespVo <span class="hljs-title">redPctQuery</span><span class="hljs-params">(RedPctQueryReqVo redPctQueryReqVo, RedPctQueryRespVo respVo)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="具体开发流程"><a href="#具体开发流程" class="headerlink" title="具体开发流程"></a>具体开发流程</h2><p>接口具体实现方法主要有三个步骤：</p><ol><li>组装上游参数</li><li>给下游发送请求并解析响应</li><li>构建响应信息返回给上游</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs java">  <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建红包余额返回参数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> respStr</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> respVo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> payType</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RedPctQueryRespVo <span class="hljs-title">buildRedPctQueryRes</span><span class="hljs-params">(String respStr, RedPctQueryRespVo respVo, String payType)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TokenRedPctQueryResp resp = dcepPsbcConfig.parsePsbcCommonRtn(respStr, TokenRedPctQueryResp.class, payType);<br>        <span class="hljs-keyword">if</span> (resp == <span class="hljs-keyword">null</span> || resp.getHead() == <span class="hljs-keyword">null</span> || resp.getBody() ==<span class="hljs-keyword">null</span>)  &#123;<br>            log.error(<span class="hljs-string">&quot;buildRedPctQueryRes error resp is null&quot;</span>);<br>            respVo.response.setErrorCode(ErrorCodeConfig.PAYGATE_COMMON_ERR);<br>            <span class="hljs-keyword">return</span> respVo;<br>        &#125;<br>        logHandler.logBankInter(<span class="hljs-string">&quot;dcep psbc buildRedPctQueryRes response:&quot;</span> + JacksonUtil.toJson(resp));<br>        <br>        String respCode = resp.getBody().getRespCode();<br>        String respMsg = resp.getBody().getRespMsg();<br>        String outNo = resp.getBody().getBusiMainId();<br>        <span class="hljs-keyword">if</span> (BANK_RESP_OK.equalsIgnoreCase(respCode)) &#123;<br>            respVo.setOutNo(outNo);<br>            List&lt;PsbcRedPctActInfo&gt; redPctActInfoList = resp.getBody().getRedpctActInfoList();<br>            List&lt;Object&gt; objectList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (PsbcRedPctActInfo item : redPctActInfoList) &#123;<br>                RedPctActInfo redPctActInfo = <span class="hljs-keyword">new</span> RedPctActInfo();<br>                redPctActInfo.setRedPctActNo(item.getRedpctActNo());<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;#.##&quot;</span>.equals(item.getRedpctActBal()) &amp;&amp; StringUtils.isNotBlank(item.getRedpctActBal())) &#123;<br>                    redPctActInfo.setRedPctActBal(AmountUtils.y2fLong(item.getRedpctActBal()) + <span class="hljs-string">&quot;&quot;</span>);<br>                &#125;<br>                redPctActInfo.setRedPctActCode(item.getRedpctActCode());<br>                redPctActInfo.setRedPctActMsg(item.getRedpctActMsg());<br>                objectList.add(redPctActInfo);<br>            &#125;<br>            List&lt;RedPctActInfo&gt; redpctActInfoList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (Object item: objectList) &#123;<br>                redpctActInfoList.add((RedPctActInfo) item);<br>            &#125;<br>            respVo.setRedPctActInfoList(redpctActInfoList);<br>            respVo.response.setSuccess(<span class="hljs-keyword">true</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            respVo.response.setSuccess(<span class="hljs-keyword">false</span>);<br>            String gwRtnCode = <span class="hljs-keyword">this</span>.bankCodeToGwRtnCode(respCode, RedPctQueryRespVo.class);<br>            respVo.response.setErrorCode(gwRtnCode);<br>            respVo.response.setErrorMsg(respMsg);<br>            respVo.response.setThirdErrorCode(respCode);<br>            respVo.response.setThirdErrorMsg(respMsg);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;buildRedPctQueryRes error: &#123;&#125;&quot;</span>, ExceptionUtils.getStackTrace(e));<br>        respVo.response.setErrorCode(ErrorCodeConfig.PAYGATE_COMMON_ERR);<br>    &#125;<br>    <span class="hljs-keyword">return</span> respVo;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 构建红包余额请求参数</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">* <span class="hljs-doctag">@throws</span> PreSendException</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, String&gt; <span class="hljs-title">buildRedPctQueryParams</span><span class="hljs-params">(RedPctQueryReqVo redPctQueryReqVo)</span> <span class="hljs-keyword">throws</span> PreSendException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 组装参数</span><br>        TokenRedPctQueryReq req = <span class="hljs-keyword">new</span> TokenRedPctQueryReq();<br>        TokenRedPctQueryReq.Head head = req.<span class="hljs-function">new <span class="hljs-title">Head</span><span class="hljs-params">()</span></span>;<br>        head.setPartnerTxSriNo(fmt.format(<span class="hljs-keyword">new</span> Date())+LeafIdGenUtil.getIdByDigit(Config.LEAF_ID,<span class="hljs-number">10</span>));<br>        head.setMethod(dcepPsbcConfig.RED_PCT_QUERY_METHOD);<br>        head.setVersion(dcepPsbcConfig.VERSION);<br>        head.setMerchantId(MtConfigUtils.getMccVal(dcepPsbcConfig.MERCHANT_ID));<br>        head.setAppID(MtConfigUtils.getMccVal(dcepPsbcConfig.APP_ID));<br>        head.setReqTime(fmt.format(<span class="hljs-keyword">new</span> Date()));<br>        head.setAccessType(dcepPsbcConfig.ACCESS_TYPE);<br>        head.setReserve(<span class="hljs-string">&quot;&quot;</span>);<br>        req.setHead(head);<br><br>        TokenRedPctQueryReq.Body body = req.n<span class="hljs-function">ew <span class="hljs-title">Body</span><span class="hljs-params">()</span></span>;<br>        body.setBusiMainId(redPctQueryReqVo.getOutNo());<br>        body.setReqTransTime(fmt.format(<span class="hljs-keyword">new</span> Date()));<br>        body.setPhone(redPctQueryReqVo.getUserCellphone());<br>        List&lt;RedPctActInfo&gt; redPctActInfoList = redPctQueryReqVo.getRedPctActInfoList();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == redPctActInfoList || redPctActInfoList.isEmpty() || StringUtils.isBlank(redPctActInfoList.get(<span class="hljs-number">0</span>).getRedPctActNo())) &#123;<br>            log.error(<span class="hljs-string">&quot;RedPctActNo can&#x27;t be empty&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PreSendException(ErrorCodeConfig.ILLEGAL_ARGUMENT);<br>        &#125;<br>        List&lt;String&gt; redpctActList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (RedPctActInfo item: redPctActInfoList) &#123;<br>            redpctActList.add(item.getRedPctActNo());<br>        &#125;<br>        body.setRedpctActList(redpctActList);<br>        body.setWltId(MtConfigUtils.getMccVal(DcepPsbcConfig.WltId));<br>        req.setBody(body);<br><br>        <span class="hljs-keyword">return</span> dcepPsbcConfig.assemblePsbcCommonReq(req, redPctQueryReqVo.getPayType()+<span class="hljs-string">&quot;&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (PreSendException e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;buildWalletStateQueryParams error :&#123;&#125;&quot;</span>, ExceptionUtils.getStackTrace(e));<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PreSendException(ErrorCodeConfig.ILLEGAL_ARGUMENT);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">doPostWithContentType</span><span class="hljs-params">(String urlStr, String reqContent, <span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> socketTimeout, String encoding)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    StringBuilder resStr = <span class="hljs-keyword">new</span> StringBuilder();<br>    BufferedReader in = <span class="hljs-keyword">null</span>;<br>    HttpURLConnection connection = <span class="hljs-keyword">null</span>;<br>    HttpsURLConnection connections = <span class="hljs-keyword">null</span>;<br>    OutputStream out = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> isOnline = CommonConfig.isOnline();<br><br>    <span class="hljs-comment">//设置信任所有站点证书</span><br>    trustAllHosts();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        URL url = <span class="hljs-keyword">new</span> URL(urlStr);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;https&quot;</span>.equals(urlStr.substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)))&#123;<br>            <span class="hljs-comment">//https</span><br>            connections = (HttpsURLConnection) url.openConnection();<br>            connections.setConnectTimeout(connectTimeout);<br>            connections.setReadTimeout(socketTimeout);<br>            connections.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>            connections.setDoOutput(<span class="hljs-keyword">true</span>);<br>            connections.setRequestProperty(<span class="hljs-string">&quot;accept&quot;</span>, <span class="hljs-string">&quot;*/*&quot;</span>);<br>            connections.setRequestProperty(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>            connections.setRequestProperty(<span class="hljs-string">&quot;Content-Length&quot;</span>, reqContent.length()+<span class="hljs-string">&quot;&quot;</span>);<br>            <span class="hljs-comment">//服务端站点证书与域名不匹配时需要设置不校验域名</span><br>            connections.setHostnameVerifier(<span class="hljs-keyword">new</span> MyHostnameVerifier());<br><br>            logger.info(<span class="hljs-string">&quot;https connecting...&quot;</span>);<br>            connections.connect();<br>            logger.info(<span class="hljs-string">&quot;https connected!&quot;</span>);<br><br>            out = connections.getOutputStream();<br>            out.write(reqContent.getBytes(encoding));<br><br>            String httpCode = Integer.toString(connections.getResponseCode());<br>            logger.info(<span class="hljs-string">&quot;httpCode:&#123;&#125;&quot;</span>,httpCode);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;200&quot;</span>.equals(httpCode)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;HTTPS通信失败:&quot;</span> + httpCode);<br>            &#125;<br>            <span class="hljs-comment">//</span><br>            in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(connections.getInputStream(), encoding));<br>            String line;<br>            <span class="hljs-keyword">while</span>((line = in.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                resStr.append(line).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//http</span><br>            connection = (HttpURLConnection) url.openConnection();<br>            connection.setConnectTimeout(connectTimeout);<br>            connection.setReadTimeout(socketTimeout);<br>            connection.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>            connection.setDoOutput(<span class="hljs-keyword">true</span>);<br>            connection.setRequestProperty(<span class="hljs-string">&quot;accept&quot;</span>, <span class="hljs-string">&quot;*/*&quot;</span>);<br>            connection.setRequestProperty(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>            connection.setRequestProperty(<span class="hljs-string">&quot;Content-Length&quot;</span>, reqContent.length()+<span class="hljs-string">&quot;&quot;</span>);<br><br>            logger.info(<span class="hljs-string">&quot;http connecting...&quot;</span>);<br>            connection.connect();<br>            logger.info(<span class="hljs-string">&quot;http connected!&quot;</span>);<br><br>            out = connection.getOutputStream();<br>            out.write(reqContent.getBytes(encoding));<br><br>            String httpCode = Integer.toString(connection.getResponseCode());<br>            logger.info(<span class="hljs-string">&quot;httpCode:&#123;&#125;&quot;</span>,httpCode);<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;200&quot;</span>.equals(httpCode)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;HTTP通信失败:&quot;</span> + httpCode);<br>            &#125;<br>            <span class="hljs-comment">//</span><br>            in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(connection.getInputStream(), encoding));<br>            String line;<br>            <span class="hljs-keyword">while</span>((line = in.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                resStr.append(line).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(out != <span class="hljs-keyword">null</span>) &#123;<br>                out.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(connection != <span class="hljs-keyword">null</span>) &#123;<br>                connection.disconnect();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(connections != <span class="hljs-keyword">null</span>) &#123;<br>                connections.disconnect();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(in != <span class="hljs-keyword">null</span>) &#123;<br>                in.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            out = <span class="hljs-keyword">null</span>;<br>            in = <span class="hljs-keyword">null</span>;<br>            connection = <span class="hljs-keyword">null</span>;<br>            logger.error(<span class="hljs-string">&quot;exception while sendByHttps/Http:&quot;</span> + e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resStr.toString();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 构建红包余额返回参数</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> respStr</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> respVo</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> payType</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RedPctQueryRespVo <span class="hljs-title">buildRedPctQueryRes</span><span class="hljs-params">(String respStr, RedPctQueryRespVo respVo, String payType)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        TokenRedPctQueryResp resp = dcepPsbcConfig.parsePsbcCommonRtn(respStr, TokenRedPctQueryResp.class, payType);<br>        <span class="hljs-keyword">if</span> (resp == <span class="hljs-keyword">null</span> || resp.getHead() == <span class="hljs-keyword">null</span> || resp.getBody() ==<span class="hljs-keyword">null</span>)  &#123;<br>            log.error(<span class="hljs-string">&quot;buildRedPctQueryRes error resp is null&quot;</span>);<br>            respVo.response.setErrorCode(ErrorCodeConfig.PAYGATE_COMMON_ERR);<br>            <span class="hljs-keyword">return</span> respVo;<br>        &#125;<br>        logHandler.logBankInter(<span class="hljs-string">&quot;dcep psbc buildRedPctQueryRes response:&quot;</span> + JacksonUtil.toJson(resp));<br><br>        String respCode = resp.getBody().getRespCode();<br>        String respMsg = resp.getBody().getRespMsg();<br>        String outNo = resp.getBody().getBusiMainId();<br>        <span class="hljs-keyword">if</span> (BANK_RESP_OK.equalsIgnoreCase(respCode)) &#123;<br>            respVo.setOutNo(outNo);<br>            List&lt;PsbcRedPctActInfo&gt; redPctActInfoList = resp.getBody().getRedpctActInfoList();<br>            List&lt;Object&gt; objectList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (PsbcRedPctActInfo item : redPctActInfoList) &#123;<br>                RedPctActInfo redPctActInfo = <span class="hljs-keyword">new</span> RedPctActInfo();<br>                redPctActInfo.setRedPctActNo(item.getRedpctActNo());<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;#.##&quot;</span>.equals(item.getRedpctActBal()) &amp;&amp; StringUtils.isNotBlank(item.getRedpctActBal())) &#123;<br>                    redPctActInfo.setRedPctActBal(AmountUtils.y2fLong(item.getRedpctActBal()) + <span class="hljs-string">&quot;&quot;</span>);<br>                &#125;<br>                redPctActInfo.setRedPctActCode(item.getRedpctActCode());<br>                redPctActInfo.setRedPctActMsg(item.getRedpctActMsg());<br>                objectList.add(redPctActInfo);<br>            &#125;<br>            List&lt;RedPctActInfo&gt; redpctActInfoList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (Object item: objectList) &#123;<br>                redpctActInfoList.add((RedPctActInfo) item);<br>            &#125;<br>            respVo.setRedPctActInfoList(redpctActInfoList);<br>            respVo.response.setSuccess(<span class="hljs-keyword">true</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            respVo.response.setSuccess(<span class="hljs-keyword">false</span>);<br>            String gwRtnCode = <span class="hljs-keyword">this</span>.bankCodeToGwRtnCode(respCode, RedPctQueryRespVo.class);<br>            respVo.response.setErrorCode(gwRtnCode);<br>            respVo.response.setErrorMsg(respMsg);<br>            respVo.response.setThirdErrorCode(respCode);<br>            respVo.response.setThirdErrorMsg(respMsg);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;buildRedPctQueryRes error: &#123;&#125;&quot;</span>, ExceptionUtils.getStackTrace(e));<br>        respVo.response.setErrorCode(ErrorCodeConfig.PAYGATE_COMMON_ERR);<br>    &#125;<br>    <span class="hljs-keyword">return</span> respVo;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="DCEP全链路梳理"><a href="#DCEP全链路梳理" class="headerlink" title="DCEP全链路梳理"></a>DCEP全链路梳理</h2><h3 id="网关接口调用关系"><a href="#网关接口调用关系" class="headerlink" title="网关接口调用关系"></a>网关接口调用关系</h3><p><img src="/img/2021/dcep%E7%BB%91%E5%AE%9A%E8%A7%A3%E7%BB%91%E6%B5%81%E7%A8%8B.jpg" alt="dcep绑定解绑流程"></p><p><img src="/img/2021/dcep%E6%94%AF%E4%BB%98%E9%80%80%E6%AC%BE%E6%B5%81%E7%A8%8B.jpg" alt="dcep支付退款流程"></p><p><img src="/img/2021/dcep%E8%B4%A6%E5%8D%95%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="dcep账单处理流程"></p><h1 id="网关新平台建设"><a href="#网关新平台建设" class="headerlink" title="网关新平台建设"></a>网关新平台建设</h1><h2 id="需求点"><a href="#需求点" class="headerlink" title="需求点"></a>需求点</h2><ol><li>工具类：JSON格式校验，拼接JSON</li><li>分页查询</li><li>页面迁移</li></ol><h2 id="前后端交互流程"><a href="#前后端交互流程" class="headerlink" title="前后端交互流程"></a>前后端交互流程</h2><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><p>MySQL读写分离，索引，最左匹配原则。</p><h3 id="Spring-MVC原理"><a href="#Spring-MVC原理" class="headerlink" title="Spring MVC原理"></a>Spring MVC原理</h3><p>从Spring MVC原理出发，解释页面迁移的过程。</p><h1 id="技术细节梳理"><a href="#技术细节梳理" class="headerlink" title="技术细节梳理"></a>技术细节梳理</h1><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><h3 id="dcep"><a href="#dcep" class="headerlink" title="dcep"></a>dcep</h3><ol><li>生成sm4key并对明文用sm4key对称加密</li><li>使用sm2对sm4key和publickey进行加密得到加密的sm4key</li><li>将加密请求报文和加密sm4key拼装成传输报文，再用私钥进行加密</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>项目梳理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>情绪海洋</title>
    <link href="/2021/06/25/life/%E6%83%85%E7%BB%AA%E6%B5%B7%E6%B4%8B/"/>
    <url>/2021/06/25/life/%E6%83%85%E7%BB%AA%E6%B5%B7%E6%B4%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="情绪海洋"><a href="#情绪海洋" class="headerlink" title="情绪海洋"></a>情绪海洋</h1><h2 id="活着"><a href="#活着" class="headerlink" title="活着"></a>活着</h2><p>人怎么才算活着？</p><p>有点意义地讲，但又不上升到多高的价值，你是怎么觉得的？</p><p>最近看到一句话，引起了我的注意。</p><blockquote><p>“到目前为止，我仍很激动地活着。” —— 卢川纯</p></blockquote><p>我不知道对她来说，如果不能激动地活着，是否就意味着已经死去。我也不清楚，她是否认为，当她决定要激动地活着的时候，她才算真正开始活着。</p><p>激动在每个人的定义和理解的方式都可能是不同的，或者干脆把激动换成别的什么词，也不是不可以。</p><p>但我想无论你把它换成什么其他的词，在这个语义下，都逃不出情绪这个概念。</p><p>是的，我是说，人只有带着情绪的时候，才算是在活着。</p><h2 id="妖魔化的情绪"><a href="#妖魔化的情绪" class="headerlink" title="妖魔化的情绪"></a>妖魔化的情绪</h2><p>情绪是有主动和被动之分的，生命也是有主动选择地活着和被动牵引地活着。</p><p>事情本身不会有太明确的分割线，但直觉地判断是：</p><p>愤怒是主动的情绪，抱怨就是被动的情绪；<br>满足是主动的情绪，欲望就是被动的情绪；<br>快乐是主动的情绪，爽就是被动的情绪；</p><p>诸如此类……</p><p>不过在现在，情绪好像不是什么好的词。</p><p>正能量大行其道，情绪化就带有了贬义色彩。于是市面上出现了很多正能量满满的情绪管理类书籍。</p><p>这些书只是“术”的层面，还没到“道”的层面。</p><p>最烂的鸡汤文，直接告诉你不要这样，不要那样。讲了那么多白水文，还不如告诉读者直接把情绪发泄到最开始定义和传教“道德”的人身上。</p><p>稍微动了点脑子的作者，旨在告诉读者如何做一个聪明人，他来给你计算利益得失，让原本就愚钝的你在似乎的大彻大悟之后继续聪明不起来。</p><p>真正的情绪管理，不是去情绪化，而是尽可能由内而外地将被动的情绪转化为积极的情绪。毕竟这样修为出来的人，才是真实可爱的。</p><h2 id="情绪海洋-1"><a href="#情绪海洋-1" class="headerlink" title="情绪海洋"></a>情绪海洋</h2><p>一个偶然的灵感让我模拟了这样一个概念：</p><p>在我们的内心有一片情绪海洋，在没有外界往里注入刺激的时候，这片海洋对外表现出的是相对平和的无情绪化特质。</p><p>一个负能量的人内心的情绪海洋可能只是一湾小溪，外界稍一刺激，它表面下的泥土就开始翻土，它对外就开始表现的浑浊。</p><p>一个正能量的人内心的情绪海洋才真的是一片海洋，外界往里注入什么酸性碱性的溶液，都能在极短暂的时间内被中和，外界那些小事根本掀不起这片海洋的什么风浪来。</p><p>正能量人内心的海洋始终平静吗？</p><p>正能量人内心的情绪海洋总是暗涌，只有小溪那浅薄的表层才是真的平静。</p><p>因为小溪清晰与浑浊的太另我们清晰可见了，事实上，它里面什么都没有，涓涓细流，有什么？又容的下什么呢？</p><p>海洋虽然看起来让我们觉得平静，但在它的海平面之下却总是在涌动之中。因为它装载的泥泞实在太多了，可爱的海豚在里面，臭鱼烂虾也在里面，正是因为他内心的鲸鱼在不断地吞食这些鱼虾，他的海洋才能在日光的照射下如你所见的这般蔚蓝。</p><p>人们总是在向往着自由，却在追求自由的路上，发现痛苦才是人生的本质。</p><p>人们不想表现负面情绪，却在不断地自我和解中发现，只有消化掉大量的痛苦，才能呈现出表面的平和。</p><p>空是最高级的修行，无才是真正的没有穷尽。</p><p>人世间不允许你生来那般纯澈，死亦不能带你回归最初的本原。理想主义者只能高举他们手中的完美的旗帜，朝着太阳与大地的方向不断前行。</p>]]></content>
    
    
    <categories>
      
      <category>生活沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>“毕业后我们会成为自己讨厌的样子吗？”｜B站——小苏对话罗翔</title>
    <link href="/2021/06/20/thought/%E2%80%9C%E6%AF%95%E4%B8%9A%E5%90%8E%E6%88%91%E4%BB%AC%E4%BC%9A%E6%88%90%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%AE%A8%E5%8E%8C%E7%9A%84%E6%A0%B7%E5%AD%90%E5%90%97%EF%BC%9F%E2%80%9D%EF%BD%9CB%E7%AB%99%E2%80%94%E2%80%94%E5%B0%8F%E8%8B%8F%E5%AF%B9%E8%AF%9D%E7%BD%97%E7%BF%94/"/>
    <url>/2021/06/20/thought/%E2%80%9C%E6%AF%95%E4%B8%9A%E5%90%8E%E6%88%91%E4%BB%AC%E4%BC%9A%E6%88%90%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%AE%A8%E5%8E%8C%E7%9A%84%E6%A0%B7%E5%AD%90%E5%90%97%EF%BC%9F%E2%80%9D%EF%BD%9CB%E7%AB%99%E2%80%94%E2%80%94%E5%B0%8F%E8%8B%8F%E5%AF%B9%E8%AF%9D%E7%BD%97%E7%BF%94/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1y64y167Sf">🔗 地址</a></p><ol><li><p>学生们进入社会需要具备的基本特质是：谦卑和尊重 </p><ul><li>人的本性就是骄傲和傲慢，人总是以自我为中心，这是人不快乐的根源。</li><li>一个真正谦卑（humble）的人才能发挥作为人最大的能力。</li></ul></li><li><p>一个人会被讨厌的特质是：傲慢和分裂</p><ul><li>我们无比的厌恶他人的傲慢，但我们却无比的放纵自己的傲慢。</li><li>我们随波逐流是因为我们的价值观是分裂的。</li><li>一个分裂的王国无法抵御仇敌，一个分裂的人生无法尊严的面对生命。</li><li>“一个开放的社会就像一张开放的嘴，在合起来的时候，一定要咬住某种坚实的东西。”    —— 切斯特顿</li></ul></li><li><p>讨厌自己的哪些特质：</p><ul><li>虚荣；虚伪；虚无</li><li>一个虚荣的人表现为虚伪，一个彻底虚伪的人的价值观是虚无主义，而虚无主义在逻辑上是不自洽的，虚无会让人痛苦，而且找不到人生的意义。</li></ul></li><li><p>圆滑算成熟吗？怎么看待成熟与天真的关系？</p><ul><li>我们的内心始终有刚硬的东西，这是我们无比坚守的东西，但是尊重别人，是一种同理心，我们需要学会把这种刚硬的东西磨的稍微圆润一点。</li></ul></li><li><p>校园和社会最大的改变？毕业生如何快速调整自己适应社会？</p><ul><li>大学是university，是要追求一种共向（unity）的价值观，同时要体现对多元（diversity）的尊重。</li><li>从学校步入社会，是理想与现实的碰撞。</li><li>美好是存在的，但正是因为美好的存在，我们才能容忍不美好的现实。因为如果你所生活的一切都是万般的美好，你也就感受不到美好了。</li></ul></li><li><p>考研的重要性大吗？</p><ul><li>人生唯一确定的事实就是不确定的人生。</li><li>人生就是在不断的后悔自己没有做另一个选择，因为无论如何选择，都没有想象中的那么美好。</li><li>这样一种不充分的存在，让我们不可能获得一种完美理性的选择，我们要接受这种有瑕疵的选择。</li><li>我们这一生中最大的智慧就是在一个不确定的世界中如何寻找到一种相对的确定性。</li><li>如果没有这种智慧，选择永远都是选项而已，我们还是要困扰在每天的焦虑之中。</li><li>只有枯死的叶子才会随波逐流，只有活着的东西才会与之抗争。心死为忙，在忙乱中我们忘记了自己还活着。</li></ul></li><li><p>如何看待终身学习与去能力化的工作之间的矛盾？</p><ul><li>人生中比拼的绝大多数不是高能，而是基础能力。最基础的能力是我们这个时代所最匮乏的。</li></ul></li><li><p>哲学家尼布尔曾说：“请赐予我胸怀，让我接受无法改变的事情。请赐予我勇气，让我去改变能够改变的事情。请赐予我智慧，让我分辨它们两者的不同。”</p><ul><li>古希腊哲学家艾比克泰德：“对于可控的事情我们要保持谨慎，对于不可控的事情我们要保持乐观。”</li></ul></li><li><p>如何看待很多人过的越来越功利？</p><ul><li>很多人都想过一个体面的一生，但问题在于，当你那些欲望满足的时候，你真的能够快乐吗？</li></ul></li><li><p>有多少可以自由支配的时间？</p><ul><li>我们终将毁灭于我们所热爱的东西。</li><li>那些看起来很爽的东西都是瞬间的满足，而人类所有真实的快乐，一定是恒久的努力。</li></ul></li><li><p>我们如何面对“我们活成了自己讨厌的样子”？</p><ul><li>我们时常活的忙乱，而又不知在忙什么。所以问题就在于，你的持守是什么？</li><li>当你有你的坚持，你也许就能回答这个问题。换言之，当你感觉活成了自己所厌恶的样子，你就要反躬己身问自己的坚守是什么？你心中的GOOD是什么？</li></ul></li><li><p>如何理解“勇敢”？</p><ul><li>合乎中道的勇敢。在明确心中持守和坚定的前提下，能够勇敢的为之前进。</li><li>心中知道什么是对的，但始终无法勇敢的坚守自己认为是对的东西。</li></ul></li><li><p>反问：什么是“良善”？如何过良善的一生？</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>苦尽甘来</title>
    <link href="/2021/06/19/life/%E8%8B%A6%E5%B0%BD%E7%94%98%E6%9D%A5/"/>
    <url>/2021/06/19/life/%E8%8B%A6%E5%B0%BD%E7%94%98%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="苦尽甘来"><a href="#苦尽甘来" class="headerlink" title="苦尽甘来"></a>苦尽甘来</h1><h2 id="甜水"><a href="#甜水" class="headerlink" title="甜水"></a>甜水</h2><p>一杯水在什么情况下是甜的？</p><p>往里加糖！</p><p>还有呢？</p><h2 id="竹芒"><a href="#竹芒" class="headerlink" title="竹芒"></a>竹芒</h2><p>这是来到高乐雅第三次喝竹芒得到的启发。</p><p>第一次遇见竹芒，很是惊喜，很早就关注了这款耶加雪菲，没想到在这处神奇之地可以遇见。</p><p>看到了店员姐姐手冲的全过程，还有旁边座位的妹子，我们一起聊了聊咖啡。第一次对这款咖啡味道的记忆是模糊的。</p><p>第二次来这里喝这款竹芒的时候，店员姐姐给我准备了两个杯子，一杯加冰加柠檬，一杯只加冰。这让我体验了四种不同酸度层次的口味。</p><p>这次来喝，还是准备了两个杯子。不过是一杯加冰，一杯是白水。</p><p>巧妙的事情发生了，在我一饮而尽一杯加冰的竹芒后，紧接着我喝了一口白水，那种强烈的回甘甜感十分明显。</p><p>这让我想起了今年生日前的几天，刚拿到实习的offer，在所里一楼的咖啡间，和姐姐讨了几颗余甘子和一杯冰美式。</p><p>从吃下余甘子的苦，到喝冰咖啡回甘的甜，那种苦尽甘来的体验使我印象深刻。</p><p><img src="/img/2021/%E8%8B%A6%E5%B0%BD%E7%94%98%E6%9D%A5-0.JPG" alt="余甘子-教父-竹芒"></p><h2 id="容易的快乐"><a href="#容易的快乐" class="headerlink" title="容易的快乐"></a>容易的快乐</h2><p>本杰明·富兰克林说，“唯有痛苦才能给人带来教益。”</p><p>可是教益不足以支撑我们接下来所有的生活。生活除了痛苦，还应该有快乐。</p><p>但快乐的获取方式不只一种，就如同这杯能够产生甜感的白水。</p><p>往水里直接加糖，自然喝起来会很甜。但这甜是刺激的，是迷幻的，我们喝的已不再是那杯原来的白水了，而是糖水。</p><p>我们如何才能持续不断地获取这份甜感？也许唯有不断地往水里加糖了。可是，我们手里的蔗糖始终有限。</p><p>但是如果我们喝了一杯口感浓烈回甘强劲的咖啡呢？白水还是那杯白水，但经由我们自身的感受，它却是甜的。</p><p>而且最重要的是，使我们产生甜感的，仍然是那杯白水。而我们生活里遇见最多的，也是白水。</p><p>痛苦，平淡，快乐。这像是以平淡为基点建立的生命的中轴线。在绝大多数时间的平淡里，我们时而痛苦，时而快乐。</p><p>且不说逃避痛苦是否是对的，单就一味追求平淡之外的快乐本身就存在问题。</p><p>毕竟，凡是容易的，能给神经快速带来刺激的快乐，都是短暂的、易逝的；凡是与自律相关的，通过不断地投入所带来的快乐与满足，也必将是长足的。</p><h2 id="短暂的治愈"><a href="#短暂的治愈" class="headerlink" title="短暂的治愈"></a>短暂的治愈</h2><p>并不是说拒绝娱乐，吃苦享乐就更高级，事实上快乐本身没有等级之分。</p><p>既然我们的本性是趋想快乐的，那何不如可持续地放大这种快乐？</p><p>我现在每天上下班加起来要走100公里的路程，路途本身并不会带来什么快乐，无论我如何渲染自己的这份辛苦与坚持。</p><p>但一天之中我真正的快乐是什么呢？应该是与奔波苦苦斗争之后，每天在安静不被打扰的时光里的阅读与思考。</p><p>不置身资本牢笼的学生不会体会生活的艰辛，更不会体会生活的快乐。</p><p>还是那杯白水，无论你赋予它怎样甜的意义，它始终是那杯没有味道的白水。但是你喝下一杯苦的咖啡，再去喝这杯白水，味蕾的甜感不会欺骗你。</p><p>治愈的意义也莫过于此，一天的路途上要花去四个小时，重复无聊的工作还要再花去八九个小时，但是却可以通过睡前阅读的那一个小时，得到彻底的缓解。</p><p>生活不需要长足的治愈，但是绝不能缺乏日常疲惫和重复过后的治愈本身。</p><p>所以你有没有发现，越是容易喝到的甜水（加了糖的），想再次喝到它越困难。越是尝够了苦头，喝那容易喝到的白水，获得的甜感越是容易。</p><p>要记取，每天都要为你的内心争取一段独属你的治愈时光。</p><h2 id="资本的牢笼"><a href="#资本的牢笼" class="headerlink" title="资本的牢笼"></a>资本的牢笼</h2><p>现在几乎全世界的人都已认清了资本的丑相，并且还在拥抱它。</p><p>是的，我现在想说说拥抱资本的问题。</p><p>同样是在吃，有的人吃巧克力的吃相让人觉得他在吃屎，有的人吃屎让人觉得他在吃巧克力。</p><p>拥抱资本也是一样。</p><p>人们已经足够认识资本的丑陋了，但当你拿着被资本剥削后的酬劳换取同样是资本用来安抚你的“催眠药”，你的愤怒又高级到了哪里？吃相又好看到了哪里？</p><p>你应该在自己的脑子里列一份资本的善恶清单，去享受你所处时代下资本的馈赠吧，前提是警惕资本背后的“伪善”。</p><p>要知道，人的一生大多时间都是重复而无聊的。不要再抱怨资本主义下工作生活的无聊了，生活还在忍受你的重复呢！</p><p>要活的有知觉起来，要热爱你螺丝钉一般的事业。你的工作不比西西弗斯滚落的那块石头更加无聊。</p><p>你还没有为你无聊的生活赋予意义，就着急咒责赏赐你饭碗的资本，你的善良又高贵在了哪里？</p><p>事实上，给了你你想要的闲适的生活又能怎样？给了你花不完的金钱又能怎样？你真的确定就能把这样的生活过的不无聊吗？</p><p>那些整天端着铁饭碗的人们把闲适的生活过得有意思到了哪里？那些一掷千金的富豪们在发泄性欲的时候又比小动物们有意思到了哪里？</p><p>不怕给你资本，就怕给了你资本，你自己不中用啊！</p><p>不怕每天是在搬砖，就怕你真的每天都只是在搬砖。</p><p>你能否在搬砖的过程中积累些更高级的技能？</p><p>你能否在繁杂的业务里梳理出更有价值的需求，看到更有前景和可能的契机？</p><p>你已经被资本裹挟一天了，为什么到了晚上睡觉的时候，还在拿着手机，继续被资本裹挟？</p><p>你不该奢望那么长的治愈时光，眼下最短暂最可以把握的机会都已被你错过。</p>]]></content>
    
    
    <categories>
      
      <category>生活沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven｜基础学习</title>
    <link href="/2021/06/14/tech/develop/Maven%EF%BD%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/06/14/tech/develop/Maven%EF%BD%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Maven是什么？"><a href="#Maven是什么？" class="headerlink" title="Maven是什么？"></a>Maven是什么？</h3><p>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。</p><h3 id="约定的目录结构"><a href="#约定的目录结构" class="headerlink" title="约定的目录结构"></a>约定的目录结构</h3><table><thead><tr><th>目录</th><th>功能</th></tr></thead><tbody><tr><td>${basedir}</td><td>存放pom.xml和所有的子目录</td></tr><tr><td>${basedir}/src/main/java</td><td>项目的java源代码</td></tr><tr><td>${basedir}/src/main/resources</td><td>项目的资源，比如说property文件，springmvc.xml</td></tr><tr><td>${basedir}/src/test/java</td><td>项目的测试类，比如说Junit代码</td></tr><tr><td>${basedir}/src/test/resources</td><td>测试用的资源</td></tr><tr><td>${basedir}/src/main/webapp/WEB-INF</td><td>web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</td></tr><tr><td>${basedir}/target</td><td>打包输出目录</td></tr><tr><td>${basedir}/target/classes</td><td>编译输出目录</td></tr><tr><td>${basedir}/target/test-classes</td><td>测试编译输出目录</td></tr><tr><td>Test.java</td><td>Maven只会自动运行符合该命名规则的测试类</td></tr><tr><td>~/.m2/repository</td><td>Maven默认的本地仓库目录位置</td></tr></tbody></table><h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。</p><p>POM 中可以指定以下配置：</p><ul><li>项目依赖</li><li>插件</li><li>执行目标</li><li>项目构建 profile</li><li>项目版本</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><h2 id="POM文件的结构"><a href="#POM文件的结构" class="headerlink" title="POM文件的结构"></a>POM文件的结构</h2><h3 id="1、模型版本"><a href="#1、模型版本" class="headerlink" title="1、模型版本"></a>1、模型版本</h3><p>在Maven2和Maven3中，只支持4.0.0版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、基本配置"><a href="#2、基本配置" class="headerlink" title="2、基本配置"></a>2、基本配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3、Build配置"><a href="#3、Build配置" class="headerlink" title="3、Build配置"></a>3、Build配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">reporting</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">reporting</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4、环境配置"><a href="#4、环境配置" class="headerlink" title="4、环境配置"></a>4、环境配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">issueManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">issueManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ciManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">ciManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mailingLists</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">mailingLists</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scm</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">scm</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">prerequisites</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">prerequisites</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5、其他配置"><a href="#5、其他配置" class="headerlink" title="5、其他配置"></a>5、其他配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">inceptionYear</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">inceptionYear</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">licenses</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">licenses</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">organization</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">organization</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">developers</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">developers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contributors</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">contributors</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>关于具体的解释可以参考<a href="https://zakariyya.github.io/2019/01/03/backEnd-maven-maven%E6%A0%87%E7%AD%BE%E5%AD%97%E5%85%B8/">这里</a></p></blockquote><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p><a href="http://maven.apache.org/download.cgi">下载地址</a></p><p>下载后解压到<code>/usr/local</code>目录下，并更改<code>base_dir</code>的name为<code>maven</code>。</p><p>将以下内容添加到<code>./bash_profile</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">MAVEN_HOME=/usr/<span class="hljs-built_in">local</span>/maven<br>PATH=<span class="hljs-variable">$MAVEN_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> MAVEN_HOME<br><span class="hljs-built_in">export</span> PATH<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>开发工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《少有人走的路》｜读书笔记</title>
    <link href="/2021/06/13/thought/%E3%80%8A%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E3%80%8B%EF%BD%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/13/thought/%E3%80%8A%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E3%80%8B%EF%BD%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>“人生苦难重重。”这句话告诉我们苦难是人生的常态。</p>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《查拉图斯特拉如是说》｜章节概要</title>
    <link href="/2021/06/06/thought/%E3%80%8A%E6%9F%A5%E6%8B%89%E5%9B%BE%E6%96%AF%E7%89%B9%E6%8B%89%E5%A6%82%E6%98%AF%E8%AF%B4%E3%80%8B%EF%BD%9C%E7%AB%A0%E8%8A%82%E6%A6%82%E8%A6%81/"/>
    <url>/2021/06/06/thought/%E3%80%8A%E6%9F%A5%E6%8B%89%E5%9B%BE%E6%96%AF%E7%89%B9%E6%8B%89%E5%A6%82%E6%98%AF%E8%AF%B4%E3%80%8B%EF%BD%9C%E7%AB%A0%E8%8A%82%E6%A6%82%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1、序言"><a href="#1、序言" class="headerlink" title="1、序言"></a>1、序言</h3><p>查拉下山，和老圣人一番对话。</p><p>上帝死后，老圣人依然信仰上帝，仇视人类，看山不是山。查拉出山入世，要给人类带去一件礼物，看山还是山。这种心态上的转变，或许是阅读这本书我想要获得的。毕竟，再阴郁的内心，也会觉得那句”啊！太阳”充满了光热。   </p><p>查拉入世，想给人们带去的这样礼物，便是”超人”，但当查拉借以”超人”，引出完全与之对立的<a href="http://www.ideamass.com.cn/contents/727/5041.html">“末人”</a><br>时，人们却说：”查拉，把末人还给我们吧，我们用超人和你交换末人。”</p><p>查拉陪伴在人们所讥笑的小丑演员的尸体旁，意识到创造者不该与这些尸身为伴，创造者的伙伴只能是其他创造者。查拉必须去寻找他们，告诉他们通往超人之路的阶梯。</p><blockquote><p>做一只空杯，是这只杯子最热切的希望。</p><p>如果你想要施舍他们一些东西，就单纯地去施舍，而且是在他们乞求你的情况下。即便是要送出宝物，也要留神怎样被接受才是。</p><p>人身上总有一种伟大的特质，这种特质在于人不是目的，而只是一座桥梁。人的身上，有着一种落寞，人本身，就是一种动物朝着超人的过渡，而这，也正是人的可爱之处。我爱那些作为过渡者的人们，因为他们沉溺在没落中，从来都不懂得生活。</p><p>创造者的伙伴不应该是死者，更不会是牧群和最纯正的信徒。创造者的伙伴只能是其他的创造者，是那些将新的价值观念书写在新的规则世界的人。</p></blockquote><h3 id="2、三种变形"><a href="#2、三种变形" class="headerlink" title="2、三种变形"></a>2、三种变形</h3><p>精神本身存在着三种变形，精神变成骆驼，骆驼变成狮子，狮子变成小孩。首先是”负担”，然后是”我想”，最后是”我是”。</p><blockquote><p>精神本身存在着三种变形，精神变成骆驼，骆驼变成狮子，狮子变成小孩。</p></blockquote><h3 id="3、德性讲坛"><a href="#3、德性讲坛" class="headerlink" title="3、德性讲坛"></a>3、德性讲坛</h3><p>德性之高者必拥有好的睡眠。</p><blockquote><p>睡眠很重要，它不是一件小事，白天，我们精神奕奕，保持理智和清醒，为的就是在晚上能够睡好。</p></blockquote><h3 id="4、彼世论者"><a href="#4、彼世论者" class="headerlink" title="4、彼世论者"></a>4、彼世论者</h3><p>幻想一个虚妄的来世，这本身就是一种消极的虚无主义；用强大的生命力赋予今生今世、此时此刻以意义，这才是真实。</p><blockquote><p>所谓的彼世，不是解脱，而是另一种痛苦，它代表着无能，它是一种疯狂，只有沉浸在最深沉的苦难中的人才能从其中体会到短暂的幸福。</p><p>他们相信的不是所谓的彼世，也不是救赎的血滴，而是他们自己的身体，对他们来说，自己的身体就是承载自由的容器。</p></blockquote><h3 id="5、身体的蔑视者"><a href="#5、身体的蔑视者" class="headerlink" title="5、身体的蔑视者"></a>5、身体的蔑视者</h3><p>“我的身体就是我的灵魂”是对”抽象的灵魂对肮脏的肉体的蔑视”的批判。</p><blockquote><p>我的身体就是完整的我，除了身体，一切其他的东西都不存在，灵魂也不过是人们对身体中某个特定部位的称呼。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《沉思录》｜读书笔记</title>
    <link href="/2021/05/30/thought/%E3%80%8A%E6%B2%89%E6%80%9D%E5%BD%95%E3%80%8B%EF%BD%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/05/30/thought/%E3%80%8A%E6%B2%89%E6%80%9D%E5%BD%95%E3%80%8B%EF%BD%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java异常机制代码执行顺序</title>
    <link href="/2021/05/29/tech/JavaSE/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2021/05/29/tech/JavaSE/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>在本周实习coding的时候遇到这样一个问题，如果code2处发生异常，整个程序是直接终止吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    code1<br>    code2 <span class="hljs-comment">// 发生异常</span><br>    code3<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    code4<br>&#125;<br>code5<br></code></pre></td></tr></table></figure><p>借此机会，对异常的代码执行顺序进行一个简单的整理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;发生异常！&quot;</span>); <span class="hljs-comment">// code1</span><br>            <span class="hljs-comment">// System.out.println(&quot;code1&quot;); IDE会提示为无效代码，会产生编译错误。</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace(); <span class="hljs-comment">// 捕获到了code1的代码</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;finally&quot;</span>); <span class="hljs-comment">// try完无论抛不抛异常都会执行的代码</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;end&quot;</span>); <span class="hljs-comment">// 被catch到的异常会执行，没被catch到的或者catch完有抛了新的异常都不会执行。</span><br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;参数越界&quot;</span>); <span class="hljs-comment">// IDE提示在函数头抛出异常</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;异常后&quot;</span>); <span class="hljs-comment">//抛出异常，不会执行</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">java.lang.Exception: 发生异常！</span><br><span class="hljs-comment">at Test.main(Test.java:7)</span><br><span class="hljs-comment">Exception in thread &quot;main&quot; java.lang.Exception: 参数越界</span><br><span class="hljs-comment">at Test.main(Test.java:17)</span><br><span class="hljs-comment">finally</span><br><span class="hljs-comment">end</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Process finished with exit code 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1、<a href="https://blog.csdn.net/qq_2300688967/article/details/79425729">https://blog.csdn.net/qq_2300688967/article/details/79425729</a></p>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git命令学习</title>
    <link href="/2021/05/29/tech/develop/Git%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/05/29/tech/develop/Git%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/2021/git-command.jpeg" alt="git-command"></p><p>写代码时，要把公司仓库的代码clone到本地，在workspace路径下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b &lt;branch_name&gt; &lt;repository&gt;<br></code></pre></td></tr></table></figure><p>分支操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch <span class="hljs-comment"># 查看本地分支</span><br>git branch &lt;branchName&gt; <span class="hljs-comment"># 创建分支</span><br>git checkout &lt;branch_name&gt; <span class="hljs-comment"># 转到某一分支</span><br><br>git checkout -b &lt;branchName&gt; <span class="hljs-comment"># 在当前分支下创建新的分支并切换到新创建的分支</span><br></code></pre></td></tr></table></figure><p>修改完代码提交到远程仓库分支中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add . <span class="hljs-comment"># 将所有文件放到暂存区</span><br>git commit -m &lt;message&gt;  <span class="hljs-comment"># 提交到本地仓库</span><br><br>git commit -am &lt;message&gt; <span class="hljs-comment"># 合并add 和commit的命令</span><br><br>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; <span class="hljs-comment"># 将本地的分支版本上传到远程并合并</span><br>git push &lt;远程主机名&gt; &lt;本地分支名&gt; <span class="hljs-comment"># 如果本地分支名与远程分支名相同，则可以省略冒号，一般远程主机名为origin</span><br><br>git pull &lt;remote&gt; &lt;branch&gt; <span class="hljs-comment"># 取远程仓库变化，合并到当前分支</span><br><br>git pull <span class="hljs-comment"># 一般都是从master clone下来的，所以pull到master分支</span><br>git merge master <span class="hljs-comment"># 在当前分支下，将本地master合到当前分支</span><br><br>git checkout . <span class="hljs-comment"># 未执行add，撤销工作区的修改</span><br>git reset HEAD &lt;filename&gt; <span class="hljs-comment"># add之后撤销暂存区的修改，但保留工作区修改</span><br>git restore &lt;finename&gt; <span class="hljs-comment"># 撤销工作区的修改</span><br>git reset --hard HEAD^ <span class="hljs-comment"># commit之后回到最新一次的提交</span><br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status <span class="hljs-comment"># 显示所有🈶变更的文件</span><br>git diff <span class="hljs-comment"># 显示暂存区和工作区的差异</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“提升专注力”｜B站&lt;YXZHANG_&gt;</title>
    <link href="/2021/05/23/thought/%E2%80%9C%E6%8F%90%E5%8D%87%E4%B8%93%E6%B3%A8%E5%8A%9B%E2%80%9D%EF%BD%9CB%E7%AB%99%3CYXZHANG_%3E/"/>
    <url>/2021/05/23/thought/%E2%80%9C%E6%8F%90%E5%8D%87%E4%B8%93%E6%B3%A8%E5%8A%9B%E2%80%9D%EF%BD%9CB%E7%AB%99%3CYXZHANG_%3E/</url>
    
    <content type="html"><![CDATA[<p>生命的有效时长由三个因素决定，一是所行之事本身是否有意义，在此基础上，另一个是行事的有效投注时间。</p><p>提升专注力不等同于提升效率，因为追求效率意味着可能掉进时间管理的陷阱，即被过程中的形式主义所束缚，而忽略了问题的本质和最终的目标。</p><p>专注和效率的正确关系是，<strong>效率是专注做事附带的产物</strong>，而专注除了可以提升产出效率外，还可以保持头脑清晰，带来心情愉悦。</p><p>专注是需要精力的，所以提升专注要围绕两方面展开，一方面要减少精力的消耗，另一方面要直接或间接地补充精力。</p><p>精力消耗的一种情况是走神，应对策略是自我暗示，即告诉自己当下在做什么，如此可以减少走神时间。除此，要控制好环境变量，减少信源等，可以采用效率软件辅助。</p><p>补充精力要早起早睡，运动，规律饮食，三者可以形成正反馈闭环，主动提升专注力。除此，正念冥想的作用也十分明显。</p><p>分析精力消耗和精力补充的关系：在补充精力代价下，如果控制不好精力的消耗，意味着产出的低效，这不会影响头脑的清晰，但会被动使心情变糟；在控制好精力消耗的代价下，没有补充好精力，这将导致心有余而力不足，久而久之形成恶性循环。</p><p>分析各因素的性价比：</p><ol><li>睡眠时间是实打实的，长期规律的休息时间大概在8个小时左右，如果睡眠时长在5个小时左右，甚至更短，可能需要用几天甚至一周的时间来调整，性价比极低，因此需要保证工作日睡眠的基本充足；</li><li>冥想时间在15分钟左右；长期冥想会直接影响到一天的精神状态，性价比极高。</li><li>运动时间在1小时左右，长期规律运动会保持心情愉悦，也有助于脑力和身体其他技能锻炼，性价比也很高。</li><li>减少信源，可以设定时间间隔看信息，比如每隔一小时回复消息，每隔三天刷一次朋友圈。</li></ol><p>至此，一个良性的专注力提升闭环已形成：</p><ol><li>通过早起早睡保证有力可用；</li><li>通过正念冥想使精神集中，直接提高专注能力；</li><li>通过运动调整身体机能和心情，辅助更好地专注；</li><li>做事前屏蔽掉噪声信源，减少走神的概率和频次；</li><li>走神的时候通过自我暗示最大程度减少走神时间。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.bilibili.com/video/BV1ND4y1m74e">https://www.bilibili.com/video/BV1ND4y1m74e</a></p>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《刘擎西方现代思想讲义》｜伟大又危险的尼采</title>
    <link href="/2021/05/02/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E4%BC%9F%E5%A4%A7%E5%8F%88%E5%8D%B1%E9%99%A9%E7%9A%84%E5%B0%BC%E9%87%87/"/>
    <url>/2021/05/02/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E4%BC%9F%E5%A4%A7%E5%8F%88%E5%8D%B1%E9%99%A9%E7%9A%84%E5%B0%BC%E9%87%87/</url>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>尼采说：“一个人能承受多少真相，是对他精神强度的考验。”只有我们有勇气直面上帝之死后的种种真相，才能真正找到生命的意义。这也正是罗曼罗兰所说的：“世上只有一种英雄主义，就是在认清生活的真相后依然热爱生活。”</p><h2 id="从“上帝死了”说起"><a href="#从“上帝死了”说起" class="headerlink" title="从“上帝死了”说起"></a>从“上帝死了”说起</h2><h3 id="可怕的宣言"><a href="#可怕的宣言" class="headerlink" title="可怕的宣言"></a>可怕的宣言</h3><p>随着启蒙时代的到来，理性主义大行其道。而把宗教从神坛基本上推下来的，应该是尼采的那句“上帝死了”。然而，这真的像是一场革命胜利的欢呼吗？</p><p>其实，尼采在宣告“上帝死了”之后的下一句是“是我们杀死了上帝！”这根本不是欢呼，这完全是一句沉痛的哀告。</p><p>为什么说这是一句哀告？因为对于当时的西方人而言，否定了上帝，信仰的大厦完全崩塌，生命找不到意义，人们就会陷入「虚无主义」之中。</p><p>可为什么尼采又说“是我们杀死了上帝”？</p><p>学术界有千万种解释，而作者认为，尼采虽以反基督教著称，但他对耶稣本身并无敌意。只是他认为，耶稣并不是要直接救赎人类，而是告诉人们应该怎么生活。可耶稣的门徒却把经念歪了，不仅没有好好实践“怎样生活”，还搞出一套教义理论自欺欺人。这根本不是耶稣的愿意，而是一套虚假的思想。</p><h3 id="虚假的形而上"><a href="#虚假的形而上" class="headerlink" title="虚假的形而上"></a>虚假的形而上</h3><p>这个虚假的思想究竟是什么呢？</p><p>尼采给出的答案是“形而上学”。</p><p>尼采将形而上学概括为三大信念：</p><ol><li>相信在感知的表象世界背后有一个更真实的本质世界；</li><li>相信这个混乱的世界实际上是有目的的；</li><li>相信这个纷乱多样的世界背后有一种统一性。</li></ol><p>可尼采认为，那个所谓的更真实的、有目的的、有统一性的本质世界根本不存在。这完全是形而上学的编造，其本质原因是人们需要安慰。但这种安慰最终却会带来恶果：就好比一个人本来很爱钱，但因为贫穷感到自卑，于是他就去信奉一套所谓的“高尚的人应该是金钱如粪土”的说辞来躲避自己的自卑感。可生命欲望却是真实的，也是正当的。</p><p>因此在尼采看来，那些看上去高尚典雅、充满确定感的形而上学才是虚无主义的真正根源。</p><h2 id="直面虚无主义的真相——“超人学说”"><a href="#直面虚无主义的真相——“超人学说”" class="headerlink" title="直面虚无主义的真相——“超人学说”"></a>直面虚无主义的真相——“超人学说”</h2><blockquote><p>人类的高贵在于自身有决定价值的能力，不需要别人同意，他懂得自己给事物以荣耀。    —— 尼采</p></blockquote><h3 id="积极的虚无主义"><a href="#积极的虚无主义" class="headerlink" title="积极的虚无主义"></a>积极的虚无主义</h3><p>上帝之死所产生的虚无难道一定是一种很悲剧很可怕的处境吗？</p><p>尼采的回答是，未必。</p><p>而如果对尼采一生的哲学命题进行一个概括的话，就是：人生虚无、理论虚假、生命强健。</p><p>生命本身就是对抗虚无的办法。</p><p>其实在尼采看来，虚无主义本身还分积极的和消极的。先说消极的虚无主义，虚无并不直接导致消极，从虚无到消极，要必经一个中间环节——幻念：认为在世界的表象背后还存在绝对的本质，并且认为人生必须依靠这个绝对的本质才能找到价值和意义。然而当你所认为的这个本质被一次次击碎的时候，幻念将变成绝望。而积极的虚无主义则是：认识到世界本无意义，而这恰恰带来了创造的自由。</p><p>最好的积极的虚无主义的例子，就是加缪笔下的西西弗斯。西西弗斯的命运象征着人生的困境，一切皆是徒劳。但除了沮丧绝望让整个生命历程变成一种痛苦的折磨的选择外，还有一种选择就是勇敢无畏精神焕发地推动那块巨石。西西弗斯选择了后者，他用自己的选择创造出了意义，用无尽的斗争精神去对抗虚无。因此加缪写道：“登上顶峰的斗争本身足以充实人的心灵。应该设想，西西弗斯是幸福的。”</p><h3 id="奴隶道德与主人道德"><a href="#奴隶道德与主人道德" class="headerlink" title="奴隶道德与主人道德"></a>奴隶道德与主人道德</h3><p>我们每个人都是西西弗斯，面对虚无的人生，有两种截然不同的选择。尼采把这两种人生选择叫作奴隶道德<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="奴隶道德就是放弃自己生命的激情，用虚假的思想来约束自己、安慰自己，把人生希望寄托在虚妄的观念之中。">[1]</span></a></sup>和主人道德<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="主人道德就是放弃一切幻念，直面虚无和荒谬，像西西弗斯那样用生命的激情去自我创造，做一个勇敢、荒谬的英雄。">[2]</span></a></sup>。</p><p>而拥有主人道德的人就是「超人」，超人能够在上帝死后，成为自己的主人。可以说，超人于普通的人，无异于普通人于一只猴子。</p><h3 id="“超人学说”本身是否也是一种虚假理论"><a href="#“超人学说”本身是否也是一种虚假理论" class="headerlink" title="“超人学说”本身是否也是一种虚假理论"></a>“超人学说”本身是否也是一种虚假理论</h3><p>历史上所有的先知都呼吁他们的信徒“听从我，追随我”，而尼采却说，你否定了我才是真正理解了我，才是深刻的追随，我才会回到你们身边。</p><p>所以，如果你相信一种真理，那就不该盲从它，如果你真的理解一种思想，就不该相信创造这种思想的人所留下的教条，而是去探索自己的生命。</p><blockquote><p>你们说相信查拉图斯特拉，但查拉图斯特拉算什么？你们说是我的信徒，但所有的信徒又算得了什么？你们没有探索自己，却发现了我……现在我要你们丢开我去发现自己，只有当你们全部否定我的时候，我才会回到你们身边。    —— 尼采 《查拉图斯特拉如是说》</p></blockquote><h2 id="我们共同的真相应该是什么"><a href="#我们共同的真相应该是什么" class="headerlink" title="我们共同的真相应该是什么"></a>我们共同的真相应该是什么</h2><h3 id="视角主义"><a href="#视角主义" class="headerlink" title="视角主义"></a>视角主义</h3><p>尼采在一个多世纪前，就看到了后真相现象<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="用来描划“客观事实在形成舆论方面影响较小，而诉诸情感和个人信仰会产生更大影响”的情形。比如对硅谷的程序员来说，全球化推动了美国经济的发展，这是一个事实。而事业的重工业区就业者说出的另一个事实是，全球化推动了互联网公司的发展，但是制造业却衰退了而制造业却是国家的立身之本。">[3]</span></a></sup>的本质：客观的事实真相可能根本不存在。这种观点在哲学届被称为“视角（perspective）主义”，即没有事实，只有阐释。</p><p>但这和我们传统的认知模式<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="这种传统的认知模式可以是：横看成岭侧成峰，远近高低各不同。也可以是我们借用科学工具能看到我们肉眼看不到的客观世界。">[4]</span></a></sup>有一个根本的不同。我们传统认知模式有一个前提是：认为存在一个客观的真相或真理。我们不断地去认知它，理解它，表达它，只要不断推进这个过程，我们最终是可以完全认识和掌握这个真相的。</p><p>但尼采的视角主义认为，“存在一个客观真相”不过是一厢情愿的假设。这种“客观性”不过是一种合理的错觉。我们以为我们在“认知”真相，其实我们只是在“制造”真相。</p><p>而事实是，那些我们的“共同视角”所看到的真相，只不过得到了一致的解释，但客观事实也会变，科技也在进步，我们所看到的“客观事实”也会随着“共同视角”的变化而变化。</p><h3 id="“后真相”时代给我们的启示"><a href="#“后真相”时代给我们的启示" class="headerlink" title="“后真相”时代给我们的启示"></a>“后真相”时代给我们的启示</h3><p>在后真相时代下，难道社会注定只能陷入无休止的分裂和争执吗？</p><p>理财的视角主义种还蕴藏着另一种可能性：恰恰是因为明白了每个人视角都只是视角之一，所以我们应该意识到我们所以为的真相其实不一定是绝对的真相。了解不同，不是要我们和他人划清界限，而是要我们以更开放的态度，去倾听、理解和学习它们。</p><blockquote><p>我们越是运用更多的眼睛、不同的眼睛去观察同一个东西，我们对这个东西的“概念”就越“完整”。我们也能越“客观”。    —— 尼采《道德的谱系》</p></blockquote><h2 id="我的感受"><a href="#我的感受" class="headerlink" title="我的感受"></a>我的感受</h2><p>阅读刘擎笔下尼采这部分的文字，所给我带来的精神愉悦无疑是极致的。了解了尼采的“超人主义”过后，再回头去想加缪笔下的西西弗斯，才发现虚无主义可能包含的积极性究竟在哪。“后真相”时代让每个人都成为自己“视角主义”的上帝，但与此同时一个事实也十分明显：保持开放态度地倾听、理解和学习他人视角下的真相只是一种“应然”，而现实却是人群中随处可见的傲慢与偏见。我们每个人的确可以做自己生命中的乐观的悲观主义者，但上帝死后的世界究竟该何去何从，混乱的世界到底还要不要一个相对统一的价值判断，如果要，它会是什么，尼采似乎并没有告诉我们答案。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>奴隶道德就是放弃自己生命的激情，用虚假的思想来约束自己、安慰自己，把人生希望寄托在虚妄的观念之中。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>主人道德就是放弃一切幻念，直面虚无和荒谬，像西西弗斯那样用生命的激情去自我创造，做一个勇敢、荒谬的英雄。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>用来描划“客观事实在形成舆论方面影响较小，而诉诸情感和个人信仰会产生更大影响”的情形。比如对硅谷的程序员来说，全球化推动了美国经济的发展，这是一个事实。而事业的重工业区就业者说出的另一个事实是，全球化推动了互联网公司的发展，但是制造业却衰退了而制造业却是国家的立身之本。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>这种传统的认知模式可以是：横看成岭侧成峰，远近高低各不同。也可以是我们借用科学工具能看到我们肉眼看不到的客观世界。<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《刘擎西方现代思想讲义》｜韦伯—现代思想的成年</title>
    <link href="/2021/05/01/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E7%9A%84%E6%88%90%E5%B9%B4/"/>
    <url>/2021/05/01/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E7%9A%84%E6%88%90%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>从现代社会的底层机制和最深层的缺陷看待我们如何成为一个完整的人。</p><h2 id="韦伯与现代思想的成年"><a href="#韦伯与现代思想的成年" class="headerlink" title="韦伯与现代思想的成年"></a>韦伯与现代思想的成年</h2><p>在阅读导论的时候，我们说道韦伯是作为现代思想成年的标志，这是因为他完成了两项任务：看清现代，反思现代。</p><p>所谓看清现代，是说他的思想<strong>真正理解了现代社会运作的底层机制</strong>。韦伯之前，西方的现代化虽已发展两百年，但人们对于现代化的理解大多还是片面和混乱的。直到韦伯以“理性化”为核心，建立了一套现代化理论，才第一次全面而系统地解释了现代社会的来龙去脉和运转机制。</p><p>而所谓反思现代，是说韦伯的思想<strong>指出了现代性最深层的缺陷</strong>。这种缺陷是根植于现代化本身的问题。这些问题不随社会进步而消除，反因社会发展而更加严重。</p><p>韦伯在《学术作为一种志业》的演讲中指出了生命意义的问题是一种超出科学边界的存在，即：科学永远无法回答我们做出什么样的选择才是值得的；我们过什么样的生活才是有意义的；我们生命的目的究竟是什么。<strong>科学也许可以给出最有的“方案”，但永远无法教给我们一个最有的“选择”</strong>。（关于方案和选择，其实就是后面要提到的「工具理性」和「价值理性」的问题）</p><p>在欧洲文艺复兴之后，人们把理性推向了替代神明的高座，却对于其产生的后果没有充分的认识。韦伯真正的贡献不在于阐明了现代的理性化特征，而是揭示了理性化的各种复杂后果，打破了启蒙时代以来对于科学理性的乐观主义错觉。</p><p>而后的几节，分别是作者从韦伯思想中提炼的核心命题：“世界的祛魅”“诸神之争”“现代的铁笼”。</p><h2 id="祛魅"><a href="#祛魅" class="headerlink" title="祛魅"></a>祛魅</h2><p>今天我们再看待过去时代的人所信仰的神明，它可能意味着任何世界之间是可以建立起某种联系的，甚至是可以沟通和互动的。诸如：渔船出海前祭奠妈祖；打仗出征前到神庙占卜；生不出孩子去求送子观音。虽然未必有用，但至少有路可走，内心是安稳的。这些冥冥之中难以言说的神秘事物，组成了古代精神极为重要的一部分，让人类与整个宇宙紧密连结成一个整体，构成宇宙秩序（consmos）。古代人从这种秩序中确立了生存的意义。</p><p>而祛魅则意味着用理性的力量驱散了神秘的魅惑，作为一种理性化的取向，祛魅所要考问的是所有超验的、神秘的东西，这个逻辑链条一旦展开，就不会停止。因此祛魅除了要祛除迷信，还要祛除宗教。而当尼采喊出“上帝死了”的时候，这个祛魅的挑战也就算基本完成了。</p><p>自然世界客观化了，不再具有神性和灵性的世界，变成了用冷冰冰的因果规律解释的物理世界。</p><blockquote><p>我们的时代，是一个理性化、理知化，尤其是将世界之迷魅加以祛除的时代；我们这个时代的宿命，便是一切终极而最崇高的价值，已自公共领域隐没。    —— 韦伯《学术作为一种志业》</p></blockquote><p>失去了神的默认选项，对人类意味着什么？也许这意味着到了现代社会，一个人从“母体”中剥离出来，从此要孤独地、无依无靠地存活在这个世界上。这在一定程度上解释了当代年轻人的孤独。</p><p>关于韦伯所讲的祛魅，我们还要关注的一点是，它并不带有好坏值评判的色彩，充其量只是一个对客观事实的描述：一方面，祛魅让人的精神格外“荒凉”，理性主义的科学并不能为生命的意义提供新的根本依据；另一方面，祛魅只是现代的真相，无论你是否喜欢，它都作为现代的特性不能被消除，我们所要做的只是要直面这个真相。</p><p>那么，清醒后的现代人又该如何重建终极价值和生命的意义？祛魅的额世界如何才能不成为荒凉的世界？科学和理性能帮我们做什么呢？这这就牵扯了“诸神之争”。</p><h2 id="诸神之争——事实判断和价值判断"><a href="#诸神之争——事实判断和价值判断" class="headerlink" title="诸神之争——事实判断和价值判断"></a>诸神之争——事实判断和价值判断</h2><p>想回答上面的问题，需要引入两个概念：「事实判断」和「价值判断」。「事实判断」对应的是「是然」，它具有统一的标准；而「价值判断」对应的是「应然」，所依据的是个人形成的一套价值标准，会产生多元化。「价值多元化」让个体获得了更多的自由，但又可能是另一种“困境”。</p><p>从个人层面来说，每个人的人生选择都可能有自己的主观理由，却没有一个公认的共同理由。因此很多问题我们并不能给出确定无疑的答案，就如同糟糕的并不一定是我们没有充分依据的选择，而是即便我们选了也永远不知道选得对不对。</p><blockquote><p>人是悬挂在自己编织的意义之网上的动物。    —— 韦伯</p></blockquote><p>从社会层面来说，公共生活中许多激烈对立的议题本质上是价值观之间的冲突。我们不难联想到当下被推向舆论风口浪尖的议题，但我想说的是，这些在部分人眼中的所谓的应然的价值判断，除了能说明个人的基本权利，其他什么都改变不了，任何所谓的重新审视某些问题从来和历史发展的必然性没有直接联系，如果一个事情从根本上得到了改变，那必然是社会秩序发生了新一轮进化的结果。</p><p>对此，韦伯对这场“诸神之争”的态度是：“对待生活的各种可能的终极态度，是互不相容的，因此它们之间的斗争，也是不会有结论的。”</p><blockquote><p>个人必须决定，在他自己看来，哪一个是上帝，哪一个是魔鬼。  —— 韦伯</p></blockquote><p>韦伯带给我们的启示是，坦然面对这种困境，与此共存，也许是智性成熟的一种标志。</p><h2 id="现代铁笼"><a href="#现代铁笼" class="headerlink" title="现代铁笼"></a>现代铁笼</h2><h3 id="先破后立，立了什么"><a href="#先破后立，立了什么" class="headerlink" title="先破后立，立了什么"></a>先破后立，立了什么</h3><p>如果说现代社会是对古代社会的“先破后立”，我们已经讨论了“破”的是什么，那接下来我们再来聊聊又“立”了什么。</p><p>说起这个我们还要回到「事实判断」这个问题上，因为它才给我们提供了一套统一的标准。如果让你来说一下在当今社会，有哪样一种东西可以最替代或者说最接近曾经的上帝或神灵，我想我们的回答都会是一个：金钱。对于金钱的态度，现代人的态度似乎确实高度一致。</p><blockquote><p>金钱有一点像上帝，上帝对所有人一视同仁，每个人都可以用上帝的名义做自己的事情。    —— 齐美尔</p></blockquote><h3 id="工具理性带来的问题是什么？"><a href="#工具理性带来的问题是什么？" class="headerlink" title="工具理性带来的问题是什么？"></a>工具理性带来的问题是什么？</h3><p>为了更好的理解金钱，形成我们个人的价值观，有必要引出韦伯提到了一个重要概念——“工具理性”。韦伯认为，人类的理性可以区分成两种不同类型，工具理性和价值理性。</p><p>工具理性即做事的手段，它不关心目的，只关心达成目的的手段是否最优。而价值理性是说我需要决定到底要不要做这件事。</p><p>这就意味着很明显的几种特质：手段的价值更容易“计算”，选择的价值更难于“计算”；工具理性问题有客观标准，更容易达成一致，而价值理性标准不一，很难找到确定的答案。而这，也就导致了在现代化过程中，工具理性大行其道，压倒了价值理性。</p><p>社会的理性化发展，变成来工具理性的单方面扩张，理性化变成来不平衡的“片面的理性化”。在实践中，表现为<strong>对手段的追求压倒了对目的的追求</strong>。这种后果对个人层面和社会层面都是如此。</p><p>一个显著的后果就是社会制度的官僚化。官僚制最典型的体现就是行政管理系统，它的特点是有一个登记严密的上下结构关系，整个系统都有明确的分工，每个人都要按流程规矩办事；它的本质其实是最大化工具理性的生产效率；虽然你的主观感受是官僚制度繁文缛节、办事拖沓、效率低下，但这并不是它的必然结果。反而，事实正好相反，对个人来说，这可能是僵硬、机械的，但个人体验和全局效益不同，个人体验不佳恰恰是系统追求高效的结果。这种“非个人化”（impersonal）的好处是，无法被计算的复杂个人变成来可以计算的数据。而事实上，绩效制（meritocracy）就是这么来的。</p><p>“非个人化”使得在公司内部，人被看成是“机器的零件”，而不光是公司内部，现代社会也成了一条“流水线”，社会上的任何一个部门都是这个自我循环的流水线的一环。过去周而复始的循环历史观破碎了，现在周而复始的生产方式又建立了。韦伯把这种特征概括为“铁笼”。</p><p>铁笼存在两个非常大的弊端，一个是片面的社会文化，诸如用利益计算解决道德问题的治标不治本等；还有一个是早就了片面的社会关系：人与人、人与组织之间逐渐变成了一种商业的“供求关系”。</p><p>身处这个铁笼之中，即使有丰富的只是，成了专家，也不过是一种高级的零件罢了，本质上，没有任何区别。而所谓的“社会核心竞争力”也并没有真正意义上的人格的自主性，因为有一个摆在我们每个人眼前的迫切任务：<strong>满足社会机器对一个零件的要求</strong>。我们在竞争激烈的内卷中成为一个优质的、合格的零件。这也许就是铁笼这个比喻所蕴含的深意：人类作为“万物的灵长”，那些生命和灵性发展的需求被忽视和淹没了。</p><blockquote><p>专家没有灵魂。    —— 韦伯</p></blockquote><h3 id="铁笼可以被打破吗"><a href="#铁笼可以被打破吗" class="headerlink" title="铁笼可以被打破吗"></a>铁笼可以被打破吗</h3><p>既然我们已经知道了现代社会变成了一个铁笼，有这么大的弊端，那是不是打破这个铁笼就可以了呢？</p><p>也没有那么简单。因为铁笼一方面囚禁了人的灵性，另一方面也保护了我们。科技的进步确实有效地解决了困扰人类数千年的问题：贫困、奴役、疾病，等等。</p><p>历史的车轮还要继续前进，没有谁可以阻挡。</p><h3 id="我们可以做些什么"><a href="#我们可以做些什么" class="headerlink" title="我们可以做些什么"></a>我们可以做些什么</h3><p>现在的一种流行说法是：先实现财富自由，再去追求诗和远方。但在实现财务自由的过程中，我们自身也会被过程本身塑造，最后我们可能变得只会赚钱。赚钱本来是一种手段，但为了找到实现目标的最优手段花费了我们太多的时间和精力，陷的太深，以至于忽视了，甚至放弃了最初的目标。所谓的不忘初心，莫过于此。</p><p>前面我们引用了齐美尔的那句话，“金钱有点像上帝”，但其实他还有另外一句话：</p><blockquote><p>金钱只是通向最终价值的桥梁，而人是无法栖息在桥上的。  —— 齐美尔</p></blockquote><p>在这座桥上，我们真的能找到安身立命的根本，找到生命的意义吗？这个问题只能留给你自己。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>反观自己，如果专业技术水平没有办法做到专家，那未尝不是一件高兴的事，起码有更多时间精力追求自身的价值判断。</p><p>尽早地规律作息、加强锻炼可以延寿，而延寿是为了可以增加追求自己内心价值的事情的时间。同样地，如果注定要卷入现代社会的疯狂内卷中，那每天除了“996”地追求金钱这个统一的价值标准，也要预留出固定的时间去迎合内心的价值判断，做自己喜欢的事。</p><p>总之，不忘初心，做一个完整的人。</p>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>第一章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《刘擎西方现代思想讲义》｜古今之变</title>
    <link href="/2021/04/30/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E5%8F%A4%E4%BB%8A%E4%B9%8B%E5%8F%98/"/>
    <url>/2021/04/30/thought/%E3%80%8A%E5%88%98%E6%93%8E%E8%A5%BF%E6%96%B9%E7%8E%B0%E4%BB%A3%E6%80%9D%E6%83%B3%E8%AE%B2%E4%B9%89%E3%80%8B%EF%BD%9C%E5%8F%A4%E4%BB%8A%E4%B9%8B%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>历史上是否任何一个时代都可以自称为现代？如果不是，我们所处在时代和以往相比又有哪些不同？启蒙理性主义是如何影响现代社会秩序的建立的？我们又该如何审视当下人们口中频繁讲出的「我喜欢」和「我愿意」？</p><p>在阅读前言和导论的时候，我重点提取了所谓的「现代」的含义，如何从历史的发展来看待「古今之变革」以及具体「变在哪」。</p><p>这样做的一个好处是让我们对现代社会所捕捉的现象，衍生的问题更加敏感。我认为，保持敏感是适时作出合理应对的良好前提。</p><h2 id="现代和现代性"><a href="#现代和现代性" class="headerlink" title="现代和现代性"></a>现代和现代性</h2><p>历史上任何一个时期都有自己“当下的时代”，但并非每一个时期能可以自称为“现代”。</p><p>古人的历史观在学术界被称为“<strong>循环历史观</strong>”，即人们感知到的时间是在不断循环的：日升日落，四季轮回。但直到文艺复兴，这种“循环历史观”才发生改变。人们逐渐意识到，“当下的时代”不再是以往的延续和重复，而是前所未有的，是崭新的。时间不再是循环往复的，而是线性展开的——从过去、到现在，然后通往未来，时间成为一个有方向的适量概念。</p><p>这种时间观念带来几种重要变化：</p><ol><li>我们不能完全依靠传统习俗引导现代生活；</li><li>“线性进步的历史观”让人们认为社会具有不断进步的可能性，即当下及未来比过去更重要；</li><li>人类从循环历史宿命的束缚中解放，成为有自由的、有目的的创造者，成为主宰自己命运的主体。</li></ol><p>现代意味着重大变革，现代也可以被称之为“古今之变”。</p><blockquote><p>一切固定的东西都烟消云散了，一切神圣的东西都被亵渎了。    —— 《共产党宣言》</p></blockquote><p>其中，引发现代变革的动力是“启蒙理性主义”，而“古今之变”催生的产物则是现代社会和现代人。而“现代性”则是现代产物所具有的特点。</p><p>所谓的“启蒙理性主义”是说，直到欧洲的启蒙时代，西方社会才把理性推到了至高无上的地位，理性成为划分“光明”和“黑暗”的决定性标准。而在此之前，理性和信念、情感、感受、直觉、冥想、猜测、灵感等处于平衡之中，都作为人的各种能力而存在。</p><p>启蒙思想的原型起源于古希腊的“洞穴寓言”<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="“洞穴寓言”是柏拉图在《理想国》中提到的，它是说，从小就被禁锢在黑暗中的奴隶，有一天终于走出了洞穴，第一次看到了太阳，才知道洞穴中的一切原来只是虚假的幻象，阳光照耀下的世界才是真实的。太阳代表了理性，让人发现了最高的真善美。">[1]</span></a></sup>。</p><blockquote><p>只有经得住理性的自由、公开检查的东西才能博得理性的尊敬。  —— 康德</p></blockquote><p>启蒙理性主义作为西方古今之变的核心，让理性成为区分真理与蒙昧的决定性标准，成为了衡量一切的准绳。</p><h2 id="“古今之变”变在哪"><a href="#“古今之变”变在哪" class="headerlink" title="“古今之变”变在哪"></a>“古今之变”变在哪</h2><h3 id="个体主观价值的提升"><a href="#个体主观价值的提升" class="headerlink" title="个体主观价值的提升"></a>个体主观价值的提升</h3><p>现代出现了一个新的、关键的问题，即我喜不喜欢，我愿不愿意。</p><p>以前我们说喜欢一件事物总要说些理由出来，只有讲出个一二三来，才能有人信服。但现在问题变得简单多了，基本上说一句“我喜欢”就够了。一方面，“我喜欢”包含了对个人的尊重，对个人的尊重是个人解放的前提，是打破旧有等级体系的力量，是民主化的基础；但另一方面，这种现象又会让人困惑：无论多么伟大、崇高、优美的东西，只要一句“我不在乎”，好像就能否定它的价值。在和别人讨论问题的时候，有些话题只要你说“我喜欢”“我愿意”，对方似乎就无法反驳了。这种轻率和傲慢在过去是不可想象的。</p><p>如果我们做出选择的最高基准是主观意愿的话，“选择”就成了孤证。除了“我的意愿”，不存在任何同等有力的旁证。选择变得脆弱、不稳定。我们可能自己都无法坚信自己的选择。于是，我们一方面处在解放的轻松与兴奋当中，另一方面又处在不确定的、没有把握的焦虑当中；一面习惯于“轻率的傲慢”，一面又常常感到惶恐和不安。</p><h3 id="自然秩序被理性打破"><a href="#自然秩序被理性打破" class="headerlink" title="自然秩序被理性打破"></a>自然秩序被理性打破</h3><p>古代人只遵循一个准则，或者是上帝，或者是传统的教化。而现代人大都“我命由我不由天”。我们抛弃了自然秩序这个神话，得到了自由，代价是：在价值与价值之间很难区分高低优劣，每一种价值都有自己的道理，彼此冲突的观念，谁也说服不了谁。</p><p>共同的神话束缚了我们，却也让我们有了共同的准则。摆脱这个神话之后，我们有了自由，却又陷入混乱和茫然之中。</p><h3 id="新秩序的建立"><a href="#新秩序的建立" class="headerlink" title="新秩序的建立"></a>新秩序的建立</h3><p>在古代，春节是传统，春运不是。但在现代，随着大量人口流动，春运成为了一种新传统。此新秩序的建立本质是因为现代化改变了我们的社会生产和组织方式。</p><h2 id="“古今之变”后的两个观念转变"><a href="#“古今之变”后的两个观念转变" class="headerlink" title="“古今之变”后的两个观念转变"></a>“古今之变”后的两个观念转变</h2><p>一个是“人类中心主义的转变”，另一个是“个人主义的转变”。</p><p>书中关于后者有一个解释比较有意思。在现代社会，大量的人口流动使越来越多的人背井离乡工作和生活。于是，那种无法离开的“血肉相连”的有机共同体变成了一个神话，只有你和你自己才是血肉相连的。这个时候由社群过渡到个人的重要性和优先性就突显出来了。这就是所谓的“个人主义的转向”。</p><p>这种转向带来了传统社会难以想象的个人自由，生活变得多样而丰富，这是现代性的主要成就。但代价是，因为个人失去了与一个特定群体的久远、厚重和牢固的纽带关系，这带来了孤独感、漂泊感和乡愁。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>古今之变的最主要的特征就是从原来的“自然的”变成了“不自然”。</p><p>在现代秩序下，我们要面对两个难题。</p><p>一个与个人生活意义相关。我们不再相信神和传统，那我们的信仰该是什么呢？我们活着的意义是什么呢？如果用理性作答将是十分艰难的。如何找到生活的意义和理由，这是一个难题。</p><p>另一个与社会秩序相关。在以理性为基础的新秩序中，人人自由平等，那最终究竟由谁来统治谁？社会秩序就建立在我们对于这类问题的回答中。</p><p>最后，为了回答这些问题，我们需要拜访一些现代的哲学家、思想家。第一位是马克思·韦伯，因为在作者看来，他的思考标志着现代思想的成年。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>“洞穴寓言”是柏拉图在《理想国》中提到的，它是说，从小就被禁锢在黑暗中的奴隶，有一天终于走出了洞穴，第一次看到了太阳，才知道洞穴中的一切原来只是虚假的幻象，阳光照耀下的世界才是真实的。太阳代表了理性，让人发现了最高的真善美。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>前言</tag>
      
      <tag>导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《十三邀x微信十年》｜如何成为更好的自己</title>
    <link href="/2021/04/28/thought/%E3%80%8A%E5%8D%81%E4%B8%89%E9%82%80x%E5%BE%AE%E4%BF%A1%E5%8D%81%E5%B9%B4%E3%80%8B%EF%BD%9C%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
    <url>/2021/04/28/thought/%E3%80%8A%E5%8D%81%E4%B8%89%E9%82%80x%E5%BE%AE%E4%BF%A1%E5%8D%81%E5%B9%B4%E3%80%8B%EF%BD%9C%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>在短平快的时代里，做一个清醒的现代人，能够自觉，能够掌握自己的生活，这是非常困难的。在这个意义上，如果你能够完成，这将是一个非常光荣的使命。</p><h2 id="语录摘记"><a href="#语录摘记" class="headerlink" title="语录摘记"></a>语录摘记</h2><h3 id="以下是刘擎的语录摘记："><a href="#以下是刘擎的语录摘记：" class="headerlink" title="以下是刘擎的语录摘记："></a>以下是刘擎的语录摘记：</h3><p>微信它是具有反讽的双重性的。</p><p>一方面它是便捷的，丰富的，开放的，自由的，带给我们全新的美妙的体验。</p><p>但另一方面当我们不具有反思性的，依靠本能的愿望使用它的时候，它在便捷当中会带来轻率，在丰富当中会带来另外一种贫乏，在开放当中可能会固化我们已有的见解——变得封闭、部落化、有偏见，而在自由当中我们可能会变得放纵变得失控。</p><p>微信改变了人的存在论的环境，这样就导致了成年人的童稚化。童稚化的一个标志就是我们不太能够延迟满足。</p><p><strong>真正的自由是自己能够把握自己，引导自己，而且向着更好的自我成长。</strong></p><p><strong>更好的自己意味着你能够通过理性的自我掌控变成了一个自己更喜欢的人，你能够讲好一个关于自己的故事。</strong></p><p>如果你是一个沉湎的、失控的、放纵的自己，你讲不好自己的故事，你会讲一堆纷乱的事情，但是你没有办法理解自我，把你自己组织起来整合成一个发展的成长的线索。</p><p>那个更好的自己，它是需要努力的，是需要克制的，需要来辨析自己，需要用理性来主导自己：你必须要来判断这些事情你收到的赞美是你需要的还是不需要的，你必须区分真正的骄傲和虚荣在哪里，真实受到的夸赞和点赞在哪里。那个反思的自我，那个反思的时刻的引入是非常重要的，但是是缺失的。</p><p>所以做一个清醒的现代人，能够自觉，能够掌握自己的生活，这是非常困难的。在这个意义上，如果你能够完成，这将是一个非常光荣的使命。</p><h3 id="以下是许知远的语录摘记："><a href="#以下是许知远的语录摘记：" class="headerlink" title="以下是许知远的语录摘记："></a>以下是许知远的语录摘记：</h3><p>怎么理解一个新技术在自己既有的土壤中生长？</p><p>我们对这件事情没有进行一个深入的讨论和言说，因此会很容易掉入一个非常二元化的思维窠臼：它是不是破坏了我们过去的东西？它是不是丢失了很多缓慢的情感？它是不是使我们思考不再具有深度？</p><p>我们非常容易陷入一种很简化的判断，过去和现在，过去和未来，正面和反面。但事物的发展却不是这样的，<strong>它们永远都在过去之中就孕育着未来，在新生之中就会孕育着腐朽，在腐朽之中又会产生新的可能性。</strong>所有的事物都是这样进行的。</p><p>事实上我们在过去的思考也不见得就有深度，我们也未必一定会移向一个更美好的未来。微信只是做出了一种新的回应方式，现阶段我们正处在迁移过程的挣扎之中。但是我们一定会在这种过程中学会新的游泳的方式的，只是在这个过程中，我们需要邀请更多的人加入去理解这个新事物，这种智识上的回应是非常必要的。</p><h2 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h2><p>在短平快的时代下，我们大多数人都能够保持警惕，但在警惕之下，做一个清醒的人还要保持反思和专注。关于这一点，我反思了自己的不足。</p><p>我自认自己是个相对自律的人，一个好的习惯让我的自我反思过程和有效专注时间的下限是要比同龄人高的。但我不得不进一步反思的是：这样的自律究竟只是出于一种习惯的养成，还是通过真正的哲学反思来主动获取的。</p><p>前者很可能是以牺牲其他娱乐活动为代价，事实上我并不讨厌娱乐活动，我只是讨厌自己在进行一个事先并未赋予其意义与价值的娱乐活动。我也很难轻易地给他人的娱乐活动点赞，因为只有当我能够感受到这件事对ta究竟具有怎样的意义的时候，我才能把自己的点赞和夸赞视为等同。</p><p>进而我把自己的不足推向了“如何成为更好的自己”的问题上。</p><p>正如刘擎教授所说的：<strong>“更好的自己意味着你能够通过理性的自我掌控变成了一个自己更喜欢的人，你能够讲好一个关于自己的故事。”</strong>我觉得我对自己的掌控还不够理性，很多时候只是出于一种直觉。当然，如果按照认识论说的“一切理性都是由感性产生的”的那样，我只有将自己的直觉一步步抽离出一个个抽象的层次，然后清晰自己的认识和表达，才能算作崇高的理性。因此，我并没有很好的自我掌控自己。</p><p>另外一个问题，我能否讲好一个自己的故事，我认为完全没有。我对问题还停留在纷乱的、不清晰的表述层面上，甚至我对自己故事的表达也是如此。当然，这也部分解释了我喜欢哲学的原因，出于一种天然的欣赏（从相对更加故事性、平叙地讲述，我更容易被深刻的、清晰的、简洁的、甚至有点抽象难以理解的表达所吸引来说），还有我对它的需要（指我对自我及世界的本质的认识）。</p><p>我已经逐渐意识到了问题的所在，也在这个过程中更加清晰了喜欢的自己应有的模样。即便这一切才刚刚开始，但直觉告诉我，一切都还来得及。</p>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《作为意志和表象的世界》｜读书笔记</title>
    <link href="/2021/04/26/thought/%E3%80%8A%E4%BD%9C%E4%B8%BA%E6%84%8F%E5%BF%97%E5%92%8C%E8%A1%A8%E8%B1%A1%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/04/26/thought/%E3%80%8A%E4%BD%9C%E4%B8%BA%E6%84%8F%E5%BF%97%E5%92%8C%E8%A1%A8%E8%B1%A1%E7%9A%84%E4%B8%96%E7%95%8C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在过去的几年时间里，我大部分的时间都是用来学习和理解这个世界上早有人创造出来的东西。</p><p>可能也是伴随着对自身天赋的逐渐意识，我对自己的人生定位开始变成了通过不断的学习和理解，试图更深刻地认识自己以及认识这个世界，同时，对那些天赋异禀，能够改变时代改变世界，甚至思想可以领先所处时代数十年百年的人，表示无比的欣赏和羡慕。</p><p>当然，叔本华就是这样的人。</p><blockquote><p>“人存在于这个世界上，最大的问题是认识本质，包括自我和世界的本质。”</p></blockquote><h2 id="对序言的概括"><a href="#对序言的概括" class="headerlink" title="对序言的概括"></a>对序言的概括</h2><p>在该书的序中，叔本华除了提出了几点阅读建议和要求，以及对版本之间的修调加以说明外，还描述了自己所处时代背景下的哲学现状，和自己所追求的哲学。</p><p>在第一版序言的开篇，作者就说明了这本书在解决什么问题：</p><blockquote><p>这本书所要表达的思想是长久以来哲学家们苦苦探求的东西。伟大的哲学家们用思想照亮前进的道路，遗憾的是，他们仍未找到他们一心想要得到的东西。这种历经努力而没有回报的经历让拥有历史素养的人们感到无望。普林尼说过：“直至成为事实之前，多少事不都是人们认为不可能的吗？”他们都直接放弃寻觅，觉得这一切都是虚妄，就像石头终究不能变成金子，世上不可能有长生仙药一样。</p></blockquote><p>在序中，作者也给出了对读者的三点阅读要求，不要因为深究一个具体的细节而忽略本书的主干思想，要系统整体地看待本书的全部论证程序。本书行文逻辑层层递进，前一章节皆可看作后面章节论调基于的前提，章节内也联系紧密，前后照应。同时，要把本书的序读完（虽然如果一上来就不读序的读者也不会看到这句话哈哈）。在阅读本书前，还要先阅读康德的经世名作《纯粹理性批判》和叔本华的博士论文《充分理由律的四重根》，本书第一部分是对那片博士论文的继承，以及在作者看来康德的某些不正确思想的批评和指正。事实上，在那篇博士论文的开篇，叔本华就对柏拉图和康德盛赞一番，他将柏拉图奉若神明，视康德为一个奇迹，对这两人的思想相当崇敬。</p><blockquote><p>“神圣的柏拉图和惊人的康德同声高呼, 向世人介绍一个法则, 说这个法则可以作为所有哲学探索也可以作为所有其他科学的方法1。他们告诉我们,有两个准则应一视同仁,绝不可厚此薄彼。它们是：统一律和分解律。”   ——《充分理由律的四重根》</p></blockquote><p>但叔本华十分厌恶后来费希特、黑格尔代表的思辨哲学，这集中体现在第二版的序中，他认为哲学成为了一种政治目的和个人目的，很多人为了自己真实的俗世的背后目的宣扬一种他们彼此之间心照不宣的言论，然后将其视为哲学误导大众。对于纯粹的真理他们视若不见，而且也并不想经受追求和发现真理过程中所经历的感受的苦楚，他们只是把哲学当成一种达成自己动机的工具。</p><p>叔本华建议读者在阅读康德经典著作的时候一定要看原著，而不是去看一些经由他人理解而“分泌”<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="“分泌”这个词，最早来自歌德的一种形容，它指“对有意义或者重要的东西的侵蚀”。">[1]</span></a></sup>的产物。他的原话是这样说的：</p><blockquote><p>想要真正地了解哲学，最有效的方式便是在创造者的原著中感受寻找，真正的哲学家原著中所提供的学说比那些经过庸人头脑专属出来的报告更有价值。</p></blockquote><p>以上是我抽取出来的主干层次，当然我建议大家最好都要读一下这些序。单纯是序言，就已经很让我兴奋不已了。</p><p>好了，最后让我们再来总结一下作者提出的三点要求：</p><ol><li>不要因为深究一个具体的细节而忽略本书的主干思想；</li><li>把读完序论作为开始阅读这本书的前提；</li><li>对作者博士论文《充分根据律的四重根——一篇哲学论文》和康德的《纯粹理性批判》有一个大致的了解。</li></ol><h2 id="对充足理由律的四重根的概括"><a href="#对充足理由律的四重根的概括" class="headerlink" title="对充足理由律的四重根的概括"></a>对充足理由律的四重根的概括</h2><h3 id="充足理由律"><a href="#充足理由律" class="headerlink" title="充足理由律"></a>充足理由律</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%85%85%E8%B6%B3%E7%90%86%E7%94%B1%E5%BE%8B">充足理由律</a>可以被概括地表达为：“任何事物都有它之所以如此的理由，或者说任何事物皆可被解释”。</p><p>叔本华首先对充足理由律的本质作出了描述，他说在他之前这条定律的被不明其理的人们滥用了，从而常常使人陷入谬误和混乱。在他看来，充足理由律的两种基本性质被混淆了，一是将它用于判断，即判断为真的理由，其次是将它用于对象的变化，即事物变化的原因，这两者实质上是不同的。事实上，叔本华认为充足理由律有四种不同的意义，即一切表象都可以从四个层次上进行解释，从而将这四种意义比喻为“四重根”。</p><p>充足理由律在叔本华那里具有一种先验的地位，即它是不能证明的。叔本华认为康德等人试图证明它是徒劳无功的，因为为了证明一个特定命题，就必须假定一个给它正确的理由，而这个理由却正是充足理由律。为了证明它，就必须假定它成立，所以证明这个命题将陷入不可避免的循环论证。他的这种思想在一定程度上影响了维特根斯坦。此外叔本华将充足理由律和<a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%9F%9B%E7%9B%BE%E5%BE%8B">无矛盾律</a>、<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E4%B8%80%E5%BE%8B">同一律</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E4%B8%AD%E5%BE%8B">排中律</a>并列，把它看成第四个思维规律。</p><h3 id="四重根"><a href="#四重根" class="headerlink" title="四重根"></a>四重根</h3><p>叔本华认为充足理由律的四种不同表现形式分别是：因果律，逻辑推论，数学证明，行为动机。这四种形式并不作为证明充足理由律的原因，而是充足理由律在这四者中表现其自身。</p><p>叔本华认为因果律只作用于表象之间而和物自体没有丝毫联系，而且一切表象间都受到因果律影响，任何事物的变化都有其先前的一个原因。像上帝这样一个不动的动者或者不存在的东西进入存在被叔本华认为是绝对不可能的。基于这个立场，<strong>叔本华既是个坚定的无神论者又是一个完全的宿命论者</strong>。</p><p>逻辑真理的成立必然存在一个先验的、在它之前的真理，这是充足理由律的表现形式的第二个形式。叔本华将引导至真理的途径分为逻辑的，经验的，先验的，超验的。这四种理由和根据证明真理本身的同时也表现了充足理由律。<br>因果律中的表象被认为是时间和空间中纯粹直观的表象，而时间和空间本身是在对表象观察中被感性地连续知觉到的表象，两者间的本质区别是物质。这里叔本华沿用了康德的看法，时间和空间分别对应于数学和几何。时空中的表象是数学证明的前提而不是它可证明的依据。</p><p>人的行为动机被叔本华认为是充足理由律第四种形式。也就是说，人的每一个行为必有其动机上的原因，并从动机上得到解释。事实上这一看法引出了他的另一部著作《作为意志和表象的世界》，也奠定了它的伦理学说。</p><h2 id="批判康德哲学"><a href="#批判康德哲学" class="headerlink" title="批判康德哲学"></a>批判康德哲学</h2><p>叔本华对康德是充满赞美之情的。在对康德哲学批判的附录标题上，他引用了伏尔泰的话：<em>“真正的天才可以犯错而不受责难，这是他们的特权”</em>。</p><p>叔本华认为康德的最大功绩不是他的认识论，而在于他划分了表象和物自体之间的区别。他认为康德错误地假定知觉包括想象，将直观和思维混淆起来。康德构造了将感性直观和知性十二范畴共同构成经验对象的理论。叔本华发现若按照这种理论，表象世界就成了既是直观又是思维，既非直观又非思维的东西。而且这样一来动物要么就具有思维，要么就连外在世界的表象也没有了，这显然是不合情理的。</p><p>在康德那里，因果律是先验的，所有的经验知觉都是处于主观之上，不可能区别或认识物自体。而叔本华认为仅用直观我们就能获得经验对象。关于物自体的知识，是通过理智这种内在感觉而获得的，它只在时间的形式中被认识。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>叔本华为这部悲观主义巨著作出了乐观的预言：这部书不是为了转瞬即逝的年代而是为了全人类而写的。</p><p>的确如此，我早已兴奋不已，准备开始阅读这部超越时代，并且成为整个人类文明经典的著作了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%9B%BE%E5%B0%94%C2%B7%E5%8F%94%E6%9C%AC%E5%8D%8E">维基百科</a></li><li>《充分理由律的四重根》</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>“分泌”这个词，最早来自歌德的一种形容，它指“对有意义或者重要的东西的侵蚀”。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>思想沉淀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界读书日的由来</title>
    <link href="/2021/04/23/info/%E4%B8%96%E7%95%8C%E8%AF%BB%E4%B9%A6%E6%97%A5%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <url>/2021/04/23/info/%E4%B8%96%E7%95%8C%E8%AF%BB%E4%B9%A6%E6%97%A5%E7%9A%84%E7%94%B1%E6%9D%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="美丽传说"><a href="#美丽传说" class="headerlink" title="美丽传说"></a>美丽传说</h2><p>世界读书日来源于一个骑士屠龙的悲壮故事。</p><p>在1700多年前的罗马帝国时代，有一个叫圣乔治的巴勒斯坦人，生于260年。他长大后加入了罗马军队，因为骁勇善战，屡立战功，成为一名罗马骑兵军官。</p><p>当时，欧洲有一个城堡，城堡堡主的女儿长得非常美丽，引来了恶龙的垂涎。恶龙威胁堡主，要他把女儿献给自己。圣乔治闻讯后，跨上战马，带着长枪前往城堡拯救堡主的女儿。到了城堡，圣乔治与恶龙进行了一番激烈的搏斗，最后，凭借自己的勇敢和指挥，杀死了这条祸害当地老百姓的恶龙，解救了堡主的女儿。恶龙流出的血在地上形成了一个十字形。</p><p>堡主的女儿为了表示感谢之情，送了圣乔治一本书。从此，书籍就成了胆识和力量的象征。</p><p>不过，圣乔治由于跟恶龙搏斗时耗费了所有的精力，筋疲力尽而亡，年仅43岁。这一年，是303年。</p><p>圣乔治死后700年，成了英格兰的守护圣人。</p><p>那是十字军第三次东征(1189—1192年)的事情了。英格兰国王理查一世成为十字军第三次东征的统帅。理查一世因勇猛善战而号称“狮心王理查”。他当了10年国王，期间不关心处理政务，而是将全部心思花在征战上。期间，理查一世在当年圣乔治屠龙附近的地方，与拥有优势兵力的敌人作战，在极度不利的情况下，终于扭转战局，击败了敌人，取得了胜利。</p><p>理查一世认为，这是圣乔治的神灵在保护英格兰，便将圣乔治封为英格兰的守护圣人，并将圣乔治死去的日子4月23日，作为“圣乔治日”。每到这一天，全国宣布放假，人们要向爱人送一支玫瑰，向孩子送一本书。</p><p>1277年，英格兰根据圣乔治屠龙时龙血的形状，设计出一款白底红十字的“圣乔治旗”，这就是后来的英格兰国旗。</p><p>圣乔治的故事，不但成为英格兰文化很重要的一部分，还在德国、格鲁吉亚、保加利亚、葡萄牙以及加泰罗尼亚等受英格兰文化影响的国家和地区流传。在15世纪之前，圣乔治日作为一个重要的节日，与圣诞节享受一样的待遇。只不过，后来圣乔治日逐渐被人们淡忘。</p><h2 id="灵感来自于西班牙浪漫传统"><a href="#灵感来自于西班牙浪漫传统" class="headerlink" title="灵感来自于西班牙浪漫传统"></a>灵感来自于西班牙浪漫传统</h2><p>选择4月23日的灵感来自于西班牙加泰罗尼亚地区的一个传统。1926年，当时的西班牙国王设立了“西班牙自由节”，并把伟大作家塞万提斯的生日10月7日作为这个节日的庆祝日。1930年庆祝活动移到4月23日——塞万提斯的忌日，这一天也是加泰罗尼亚大众节日“圣乔治节”（加泰罗尼亚一直在坚持圣乔治日）。相传勇士乔治屠龙救公主，并获得了回赠一本书册，象征着知识与力量。一些欧洲国家将这种传统延续至今。</p><p>加泰罗尼亚地区作为“读书日”缘起传说的发祥地有一个传统，你会看到很多人拿着玫瑰在街上走，像是情人节一样，十分有趣。妇女们就给丈夫或男朋友赠送一本书，男人们则回赠一支玫瑰花。如今每到4月23日这一天，当地的书籍会减价10%，玫瑰花的价格则陡然上涨。</p><h2 id="文学大师们的生日与忌日"><a href="#文学大师们的生日与忌日" class="headerlink" title="文学大师们的生日与忌日"></a>文学大师们的生日与忌日</h2><p>4月23日与世界上很多著名作家也有很大关系：它是莎士比亚出生和去世的日期，也是塞万提斯、西班牙游记作家何西·布拉、秘鲁文学家加尔西拉索去世的日子，还是纳博科夫、法国作家莫里斯·德鲁昂、冰岛诺贝尔文学奖获得者拉克斯内斯、哥伦比亚小说家曼努埃尔·梅希亚·巴列霍等人的生日。</p><h2 id="庆幸生在这一天"><a href="#庆幸生在这一天" class="headerlink" title="庆幸生在这一天"></a>庆幸生在这一天</h2><p>是的，很荣幸可以生在世界读书日这一天，与这么多伟大的思想家作家同一天。自打小时候有记忆以来，我从来都是对书有莫名好感的。自己喜欢书，也同样喜欢爱书的人。爱读书，谈吐举止中洋溢着书生气的人往往也会给我带来莫名的好感，与这些人的交流中，我往往能得到启发，或者产生强烈的共鸣。人的爱好可能不止一个，喜欢的人或事也不只一类，但于我而言，读书，读书之人，却几乎是我所有的喜欢里之最的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.guidaye.com/h/sj/512699.html">“4月23日世界读书日”的由来</a></li><li><a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E8%AF%BB%E4%B9%A6%E6%97%A5">百度百科</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>148. 排序链表</title>
    <link href="/2020/11/29/tech/leetcode/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/11/29/tech/leetcode/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h4><blockquote><p>还原成数组结构借助内部排序方法显然不是面试官所期待的解法；</p><p>链表结构中模拟快排显然很复杂，因此想能不能用归并；</p><p>很容易将问题拆解成：查找中间结点、分治母链表、合并两个链表的子问题；</p><p>问题的难点在于如何在merge后保持链表的完整性，因此需要注意以下几个细节：</p><ol><li>由于合并之后的链表的头结点可能和原head不一致，因此merge是有ListNode类型的返回值的；</li><li>merge所返回的是合并后的链表，而在mergeSort中，这相当于左右两个子链表；</li><li>为了使merge完全转化为合并两个链表的问题，要确保两个子链表的尾部都指向null，而具体的实现是将中间结点的next指向null；</li><li>递归的终止条件在于分治到只有一个结点的子链表，此时<code>mid = head; mid.next = null</code>，再进入下一层递归时要出来，显然终止条件应该是<code>head.next == null</code>，而返回的是<code>head</code>，<strong>不是</strong><code>null</code>；</li><li>合并链表的时候由于头结点要发生改变，因此最好的方式是建立一个哨兵；</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        ListNode res = mergeSort(head);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">mergeSort</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 注意递归终止条件！</span><br>        ListNode mid = midNode(head);<br>        ListNode p = head, q = mid.next;<br>        mid.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 链尾一定要断开！这样可以保证merge的两个链表的表尾都指向null；</span><br>        ListNode left = mergeSort(p);<br>        ListNode right = mergeSort(q);<br>        <span class="hljs-keyword">return</span> merge(left, right); <span class="hljs-comment">// 头结点要通过merge来返回！</span><br>    &#125;<br>    <span class="hljs-comment">// 合并两个有序链表（21. 合并两个有序链表）</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode p, ListNode q)</span> </span>&#123;<br>        ListNode sentry = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>); <span class="hljs-comment">// 一定要建一个哨兵！</span><br>        ListNode cur = sentry;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; q != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p.val &lt; q.val) &#123;<br>                cur.next = p;<br>                p = p.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur.next = q;<br>                q = q.next;<br>            &#125;<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) &#123;<br>            cur.next = q;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur.next = p;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sentry.next;<br>    &#125;<br>    <span class="hljs-comment">// 找到链表中间节点（876. 链表的中间结点）</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">midNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123; <span class="hljs-comment">// 用快慢指针找中间结点！</span><br>        ListNode slow = head;<br>        ListNode fast = head.next; <span class="hljs-comment">// 注意fast的初始值，这是为了mid能下取整</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>493. 翻转对</title>
    <link href="/2020/11/28/tech/leetcode/493-%E7%BF%BB%E8%BD%AC%E5%AF%B9/"/>
    <url>/2020/11/28/tech/leetcode/493-%E7%BF%BB%E8%BD%AC%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        mergeSort(nums, left, mid);<br>        mergeSort(nums, mid + <span class="hljs-number">1</span>, right);<br>        merge(nums, left, mid, right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = left;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>                <span class="hljs-keyword">while</span> (j &lt;= right &amp;&amp; (<span class="hljs-keyword">long</span>) nums[i] &gt; <span class="hljs-number">2</span> * (<span class="hljs-keyword">long</span>) nums[j]) &#123;<br>                    j++;<br>                &#125;<br>                count += j - mid - <span class="hljs-number">1</span>;<br>                i++;<br>            &#125;<br>        &#125;<br>        i = left; <br>        <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right - left + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(i &lt;= mid || j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; mid) &#123;<br>                arr[k++] = nums[j++];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; right) &#123;<br>                arr[k++] = nums[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>                    arr[k++] = nums[i++];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    arr[k++] = nums[j++];<br>                &#125;<br>            &#125;<br>        &#125;<br>        k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k &lt; arr.length) &#123;<br>            nums[left++] = arr[k++];<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-自动装箱&amp;拆箱</title>
    <link href="/2020/11/10/tech/JavaSE/Java-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-%E6%8B%86%E7%AE%B1/"/>
    <url>/2020/11/10/tech/JavaSE/Java-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-%E6%8B%86%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<ul><li>什么是自动装箱&amp;拆箱？</li></ul><p>Java中基础数据类型与它们的包装类进行运算时，编译器会<strong>自动</strong>帮我们进行转换，转换过程对程序员是透明的，这就是装箱和拆箱，</p><ul><li>什么时候会进行装箱&amp;拆箱？<ul><li>进行 = 赋值操作（装箱或拆箱）</li><li>进行+，-，*，/混合运算 （拆箱）</li><li>进行&gt;,&lt;,==比较运算（拆箱）</li><li>调用equals进行比较（装箱）</li><li>ArrayList,HashMap等集合类 添加基础类型数据时（装箱）</li></ul></li></ul><ul><li>一道面试题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAutoBox2</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">//1</span><br>     <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;<br>     Integer b = <span class="hljs-number">100</span>;<br>     System.out.println(a == b); <span class="hljs-comment">// true</span><br>     <br>     <span class="hljs-comment">//2</span><br>     Integer c = <span class="hljs-number">100</span>;<br>     Integer d = <span class="hljs-number">100</span>;<br>     System.out.println(c == d); <span class="hljs-comment">// true</span><br>     <br>     <span class="hljs-comment">//3   </span><br>     c = <span class="hljs-number">200</span>;<br>     d = <span class="hljs-number">200</span>;<br>     System.out.println(c == d); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><p>对于case1，就是正常的自动装箱；</p><p>对于case2 和case3，涉及到两个知识点：</p><ol><li>Integer声明的是一个对象，用==来比较两个对象其实是比较二者所指向的地址值是否相等；</li><li>创建Integer对象时并不是简单new一个，还会涉及到用IntegerCache做一个cache，而这个cache是可以设置的。</li></ol><p>一般缓存设置为-128 ～127范围内，如果初始化在这个区间，那么两个变量指向的会是同一个地址，否则要指向两块不同的存储区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>  <span class="hljs-keyword">static</span> &#123;<br>  <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>  String integerCacheHighPropValue =<br>          sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>  <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>         i = Math.max(i, <span class="hljs-number">127</span>);<br>         <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>         h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>         <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>       &#125;<br>     &#125;<br>     high = h;<br><br>     cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>     <span class="hljs-keyword">int</span> j = low;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>        cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br>  ....<br><br></code></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://juejin.im/post/6844903641220907016">5分钟彻底理解-Java自动装箱、拆箱</a>w</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>深入理解几个概念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java数组更改排序规则</title>
    <link href="/2020/11/10/tech/JavaSE/Java-%E9%87%8D%E5%86%99%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99/"/>
    <url>/2020/11/10/tech/JavaSE/Java-%E9%87%8D%E5%86%99%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h4 id="一维数组降序"><a href="#一维数组降序" class="headerlink" title="一维数组降序"></a>一维数组降序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;;<br>Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123; <span class="hljs-comment">// 使用泛型，整型数组需要是Integer封装类</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span> <span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o2 - o1;<br>    &#125;<br>&#125;);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; ++i) &#123;<br>    System.out.print(arr[i]);<br>    System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;;<br>Arrays.sort(arr, (o1, o2) -&gt; &#123;<span class="hljs-keyword">return</span> o2 - o1;&#125;); <span class="hljs-comment">// 使用lambda表达式</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; ++i) &#123;<br>    System.out.print(arr[i]);<br>    System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二维数组按指定列排序"><a href="#二维数组按指定列排序" class="headerlink" title="二维数组按指定列排序"></a>二维数组按指定列排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] nums = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>Arrays.sort(nums, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> arr1[<span class="hljs-number">1</span>] - arr2[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 指定第二列排序</span><br>    &#125;<br>&#125;);<br><span class="hljs-comment">// System.out.println(nums);</span><br><br><span class="hljs-keyword">int</span>[] order = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// 先按第1列排，再按第0列排，最后再按第2列排；</span><br><span class="hljs-keyword">int</span>[][] nums = &#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;&#125;;<br>Arrays.sort(nums, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; order.length; ++i) &#123;<br>            <span class="hljs-keyword">int</span> k = order[i];<br>            <span class="hljs-comment">// 经过测试如果没有这句话，只按order[0]排</span><br>            <span class="hljs-keyword">if</span> (arr1[k] == arr2[k]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 关键！！</span><br>            <span class="hljs-keyword">return</span> arr1[k] - arr2[k]; <span class="hljs-comment">// 升序</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">int</span>[] order = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 先按第1列降序排，再按第0列升序排</span><br><span class="hljs-keyword">int</span>[][] nums = &#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;&#125;;<br>Arrays.sort(nums, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr1, <span class="hljs-keyword">int</span>[] arr2)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; order.length; ++i) &#123;<br>            <span class="hljs-keyword">int</span> k = order[i];<br>            <span class="hljs-keyword">if</span> (arr1[k] == arr2[k]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 关键！！</span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> arr2[k] - arr1[k];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> arr1[k] - arr2[k];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// 输出测试</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums[<span class="hljs-number">0</span>].length; ++j) &#123;<br>        System.out.print(nums[i][j]);<br>        System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符串的排序"><a href="#字符串的排序" class="headerlink" title="字符串的排序"></a>字符串的排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;cab&quot;</span>;<br><span class="hljs-keyword">char</span>[] ch = s.toCharArray(); <span class="hljs-comment">// 通过转成char[]修改排序规则</span><br>Arrays.sort(ch);<br>s = String.valueOf(ch); <span class="hljs-comment">// 升序</span><br><br>Character[] Ch = <span class="hljs-keyword">new</span> Character[ch.length]; <span class="hljs-comment">// 如果要降序，需要构建Character封装</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ch.length; ++i) Ch[i] = ch[i];<br>Arrays.sort(Ch, <span class="hljs-keyword">new</span> Comparator&lt;Character&gt;() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Character c1, Character c2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> c2 - c1;<br>    &#125;<br>&#125;);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ch.length; ++i) ch[i] = Ch[i];<br>s = String.valueOf(Ch);<br>System.out.println(s);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>usage</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>31. 下一个排列</title>
    <link href="/2020/11/10/tech/leetcode/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2020/11/10/tech/leetcode/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：</p><ol><li><p>我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。</p></li><li><p>同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</p></li></ol><p>具体地，我们这样描述该算法，对于长度为 n 的排列 a：</p><ol><li><p>首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i] &lt; a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n)必然是下降序列。</p></li><li><p>如果找到了顺序对，那么在区间 [i+1,n)中从后向前查找第一个元素 jj满足 a[i] &lt; a[j]。这样「较大数」即为 a[j]。</p></li><li><p>交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</p></li></ol><p>如果在步骤 1 找不到顺序对，说明当前序列已经是一个降序序列，即最大的序列，我们直接跳过步骤 2 执行步骤 3，即可得到最小的升序序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> smallIndex = -<span class="hljs-number">1</span>, bigIndex = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">2</span>; i &gt; -<span class="hljs-number">1</span>; --i) &#123; <span class="hljs-comment">// 找较小</span><br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>                smallIndex = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (smallIndex == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 进行一个原数组为逆序的判断</span><br>            exchange(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">1</span>; i &gt; smallIndex; --i) &#123; <span class="hljs-comment">// 找较大</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[smallIndex]) &#123;<br>                bigIndex = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        swap(nums, smallIndex, bigIndex);<br>        smallIndex++; bigIndex = nums.length - <span class="hljs-number">1</span>;<br>        exchange(nums, smallIndex, bigIndex); <span class="hljs-comment">// 双指针反转子数组</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> smallIndex, <span class="hljs-keyword">int</span> bigIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre = nums[bigIndex];<br>        nums[bigIndex] = nums[smallIndex];<br>        nums[smallIndex] = pre;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exchange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> smallIndex, <span class="hljs-keyword">int</span> bigIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (smallIndex &lt; bigIndex) &#123;<br>            swap(nums, smallIndex, bigIndex);<br>            smallIndex++; bigIndex--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思考：如果这个题改成上一个排列，代码该怎么改？</p><p>很简单，先找一个较大值，再找一个较小值，交换完再逆序排列。此时，较大值的下标小于较小值下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> smallIndex = -<span class="hljs-number">1</span>, bigIndex = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">2</span>; i &gt; -<span class="hljs-number">1</span>; --i) &#123; <span class="hljs-comment">// 找较大</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>                bigIndex = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (bigIndex == nums.length - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 进行一个原数组为逆序的判断</span><br>            exchange(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">1</span>; i &gt; bigIndex; --i) &#123; <span class="hljs-comment">// 找较小</span><br>            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[bigIndex]) &#123;<br>                smallIndex = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        swap(nums, bigIndex, smallIndex);<br>        bigIndex++; smallIndex = nums.length - <span class="hljs-number">1</span>;<br>        exchange(nums, bigIndex, smallIndex); <span class="hljs-comment">// 双指针反转子数组</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> smallIndex, <span class="hljs-keyword">int</span> bigIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre = nums[bigIndex];<br>        nums[bigIndex] = nums[smallIndex];<br>        nums[smallIndex] = pre;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exchange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> smallIndex, <span class="hljs-keyword">int</span> bigIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (smallIndex &lt; bigIndex) &#123;<br>            swap(nums, smallIndex, bigIndex);<br>            smallIndex++; bigIndex--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>求数组第k大或前k大问题</title>
    <link href="/2020/11/09/tech/leetcode/%E6%B1%82%E6%95%B0%E7%BB%84%E7%AC%ACk%E5%A4%A7%E6%88%96%E5%89%8Dk%E5%A4%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/09/tech/leetcode/%E6%B1%82%E6%95%B0%E7%BB%84%E7%AC%ACk%E5%A4%A7%E6%88%96%E5%89%8Dk%E5%A4%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>想借用此类问题深入理解快排特性。先给结论，再具体展示。</p></blockquote><p>快排具有的特性：</p><ol><li>快排在每轮排完，能使pivot元素置于最终排序结果的位置上；</li><li>对于正序排序，每轮排完的pivot元素的左边的元素均小于pivot，位于pivot右边的元素均大于pivot。（逆序排序正好相反）</li><li>快速排序属于交换排序，交换排序除了快排还有冒泡排序，但是冒泡是稳定的排序算法，但<strong>快排是不稳定的</strong>！因此不能用原有的快排思想解决要求具有稳定特性的问题（如：有序的全排列问题）；</li></ol><p>这里有两点要说明：</p><ol><li>所谓稳定性是指：如果对于原无序数组有两个相同大小的值，排完序后，这两个元素的相对顺序没有发生改变，则该排序算法是稳定的；</li><li>还要说明的一点是，很多大厂（尤其是微软等外企）对于手写快排的要求是：还要加一些随机pivot的trick。而这实现起来，也无外乎是额外增加了三五行代码的事情（例题中有展现）。</li></ol><p>首先来看一下快排算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span>(<span class="hljs-params">nums, reverse=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">if</span> reverse == <span class="hljs-literal">False</span>:<br>        quick_sort_recursion(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        quick_sort_reverse_recursion(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort_recursion</span>(<span class="hljs-params">nums, left, right</span>):</span><br>    <span class="hljs-keyword">if</span> left &gt;= right: <span class="hljs-keyword">return</span> <br>    pivot_loc = partition(nums, left, right)<br>    quick_sort_recursion(nums, left, pivot_loc-<span class="hljs-number">1</span>)<br>    quick_sort_recursion(nums, pivot_loc+<span class="hljs-number">1</span>, right)<br><br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span>(<span class="hljs-params">nums, left, right</span>):</span><br>    pivot = nums[left]<br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[right] &gt;= pivot:<br>            right -= <span class="hljs-number">1</span><br>        nums[left] = nums[right]<br>        <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[left] &lt;= pivot:<br>            left += <span class="hljs-number">1</span><br>        nums[right] = nums[left]<br>    nums[left] = pivot <br>    <span class="hljs-keyword">return</span> left <br>    <br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort_reverse_recursion</span>(<span class="hljs-params">nums, left, right</span>):</span><br>    <span class="hljs-keyword">if</span> left &gt;= right: <span class="hljs-keyword">return</span> <br>    pivot_loc = partition_reverse(nums, left, right)<br>    quick_sort_reverse_recursion(nums, left, pivot_loc-<span class="hljs-number">1</span>)<br>    quick_sort_reverse_recursion(nums, pivot_loc+<span class="hljs-number">1</span>, right)<br>      <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition_reverse</span>(<span class="hljs-params">nums, left, right</span>):</span><br>    pivot = nums[left]<br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[right] &lt;= pivot:<br>            right -= <span class="hljs-number">1</span><br>        nums[left] = nums[right]<br>        <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[left] &gt;= pivot:<br>            left += <span class="hljs-number">1</span><br>        nums[right] = nums[left]<br>    nums[left] = pivot <br>    <span class="hljs-keyword">return</span> left <br>    <br>    <br>nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>quick_sort(nums, <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(nums)<br></code></pre></td></tr></table></figure><p>我们来总结一下快排代码需要注意的点：</p><ol><li>在递归代码中，只有当left &lt; right的时候才会往下执行代码，注意这里没有等于；</li><li>如果默认将数组的第一个元素设为pivot，请注意pivot = nums[left] 而不是pivot = nums[0]，同时在一轮交换操作完成后，还要做一个逆操作；</li><li><strong>排序规则</strong>仅是在partition函数的内层循环有所区别（请注意，这里的排序规则不仅仅是正序或者逆序这两种情况，根据不同的问题条件，会抽象出不同的排序规则，可以见后面的例题）；</li></ol><p>在熟练掌握原有快排算法后，我们遇到了可以用快排来优化时间的问题时，需要思考两个问题：</p><ol><li>基于快排什么样的特性，该问题可以使用快排；</li><li>该问题具有什么样的特点，才会想到使用快排；</li></ol><blockquote><p>一般地，前两个特性可以解决第k大或前k大问题，而通过适当改变排序规则，可以解决本质上是一个排序问题的衍生子问题。</p></blockquote><h4 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 由于使用的正序快排，利用数组长度将第k大转换成第len-k+1小的问题</span><br>        k = nums.length - k; <span class="hljs-comment">//这里的k指转换成第len-k+1小的值的下标</span><br>        quicksort(nums, k, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums[k];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<span class="hljs-keyword">return</span> ;&#125;<br>        <span class="hljs-keyword">int</span> pivotLoc = partition(arr, left, right);<br>        <span class="hljs-keyword">if</span> (pivotLoc == k) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivotLoc &lt; k) &#123;<br>            quicksort(arr, k, pivotLoc + <span class="hljs-number">1</span>, right);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            quicksort(arr, k, left, pivotLoc - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 随机产生一个pivot，并将其与当前数组的第一个元素进行交换</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-keyword">new</span> Random().nextInt(right - left + <span class="hljs-number">1</span>) + left;<br>        <span class="hljs-keyword">int</span> pre = arr[i];<br>        arr[i] = arr[left];<br>        arr[left] = pre;<br>        <br>        <span class="hljs-keyword">int</span> pivot = arr[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) &#123;<br>                right--;<br>            &#125;<br>            arr[left] = arr[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;<br>                left++;<br>            &#125;<br>            arr[right] = arr[left];<br>        &#125;<br>        arr[left] = pivot;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>该问题用到了快排的第一个特性；</p></blockquote><h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;<br>        quicksort(arr, k, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(arr, <span class="hljs-number">0</span>, k);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<span class="hljs-keyword">return</span> ;&#125;<br>        <span class="hljs-keyword">int</span> pivotLoc = partition(arr, left, right);<br>        <span class="hljs-keyword">if</span> (pivotLoc == k) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivotLoc &lt; k) &#123;<br>            quicksort(arr, k, pivotLoc + <span class="hljs-number">1</span>, right);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            quicksort(arr, k, left, pivotLoc - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pivot = arr[left];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) &#123;<br>                right--;<br>            &#125;<br>            arr[left] = arr[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;<br>                left++;<br>            &#125;<br>            arr[right] = arr[left];<br>        &#125;<br>        arr[left] = pivot;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>该问题体现了快排的第二个特性。</p></blockquote><h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span>(<span class="hljs-params">nums</span>):</span><br>            quick_sort_recursion(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)<br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort_recursion</span>(<span class="hljs-params">nums, left, right</span>):</span> <br>            <span class="hljs-keyword">if</span> left &gt;= right: <span class="hljs-keyword">return</span> <br>            pivot_loc = partition(nums, left, right)<br>            quick_sort_recursion(nums, left, pivot_loc-<span class="hljs-number">1</span>)<br>            quick_sort_recursion(nums, pivot_loc+<span class="hljs-number">1</span>, right)<br>            <br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span>(<span class="hljs-params">nums, left, right</span>):</span><br>            pivot = nums[left]<br>            <span class="hljs-keyword">while</span> left &lt; right:<br>                <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[right] + pivot &gt;= pivot + nums[right]: right -= <span class="hljs-number">1</span> <span class="hljs-comment"># 排序规则发生改变</span><br>                nums[left] = nums[right]<br>                <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[left] + pivot &lt;= pivot + nums[left]: left += <span class="hljs-number">1</span> <span class="hljs-comment"># 排序规则发生改变</span><br>                nums[right] = nums[left]<br>            nums[left] = pivot <br>            <span class="hljs-keyword">return</span> left <br>        <br>        nums = [<span class="hljs-built_in">str</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums]<br>        quick_sort(nums)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(nums)<br></code></pre></td></tr></table></figure><blockquote><p>该问题修改排序规则之后利用了快排思想。</p></blockquote><h4 id="973-最接近原点的-K-个点"><a href="#973-最接近原点的-K-个点" class="headerlink" title="973. 最接近原点的 K 个点"></a><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">973. 最接近原点的 K 个点</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] kClosest(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> K) &#123;<br>        <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[K][<span class="hljs-number">2</span>];<br>        quickSort(points, K, <span class="hljs-number">0</span>, points.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K; ++i) &#123;<br>            res[i] = points[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> K, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<span class="hljs-keyword">return</span>;&#125;<br>        <span class="hljs-keyword">int</span> pivotLoc = partition(points, left, right);<br>        <span class="hljs-keyword">if</span> (pivotLoc == K) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivotLoc &lt; K) &#123;<br>            quickSort(points, K, pivotLoc + <span class="hljs-number">1</span>, right);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            quickSort(points, K, left, pivotLoc - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] points, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-keyword">new</span> Random().nextInt(right - left + <span class="hljs-number">1</span>) + left;<br>        <span class="hljs-keyword">int</span>[] pre = points[i];<br>        points[i] = points[left];<br>        points[left] = pre;<br>        <span class="hljs-keyword">int</span>[] pivot = points[left]; <br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; distance(points[right]) &gt;= distance(pivot)) &#123;<br>                right--;<br>            &#125;<br>            points[left] = points[right];<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; distance(points[left]) &lt;= distance(pivot)) &#123;<br>                left++;<br>            &#125;<br>            points[right] = points[left];<br>        &#125;<br>        points[left] = pivot;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pos)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pos[<span class="hljs-number">0</span>] * pos[<span class="hljs-number">0</span>] + pos[<span class="hljs-number">1</span>] * pos[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>该问题修改了排序规则，同时体现了快排的前两个特性。</p></blockquote><p>延伸为一种交换思想来优化问题的解决方案：</p><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permute</span>(<span class="hljs-params">self, nums</span>):</span> <span class="hljs-comment">#  全排列I</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">first = <span class="hljs-number">0</span></span>):</span><br>            <span class="hljs-comment"># 所有数都填完了</span><br>            <span class="hljs-keyword">if</span> first == n:  <br>                res.append(nums[:])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(first, n):<br>                <span class="hljs-comment"># 动态维护数组</span><br>                nums[first], nums[i] = nums[i], nums[first]<br>                <span class="hljs-comment"># 继续递归填下一个数</span><br>                backtrack(first + <span class="hljs-number">1</span>)<br>                <span class="hljs-comment"># 撤销操作</span><br>                nums[first], nums[i] = nums[i], nums[first]<br>        <br>        n = <span class="hljs-built_in">len</span>(nums)<br>        res = []<br>        backtrack()<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一般回溯，used标记原数组具体位置对应的元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(len);<br><br>        dfs(nums, len, <span class="hljs-number">0</span>, path, used, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> depth,</span></span><br><span class="hljs-function"><span class="hljs-params">                     Deque&lt;Integer&gt; path, <span class="hljs-keyword">boolean</span>[] used,</span></span><br><span class="hljs-function"><span class="hljs-params">                     List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (depth == len) &#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>                path.addLast(nums[i]);<br>                used[i] = <span class="hljs-keyword">true</span>;<br><br>                System.out.println(<span class="hljs-string">&quot;  递归之前 =&gt; &quot;</span> + path);<br>                dfs(nums, len, depth + <span class="hljs-number">1</span>, path, used, res);<br><br>                used[i] = <span class="hljs-keyword">false</span>;<br>                path.removeLast();<br>                System.out.println(<span class="hljs-string">&quot;递归之后 =&gt; &quot;</span> + path);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        Solution solution = <span class="hljs-keyword">new</span> Solution();<br>        List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);<br>        System.out.println(lists);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>使用交换思想，定住一个位置的元素，写出来的代码可以优化空间；</li><li>对于要求按顺序输出全排列的问题，该交换思想并不能保证是有序的。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>团灭股票问题</title>
    <link href="/2020/11/08/tech/leetcode/%E5%9B%A2%E7%81%AD%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/08/tech/leetcode/%E5%9B%A2%E7%81%AD%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下问题在没有进行状态压缩前，都是套用一个模板分析的状态转移、写出的代码，因此面试的时候可以直接先把没有进行状态压缩的算法写出来，再在此基础上修改代码优化空间。</p></blockquote><hr><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 状态量： </span><br><span class="hljs-comment">//     天数 &amp; 是否持有股票</span><br><span class="hljs-comment">// dp[i][j]定义：</span><br><span class="hljs-comment">//     第i天手里有或没有股票的最大利润；</span><br><span class="hljs-comment">// 状态转移：</span><br><span class="hljs-comment">//     第i天持有股票：dp[i][1]</span><br><span class="hljs-comment">//         可能是第i-1天以前就买过了 dp[i][1] = dp[i-1][1]</span><br><span class="hljs-comment">//         也可能是第i天刚买入的 dp[i][1] = dp[i-1][0] - prices[i]</span><br><span class="hljs-comment">//     第i天不持有股票：dp[i][0]</span><br><span class="hljs-comment">//         可能是i-1天持有股票，i天刚好卖出；dp[i][0] = dp[i-1][1] + prices[i]</span><br><span class="hljs-comment">//         也可能是i-1天就没有股票； dp[i][0] = dp[i-1][0]</span><br><span class="hljs-comment">// 初始状态：</span><br><span class="hljs-comment">//     dp[0][0] = 0</span><br><span class="hljs-comment">//     dp[0][1] = - prices[0]</span><br><span class="hljs-comment">// 返回值：</span><br><span class="hljs-comment">//     最后一天不持有股票的最大利润，即：dp[prices.length - 1][0]</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = - prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; ++i) &#123;<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>空间压缩：观察到第i天是否持有股票只由i-1天决定，因此不需要记录再久之间的状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        状态转移：</span><br><span class="hljs-string">        第i天持有股票，state1</span><br><span class="hljs-string">            可能是i-1天以前买的： </span><br><span class="hljs-string">            也可能是i天刚买的</span><br><span class="hljs-string">        第i天不持有股票，state0</span><br><span class="hljs-string">            可能是i-1天以前卖的，</span><br><span class="hljs-string">            也可能是第i天刚卖的 </span><br><span class="hljs-string"></span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># state0 代表当前不持有股票的最大收益， state1 代表当前持有股票的最大收益</span><br>        state0, state1 = <span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>            state0_new = <span class="hljs-built_in">max</span>(state0, state1 + prices[i])<br>            state1_new = <span class="hljs-built_in">max</span>(state1, state0 - prices[i])<br>            state0, state1 = state0_new, state1_new<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(state0, state1)<br></code></pre></td></tr></table></figure><p>贪心策略：由于可以无限次交易，我们只需要记录<strong>当前</strong>的增量并将其累加就可，而得到的结果就是最终的全局最优解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        profit = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>            tmp = prices[i] - prices[i - <span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> tmp &gt; <span class="hljs-number">0</span>: profit += tmp<br>        <span class="hljs-keyword">return</span> profit<br></code></pre></td></tr></table></figure><hr><h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;题解：DP</span><br><span class="hljs-string">dp数组的含义：</span><br><span class="hljs-string">    dp[i][j]代表当前第i天在状态j时的最大收益</span><br><span class="hljs-string">状态：</span><br><span class="hljs-string">    第i天持有股票: dp[i][0]，第i天没有股票: dp[i][1]</span><br><span class="hljs-string">状态转移：</span><br><span class="hljs-string">    1. 第i天持有股票：</span><br><span class="hljs-string">        可能是第i-1天持有的股票：dp[i-1][0]</span><br><span class="hljs-string">        也可能是第i天刚买的股票：dp[i-1][1] - prices[i]</span><br><span class="hljs-string">        state1 = max(dp[i-1][0], dp[i-1][1] - prices[i])</span><br><span class="hljs-string">    2. 第i天不持有股票：</span><br><span class="hljs-string">        可能是第i-1天就没有股票：dp[i-1][1]</span><br><span class="hljs-string">        也可能是第i天刚卖出股票：dp[i-1][0] + prices[i] - fee</span><br><span class="hljs-string">        state2 = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee)</span><br><span class="hljs-string">边界条件：</span><br><span class="hljs-string">    dp[0][0] = -prices[0]</span><br><span class="hljs-string">    dp[0][1] = 0</span><br><span class="hljs-string">最终输出：</span><br><span class="hljs-string">    res = max(dp[n-1][0],dp[n-1][1])</span><br><span class="hljs-string">空间优化：</span><br><span class="hljs-string">    state1, state2 = -prices[0], 0</span><br><span class="hljs-string">复杂度分析：</span><br><span class="hljs-string">    T(n) = O(n); S(n) = O(1)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], fee: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        prices_len = <span class="hljs-built_in">len</span>(prices)<br>        <span class="hljs-keyword">if</span> prices_len == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> prices_len == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        state1, state2 = -prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, prices_len):<br>            state1_new = <span class="hljs-built_in">max</span>(state1, state2 - prices[i])<br>            state2_new = <span class="hljs-built_in">max</span>(state2, state1 + prices[i] - fee)<br>            state1, state2 = state1_new, state2_new<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(state1, state2)<br></code></pre></td></tr></table></figure><p>贪心解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len=prices.length;<br>        <span class="hljs-keyword">if</span> (len&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,min=prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;len ; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i]&lt;min)&#123;<br>                <span class="hljs-comment">//未发生买卖时找到第一个最小数，如果发生过买卖则比较当前价格和上次卖出时的价格减去手续费</span><br>                min=prices[i];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (prices[i]-fee&gt;min)&#123;<br>                    res+=prices[i]-min-fee;<br>                    <span class="hljs-comment">//当前的价格已经减过手续费，所以min的值应为当前价格减去手续费。</span><br>                    min=prices[i]-fee;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 状态量：</span><br><span class="hljs-comment">//     天数 &amp; 是否持有股票 &amp; 是否处于冷冻期</span><br><span class="hljs-comment">// dp定义：</span><br><span class="hljs-comment">//     dp[i][j][k] 为第i天后持有/不持有股票处于/不处于冷冻期的最大收益；</span><br><span class="hljs-comment">//     不持有不处于均用0表示，持有处于均用1表示；</span><br><span class="hljs-comment">// 状态转移：</span><br><span class="hljs-comment">//     第i天后持有股票：</span><br><span class="hljs-comment">//         可能是第i-1天已经持有的：dp[i][1][0] = dp[i-1][1][0]</span><br><span class="hljs-comment">//         也可能是第i天刚好买入的：dp[i][1][0] = dp[i-1][0][0] - prices[i]</span><br><span class="hljs-comment">//     第i天后不持有股票：</span><br><span class="hljs-comment">//         第i-1天后就没持有股票</span><br><span class="hljs-comment">//             此时可能是i-1天本来就没有股票：dp[i][0][0] = dp[i-1][0][0]</span><br><span class="hljs-comment">//             也可能是i-1天刚好卖出，此时i-1天后处于冷冻期：dp[i][0][0] = dp[i-1][0][1]</span><br><span class="hljs-comment">//         第i天刚卖出，此时第i-1天持有股票，第i天后处于冷冻期：dp[i][0][1] = dp[i-1][1][0] + prices[i]</span><br><span class="hljs-comment">// 初始化：</span><br><span class="hljs-comment">//     dp[0][0][k] = 0</span><br><span class="hljs-comment">//     dp[0][1][k] = - prices[0]</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length][<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span>; ++k) &#123;<br>            dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][k] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; ++i) &#123;<br>            dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);<br>            dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<br>        &#125;<br>        Arrays.sort(dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>空间压缩：观察到冷冻期只会出现在前一天刚卖完，当前这一天才会处在冷冻期，因此可以将状态量减小为三个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;题解：DP</span><br><span class="hljs-string">状态：</span><br><span class="hljs-string">    1. 当前第i天持有股票：dp[i][0]</span><br><span class="hljs-string">    2. 当前第i天不持有股票，处于冷冻期（第i天刚卖出股票）：dp[i][1]</span><br><span class="hljs-string">    3. 当前第i天不持有股票，不处于冷冻期（第i天没有卖出股票）：dp[i][2]</span><br><span class="hljs-string">dp数组含义：</span><br><span class="hljs-string">    dp[i][j]代表第i天j状态下的最大收益</span><br><span class="hljs-string">状态转移：</span><br><span class="hljs-string">    1. 第i天持有的股票可能是第i-1天已经持有的：dp[i-1][0]</span><br><span class="hljs-string">       也可能是第i天刚好买入的（此时i-1天只有不处在冷冻期第i天才能买入）：dp[i-1][2]</span><br><span class="hljs-string">        dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i])</span><br><span class="hljs-string">    2. 第i天刚卖出股票意味着i-1天一定持有股票：</span><br><span class="hljs-string">        dp[i][1] = dp[i-1][0] + prices[i]</span><br><span class="hljs-string">    3. 第i天不持有股票且当天没有卖出股票：</span><br><span class="hljs-string">        dp[i][2] = max(dp[i-1][1], dp[i-1][2])</span><br><span class="hljs-string">边界条件：</span><br><span class="hljs-string">    dp[0][0] = -prices[0]</span><br><span class="hljs-string">    dp[0][1] = 0</span><br><span class="hljs-string">    dp[0][2] = 0</span><br><span class="hljs-string">最终结果：</span><br><span class="hljs-string">    n = len(prices)</span><br><span class="hljs-string">    res = max(dp[n-1][0], dp[n-1][1], dp[n-1][2])</span><br><span class="hljs-string">空间优化：</span><br><span class="hljs-string">    第i天状态只由i-1天状态决定，因此可以用三个变量分别记录i-1天时三个状态的最大收益：</span><br><span class="hljs-string">    状态1: state1_stock</span><br><span class="hljs-string">    状态2: state2_selling</span><br><span class="hljs-string">    状态3: state3_selled</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        prices_len = <span class="hljs-built_in">len</span>(prices)<br>        <span class="hljs-keyword">if</span> prices_len == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> prices_len == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        state1, state2, state3 = -prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(prices_len):<br>            state1_new = <span class="hljs-built_in">max</span>(state1, state3 - prices[i])<br>            state2_new = state1 + prices[i]<br>            state3_new = <span class="hljs-built_in">max</span>(state2, state3)<br>            state1, state2, state3 = state1_new, state2_new, state3_new<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(state1, state2, state3)<br><br>sol = Solution()<br>prices = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(sol.maxProfit(prices))<br></code></pre></td></tr></table></figure><hr><h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 状态量：</span><br><span class="hljs-comment">//     天数 &amp; 是否持有股票 &amp; 已完成的交易数</span><br><span class="hljs-comment">// dp数组定义：</span><br><span class="hljs-comment">//     dp[i][j][k] 第i天后持有或不持有股票完成k笔交易的最大利润；</span><br><span class="hljs-comment">//     i 与prices[]下标一致</span><br><span class="hljs-comment">//     j = 0 -&gt; 不持有 j = 1 -&gt; 持有</span><br><span class="hljs-comment">//     k = 0, 1, 2</span><br><span class="hljs-comment">// 状态转移：</span><br><span class="hljs-comment">//     第i天后持有股票：</span><br><span class="hljs-comment">//         可能是第i-1天也持有股票：dp[i][1][k] = dp[i-1][1][k]</span><br><span class="hljs-comment">//         也可能是第i天刚买入股票：dp[i][1][k] = dp[i-1][0][k] - prices[i]</span><br><span class="hljs-comment">//     第i天后不持有股票：</span><br><span class="hljs-comment">//         可能是第i-1天也不持有股票：dp[i][0][k] = dp[i-1][0][k]</span><br><span class="hljs-comment">//         也可能是第i天刚卖出股票，此时相较于i-1天，完成的交易数+1：dp[i][0][k] = dp[i-1][1][k-1] + prices[i]</span><br><span class="hljs-comment">// 初始化：</span><br><span class="hljs-comment">//     dp[0][0][k] = 0</span><br><span class="hljs-comment">//     dp[0][1][k] = - prices[0]</span><br><span class="hljs-comment">// 返回：</span><br><span class="hljs-comment">//     最后一天后完成0，1，2笔交易后不持有股票的最大值。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length][<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; ++k) &#123;<br>            dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][k] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; ++k) &#123;<br>                dp[i][<span class="hljs-number">1</span>][k] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][k], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k] - prices[i]);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">3</span>; ++k) &#123;<br>                dp[i][<span class="hljs-number">0</span>][k] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>] + prices[i]);<br>            &#125;<br>        &#125;<br>        Arrays.sort(dp[prices.length-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> dp[prices.length-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>空间压缩：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/wu-chong-shi-xian-xiang-xi-tu-jie-123mai-mai-gu-pi/">参考地址</a></p><hr><h4 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[prices.length][<span class="hljs-number">2</span>][k+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; count &lt; k+<span class="hljs-number">1</span>; ++count) &#123;<br>            dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][count] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; count &lt; k+<span class="hljs-number">1</span>; ++count) &#123;<br>                dp[i][<span class="hljs-number">1</span>][count] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][count], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][count] - prices[i]);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>; count &lt; k+<span class="hljs-number">1</span>; ++count) &#123;<br>                dp[i][<span class="hljs-number">0</span>][count] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][count], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][count-<span class="hljs-number">1</span>] + prices[i]);<br>            &#125;<br>        &#125;<br>        Arrays.sort(dp[prices.length-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> dp[prices.length-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>327. 区间和的个数</title>
    <link href="/2020/11/07/tech/leetcode/327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2020/11/07/tech/leetcode/327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="327-区间和的个数"><a href="#327-区间和的个数" class="headerlink" title="327. 区间和的个数"></a><a href="https://leetcode-cn.com/problems/count-of-range-sum/">327. 区间和的个数</a></h4><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。<br>区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。</p><p>说明:<br>最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。</p><p>示例:</p><p>输入: nums = [-2,5,-1], lower = -2, upper = 2,<br>输出: 3<br>解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>首先可以想到二次方的暴力解法；</li><li>接着有了前缀和的灵感；</li><li>然后就是想对前缀和数组排序看看能不能直接解决问题（并不能，因为只有长的前缀和减掉短的前缀和才能和边界比较，排序后的前缀和数组做差可能会出现相反数）；</li><li>为了解决第三步的问题，可以在一层循环中，边排序，边统计结果；</li><li>总结以上特点，我们要对不改变原来前缀和的元素：边统计边排序，而具体的统计方式是对于前缀和数组preSum，lower &lt;= preSum[j] - preSum[i] &lt;= upper (i &lt; j) 的时候更新res；</li><li>不改变原数组元素相对位置的前提下，边比较，边更新排序，想到了归并排序算法；</li><li>只需要在Merge函数排序前进行统计就可以了，同时，Merge统计的只是两个前缀和做差的区间，并没有考虑前缀和区间本身，因此在创建preSum的时候，要对preSum[i] (0 &lt;= i &lt;= preSum.length - 1) 单独做一次统计；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[nums.length];<br>        preSum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (preSum[<span class="hljs-number">0</span>] &lt;= upper &amp;&amp; preSum[<span class="hljs-number">0</span>] &gt;= lower) res++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; preSum.length; ++i) &#123;<br>            preSum[i] = preSum[i-<span class="hljs-number">1</span>] + nums[i];<br>            <span class="hljs-keyword">if</span> (preSum[i] &lt;= upper &amp;&amp; preSum[i] &gt;= lower) res++;<br>        &#125;<br>MergeSort(preSum, lower, upper, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = mid + <span class="hljs-number">1</span>, r = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= mid; ++i) &#123;<br><span class="hljs-keyword">while</span> (l &lt;= right &amp;&amp; nums[l] &lt; nums[i] + lower) l++;<br><span class="hljs-keyword">while</span> (r &lt;= right &amp;&amp; nums[r] &lt;= nums[i] + upper) r++;<br>res += (r - l);<br>&#125;<br><span class="hljs-keyword">long</span>[] nums_ = (<span class="hljs-keyword">long</span>[]) nums.clone();<br>        <span class="hljs-keyword">int</span> i, j, k;<br><span class="hljs-keyword">for</span> (i = left, j = mid + <span class="hljs-number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= right; ++k) &#123;<br><span class="hljs-keyword">if</span> (nums_[i] &lt;= nums_[j]) &#123;<br>nums[k] = nums_[i++];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>nums[k] = nums_[j++];<br>&#125;<br>&#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) nums[k++] = nums_[i++];<br><span class="hljs-keyword">while</span> (j &lt;= right) nums[k++] = nums_[j++];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            MergeSort(nums, lower, upper, left, mid);<br>            MergeSort(nums, lower, upper, mid + <span class="hljs-number">1</span>, right);<br>            Merge(nums, lower, upper, left, mid, right);<br>        &#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>127. 单词接龙</title>
    <link href="/2020/11/05/tech/leetcode/127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <url>/2020/11/05/tech/leetcode/127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    
    <content type="html"><![CDATA[<h4 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h4>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>List&amp;int[]&amp;Integer[]之间的转换</title>
    <link href="/2020/11/02/tech/JavaSE/List-int-Integer-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/11/02/tech/JavaSE/List-int-Integer-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// int[] 转 List&lt;Integer&gt;</span><br>List&lt;Integer&gt; list1 = Arrays.stream(data).boxed().collect(Collectors.toList());<br><span class="hljs-comment">// Arrays.stream(arr) 可以替换成IntStream.of(arr)。</span><br><span class="hljs-comment">// 1.使用Arrays.stream将int[]转换成IntStream。</span><br><span class="hljs-comment">// 2.使用IntStream中的boxed()装箱。将IntStream转换成Stream&lt;Integer&gt;。</span><br><span class="hljs-comment">// 3.使用Stream的collect()，将Stream&lt;T&gt;转换成List&lt;T&gt;，因此正是List&lt;Integer&gt;。</span><br><br><span class="hljs-comment">// int[] 转 Integer[]</span><br>Integer[] integers1 = Arrays.stream(data).boxed().toArray(Integer[]::<span class="hljs-keyword">new</span>);<br><span class="hljs-comment">// 前两步同上，此时是Stream&lt;Integer&gt;。</span><br><span class="hljs-comment">// 然后使用Stream的toArray，传入IntFunction&lt;A[]&gt; generator。</span><br><span class="hljs-comment">// 这样就可以返回Integer数组。</span><br><span class="hljs-comment">// 不然默认是Object[]。</span><br><br><span class="hljs-comment">// List&lt;Integer&gt; 转 Integer[]</span><br>Integer[] integers2 = list1.toArray(<span class="hljs-keyword">new</span> Integer[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//  调用toArray。传入参数T[] a。这种用法是目前推荐的。</span><br><span class="hljs-comment">// List&lt;String&gt;转String[]也同理。</span><br><br><span class="hljs-comment">// List&lt;Integer&gt; 转 int[]</span><br><span class="hljs-keyword">int</span>[] arr1 = list1.stream().mapToInt(Integer::valueOf).toArray();<br><span class="hljs-comment">// 想要转换成int[]类型，就得先转成IntStream。</span><br><span class="hljs-comment">// 这里就通过mapToInt()把Stream&lt;Integer&gt;调用Integer::valueOf来转成IntStream</span><br><span class="hljs-comment">// 而IntStream中默认toArray()转成int[]。</span><br><br><span class="hljs-comment">// Integer[] 转 int[]</span><br><span class="hljs-keyword">int</span>[] arr2 = Arrays.stream(integers1).mapToInt(Integer::valueOf).toArray();<br><span class="hljs-comment">// 思路同上。先将Integer[]转成Stream&lt;Integer&gt;，再转成IntStream。</span><br><br><span class="hljs-comment">// Integer[] 转 List&lt;Integer&gt;</span><br>List&lt;Integer&gt; list2 = Arrays.asList(integers1);<br><span class="hljs-comment">// 最简单的方式。String[]转List&lt;String&gt;也同理。</span><br><br><span class="hljs-comment">// 同理</span><br>String[] strings1 = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br><span class="hljs-comment">// String[] 转 List&lt;String&gt;</span><br>List&lt;String&gt; list3 = Arrays.asList(strings1);<br><span class="hljs-comment">// List&lt;String&gt; 转 String[]</span><br>String[] strings2 = list3.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10000</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>    nums[i] = i;<br>&#125;<br><br><span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><br>Integer[] arr1 = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">10000</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) &#123;<br>    arr1[i] = nums[i];<br>&#125;<br><br><span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>System.out.println(end - start); <span class="hljs-comment">// 1</span><br><br><br>start = System.currentTimeMillis();<br><br>Integer[] arr2 = Arrays.stream(nums).boxed().toArray(Integer[]::<span class="hljs-keyword">new</span>);<br><br>end = System.currentTimeMillis();<br>System.out.println(end - start); <span class="hljs-comment">// 62</span><br></code></pre></td></tr></table></figure><blockquote><p>还是用for自己转吧。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>usage</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性连续dp</title>
    <link href="/2020/10/27/tech/leetcode/%E7%BA%BF%E6%80%A7%E8%BF%9E%E7%BB%ADdp/"/>
    <url>/2020/10/27/tech/leetcode/%E7%BA%BF%E6%80%A7%E8%BF%9E%E7%BB%ADdp/</url>
    
    <content type="html"><![CDATA[<h3 id="题目集合"><a href="#题目集合" class="headerlink" title="题目集合"></a>题目集合</h3><h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h4><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h4><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h4><h4 id="1477-找两个和为目标值且不重叠的子数组"><a href="#1477-找两个和为目标值且不重叠的子数组" class="headerlink" title="1477. 找两个和为目标值且不重叠的子数组"></a><a href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">1477. 找两个和为目标值且不重叠的子数组</a></h4>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性非连续dp</title>
    <link href="/2020/10/27/tech/leetcode/%E7%BA%BF%E6%80%A7%E9%9D%9E%E8%BF%9E%E7%BB%ADdp/"/>
    <url>/2020/10/27/tech/leetcode/%E7%BA%BF%E6%80%A7%E9%9D%9E%E8%BF%9E%E7%BB%ADdp/</url>
    
    <content type="html"><![CDATA[<h3 id="题目集合"><a href="#题目集合" class="headerlink" title="题目集合"></a>题目集合</h3><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4><h4 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a></h4><h4 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673. 最长递增子序列的个数"></a><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a></h4><h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4><h4 id="873-最长的斐波那契子序列的长度"><a href="#873-最长的斐波那契子序列的长度" class="headerlink" title="873. 最长的斐波那契子序列的长度"></a><a href="https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度</a></h4><h4 id="1027-最长等差数列"><a href="#1027-最长等差数列" class="headerlink" title="1027. 最长等差数列"></a><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence/">1027. 最长等差数列</a></h4>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>763. 划分字母区间</title>
    <link href="/2020/10/22/tech/leetcode/763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"/>
    <url>/2020/10/22/tech/leetcode/763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h4><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p><p>示例 1：</p><p>输入：S = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]<br>解释：<br>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p><p>提示：</p><p>S的长度在[1, 500]之间。<br>S只包含小写字母 ‘a’ 到 ‘z’ 。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><u>dp</u>：</p><p>一个很自然的想法是用map的key存26个字母，value为对应的片段的标号。对当前字符c，分在map和不在map两种情况，然后分别考虑如何更新res和map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    对第i个元素，如果之前出现过，且在第j个片段中，接下来有两个操作：</span><br><span class="hljs-comment">    1. 将j之后的片段的个数都加在j后并删除，j的字符个数再加1；</span><br><span class="hljs-comment">    2. 将j之后片段里的字符的哈希表的value都改为j；</span><br><span class="hljs-comment">        具体操作方式为：遍历哈希表，对value大于j的值的key，将其value重设为j；</span><br><span class="hljs-comment">    对第i个元素，如果之前没出现过，接下来也有两个操作：</span><br><span class="hljs-comment">    1. 在res中新增一个片段；</span><br><span class="hljs-comment">    2. 更新hash表；</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(String S)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Map&lt;Character, Integer&gt; hash = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S.length(); ++i) &#123;<br>            <span class="hljs-keyword">char</span> c = S.charAt(i);<br>            <span class="hljs-keyword">if</span> (hash.containsKey(c)) &#123;<br>                <span class="hljs-keyword">int</span> partIndex = hash.get(c);<br>                <span class="hljs-keyword">while</span> (res.size() - <span class="hljs-number">1</span> &gt; partIndex) &#123;<br>                    res.set(partIndex, res.get(partIndex) + res.remove(res.size() - <span class="hljs-number">1</span>));<br>                &#125;<br>                res.set(partIndex, res.get(partIndex) + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">for</span> (Character key: hash.keySet()) &#123;<br>                    <span class="hljs-keyword">if</span> (hash.get(key) &gt; partIndex) &#123;hash.put(key, partIndex);&#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.add(<span class="hljs-number">1</span>);<br>                hash.put(c, res.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><u>greedy：</u></p><p>发现：同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。如果<strong>遍历字符串，得到每个字母最后一次出现的下标位置</strong>，则必然满足一个贪心策略：<strong>对于当前的字符c，对应的最后一次出现的下标位置一定不会大于片段的右边界。</strong></p><p>如果用$start$和$end$分别表示一个片段的左右边界，那么对于当前字符c，它的右边界下标$end_c$一定小于等于它所在片段的右边界下标$end$。而$end$等于该片段内所有字符的右边界的最大值。因此可以遍历每个字符，不断的更新$end$，$end = max(end, end_c)$，而当遍历到$end$的时候就完成了一个片段的检索。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(String S)</span> </span>&#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S.length(); ++i) &#123;<br>            hash[S.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S.length(); ++i) &#123;<br>            end = Math.max(end, hash[S.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == end) &#123;<br>                res.add(end - start + <span class="hljs-number">1</span>);<br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>117. 填充每个节点的下一个右侧节点指针 II</title>
    <link href="/2020/09/28/tech/leetcode/117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II/"/>
    <url>/2020/09/28/tech/leetcode/117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj6bnf31qtj30u01lddok.jpg" style="zoom:50%;" /><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj6bh1orb8j30kc0mzdhd.jpg" style="zoom:70%;" /><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj6bh9c480j30gg0gvaax.jpg" style="zoom:86%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">connect</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        Node res = root;<br><span class="hljs-comment">// 外层循环为树高的迭代</span><br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>            Node nextLayerHead = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>);<br>            Node nextLayerNode = nextLayerHead;<br>            <span class="hljs-comment">// 内层循环根据当前层已有的链表构建下一层的链表</span><br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;<br>                    nextLayerNode.next = root.left;<br>                    nextLayerNode = nextLayerNode.next;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;<br>                    nextLayerNode.next = root.right;<br>                    nextLayerNode = nextLayerNode.next;<br>                &#125;<br>                root = root.next;<br>            &#125;<br>            root = nextLayerHead.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>437. 路径总和 III</title>
    <link href="/2020/09/27/tech/leetcode/437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III/"/>
    <url>/2020/09/27/tech/leetcode/437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum-iii/solution/qian-zhui-he-di-gui-hui-su-by-shi-huo-de-xia-tian/">题解</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4inzrspgj30u00yk0xc.jpg" style="zoom:50%;" /><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>A和B是一条路径上的节点，root到A的路径和为a，root到B的路径和为b，如果b - a = target，那么A到B就是满足题目要求的一条路径；</li><li>从root到当前节点B路径和为target的数量为B之前有几个路径和为b - target的节点；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3ms; 38.8MB</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> curSum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(root, sum, map, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum, HashMap&lt;Integer, Integer&gt; map, <span class="hljs-keyword">int</span> res)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归出口</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 状态更新</span><br>        curSum += root.val;<br>        <span class="hljs-keyword">int</span> tag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (map.containsKey(curSum - sum)) &#123;<br>            tag = map.get(curSum - sum);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (map.containsKey(curSum)) &#123;<br>            map.put(curSum, map.get(curSum) + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.put(curSum, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 递归</span><br>        res = tag + dfs(root.left, sum, map, res) + dfs(root.right, sum, map, res);<br>        <span class="hljs-comment">// 回溯</span><br>        <span class="hljs-keyword">if</span> (map.get(curSum) &gt; <span class="hljs-number">0</span>) &#123;<br>            map.put(curSum, map.get(curSum) - <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.remove(curSum);<br>        &#125;<br>        curSum -= root.val;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>113. 路径总和 II</title>
    <link href="/2020/09/26/tech/leetcode/113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/"/>
    <url>/2020/09/26/tech/leetcode/113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum-ii/solution/3chong-fang-shi-jie-jue-2chong-ji-bai-liao-100de-2/">题解参考</a></p><p>本题同 <a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><a href="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj3zfvunugj30u00v3n08.jpg">问题</a></h2><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj411upw11j30u00uq41k.jpg" style="zoom:50%;" /><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>节点值可能有正有负，必须dfs把能走的节点都走一遍；</li><li>一定是从根节点到叶子结点，考虑输入为：[1,2]  1，输出为：[] 的情况；</li></ol><p>在具体编写代码的时候要考虑的问题：</p><ol><li><p>什么时候回溯？</p><ul><li><p>对于一般的dfs，在左右递归之后，要回溯，把当前节点从path中删除；</p></li><li><p>如果在一定条件下可以提前return，在if语句里不要忘了回溯；</p></li></ul></li><li><p>sum在什么时候更新？</p><ul><li>在当前层直接更新然后做sum == 0 的判断 ✅</li><li>在当前层做sum == root.val 的判断，然后再递归传参时sum - root.val ✅</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1ms 39.3MB</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span> Collections.emptyList();&#125;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        backtrack(root, sum, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        path.add(root.val);<br>        sum -= root.val;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span> &amp;&amp; sum == <span class="hljs-number">0</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>        &#125;<br>        backtrack(root.left, sum, path, res);<br>        backtrack(root.right, sum, path, res);<br>        path.remove(path.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1ms 39.2MB</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span> Collections.emptyList();&#125; <span class="hljs-comment">// 返回一个空列表</span><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(); <br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        backtrack(root, sum, path, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">// dfs的出口</span><br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        path.add(root.val);<br>        sum -= root.val; <br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>)&#123;<br>                res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            &#125;<br>            path.remove(path.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 代码的优雅性差些 </span><br>            <span class="hljs-keyword">return</span> ; <span class="hljs-comment">//提前返回，可以节省继续dfs的空间开销</span><br>        &#125;<br>        backtrack(root.left, sum, path, res);<br>        backtrack(root.right, sum, path, res);<br>        path.remove(path.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一些tricks：</p><ol><li>要尽量修改sum，使递归的出口为sum == 0，这样可以不用引入额外的变量；</li><li>为提升代码的优雅性，dfs 左右孩子的时候不需要判断左右孩子是否存在，因为进入下一层递归时，会有root是否存在的判断（出口）；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 没使用tricks的代码</span><br><span class="hljs-comment">// 2ms 39.3MB</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/*    res本身就是一个引用型变量，</span><br><span class="hljs-comment">   只有在pathSum函数调用backtrack的时候会对其进行修改，</span><br><span class="hljs-comment">    因此定义在pathSum函数里就可以了，没必要在全局声明。*/</span><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(); <br>    <span class="hljs-keyword">int</span> pathSumVal = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span> Collections.emptyList();&#125;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        backtrack(root, sum, path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum, List&lt;Integer&gt; path)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        path.add(root.val);<br>        pathSumVal += root.val; <span class="hljs-comment">// 要善于在sum上直接进行修改，省去引入新变量消耗的资源。</span><br>        <span class="hljs-keyword">if</span> (pathSumVal == sum &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(path));<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">/*要规避这种冗余代码的书写*/</span><br>            <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>)&#123;<br>                backtrack(root.left, sum, path);<br>                pathSumVal -= path.get(path.size() - <span class="hljs-number">1</span>);<br>                path.remove(path.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>)&#123;<br>                backtrack(root.right, sum, path);<br>                pathSumVal -= path.get(path.size() - <span class="hljs-number">1</span>);<br>                path.remove(path.size() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>90. 子集 II</title>
    <link href="/2020/09/22/tech/leetcode/90-%E5%AD%90%E9%9B%86-II/"/>
    <url>/2020/09/22/tech/leetcode/90-%E5%AD%90%E9%9B%86-II/</url>
    
    <content type="html"><![CDATA[<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><p>输入: [1,2,2]<br>输出:<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>相对<a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a>，需要上来对nums进行排序，然后对当前的path进行判断是否已经存在在res中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsetsWithDup</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">index</span>):</span> <br>            <span class="hljs-keyword">if</span> index &gt; self.length: <span class="hljs-keyword">return</span> <br>            <span class="hljs-keyword">if</span> path <span class="hljs-keyword">in</span> res: <span class="hljs-keyword">return</span><br>            res.append(path.copy()) <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index, self.length): <br>                path.append(nums[i])<br>                backtrack(i + <span class="hljs-number">1</span>)<br>                path.pop() <br><br>        res = []<br>        path = []<br>        nums.sort()<br>        self.length = <span class="hljs-built_in">len</span>(nums)<br>        backtrack(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res <br></code></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>能否进一步降低时间复杂度？</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>78. 子集</title>
    <link href="/2020/09/21/tech/leetcode/78-%E5%AD%90%E9%9B%86/"/>
    <url>/2020/09/21/tech/leetcode/78-%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>受此前全排列问题的启发，解答回溯问题时，可以把模拟的递归path先列出来，再通过观察其变化，确定需要用到的状态变量及其可能的修改。</p><p>第一列1表示当前path需要加到res中，即dfs过程；0表示不加，即回溯过程。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs latex">1 1 <br>1 1 2 <br>1 1 2 3 <br>0 1 2 <br>0 1 <br>1 1 3 <br>0 1 <br>0 <span class="hljs-built_in">_</span><br>1 2 <br>1 2 3 <br>0 2<br>0 <span class="hljs-built_in">_</span><br>1 3 <br></code></pre></td></tr></table></figure><ol><li>还是以数组的index作为参数传给dfs，递归终止的条件是index大于nums_len；</li><li>每次变化的path都需要加到res中；</li><li>每深一层递归的循环起始位置都应该从上一层递归的index + 1 开始；</li><li>path要有一个回溯的状态更新；</li><li>因为此题不包含重复元素，且每次循环不需要从index = 0处开始，因此不需要visited数组；</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">index</span>):</span> <span class="hljs-comment"># 1</span><br>            <span class="hljs-keyword">if</span> index &gt; self.length: <span class="hljs-keyword">return</span> <span class="hljs-comment"># 1</span><br>            res.append(path.copy()) <span class="hljs-comment"># 2</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index, self.length): <span class="hljs-comment"># 3</span><br>                path.append(nums[i])<br>                backtrack(i + <span class="hljs-number">1</span>)<br>                path.pop() <span class="hljs-comment"># 4</span><br><br>        res = []<br>        path = []<br>        self.length = <span class="hljs-built_in">len</span>(nums)<br>        backtrack(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        backtrack(<span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt; nums.length)&#123;<span class="hljs-keyword">return</span>;&#125;<br>        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(path));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &lt; nums.length; ++i)&#123;<br>            path.add(nums[i]);<br>            backtrack(i + <span class="hljs-number">1</span>, nums);<br>            path.remove(path.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>526. 优美的排列</title>
    <link href="/2020/09/19/tech/leetcode/526-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2020/09/19/tech/leetcode/526-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p><p>第 i 位的数字能被 i 整除<br>i 能被第 i 位上的数字整除<br>现在给定一个整数 N，请问可以构造多少个优美的排列？</p><p>示例1:</p><p>输入: 2<br>输出: 2<br>解释: </p><p>第 1 个优美的排列是 [1, 2]:<br>  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br>  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</p><p>第 2 个优美的排列是 [2, 1]:<br>  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br>  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除<br>说明:</p><p>N 是一个正整数，并且不会超过15。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调试版</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countArrangement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[N + <span class="hljs-number">1</span>];<br>        calculate(N, <span class="hljs-number">1</span>, visited);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">boolean</span>[] visited)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos &gt; N)<br>            count++; <span class="hljs-comment">// 为什么没有return ？</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i] &amp;&amp; (pos % i == <span class="hljs-number">0</span> || i % pos == <span class="hljs-number">0</span>)) &#123; <span class="hljs-comment">// 与一般的全排列问题区别在于dfs的条件发生了改变</span><br>                visited[i] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 修改状态变量</span><br>                <br><span class="hljs-comment">//                System.out.print(&quot;递归前：&quot;);</span><br><span class="hljs-comment">//                for (int j = 1; j &lt; visited.length; ++j)&#123;</span><br><span class="hljs-comment">//                    System.out.print(visited[j] + &quot; &quot;);</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//                System.out.println();</span><br>                <br>                calculate(N, pos + <span class="hljs-number">1</span>, visited); <span class="hljs-comment">// dfs</span><br>                <br><span class="hljs-comment">//                System.out.print(&quot;递归后：&quot;);</span><br><span class="hljs-comment">//                for (int j = 1; j &lt; visited.length; ++j)&#123;</span><br><span class="hljs-comment">//                    System.out.print(visited[j] + &quot; &quot;);</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//                System.out.println();</span><br>                <br>                visited[i] = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 回溯，修改状态变量</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    public static void main(String[] args) &#123;</span><br><span class="hljs-comment">//        Solution solution = new Solution();</span><br><span class="hljs-comment">//        int N = 3;</span><br><span class="hljs-comment">//        int count = solution.countArrangement(N);</span><br><span class="hljs-comment">//        System.out.println(count);</span><br><span class="hljs-comment">//    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs latex">递归前：true false false <br>递归前：true true false <br>递归前：true true true <br>递归后：true true true <br>递归后：true true false <br>递归后：true false false <br>递归前：false true false <br>递归前：true true false <br>递归前：true true true <br>递归后：true true true <br>递归后：true true false <br>递归后：false true false <br>递归前：false false true <br>递归前：true false true <br>递归后：true false true <br>递归前：false true true <br>递归前：true true true <br>递归后：true true true <br>递归后：false true true <br>递归后：false false true <br>3<br></code></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>visited什么时候设为全局，什么时候设在dfs内的for前？</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>46. 全排列</title>
    <link href="/2020/09/19/tech/leetcode/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2020/09/19/tech/leetcode/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h4><p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">题解参考</a></p><p>相似题目：</p><p><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permute</span>(<span class="hljs-params">self, nums</span>):</span> <span class="hljs-comment">#  全排列I</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">first = <span class="hljs-number">0</span></span>):</span><br>            <span class="hljs-comment"># 所有数都填完了</span><br>            <span class="hljs-keyword">if</span> first == n:  <br>                res.append(nums[:])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(first, n):<br>                <span class="hljs-comment"># 动态维护数组</span><br>                nums[first], nums[i] = nums[i], nums[first]<br>                <span class="hljs-comment"># 继续递归填下一个数</span><br>                backtrack(first + <span class="hljs-number">1</span>)<br>                <span class="hljs-comment"># 撤销操作</span><br>                nums[first], nums[i] = nums[i], nums[first]<br>        <br>        n = <span class="hljs-built_in">len</span>(nums)<br>        res = []<br>        backtrack()<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="回溯问题的调试技巧"><a href="#回溯问题的调试技巧" class="headerlink" title="回溯问题的调试技巧"></a>回溯问题的调试技巧</h2><p>面试中不支持debug，但是可以通过print path 来跟踪回溯的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br><br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(len);<br><br>        dfs(nums, len, <span class="hljs-number">0</span>, path, used, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> depth,</span></span><br><span class="hljs-function"><span class="hljs-params">                     Deque&lt;Integer&gt; path, <span class="hljs-keyword">boolean</span>[] used,</span></span><br><span class="hljs-function"><span class="hljs-params">                     List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (depth == len) &#123;<br>            res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>                path.addLast(nums[i]);<br>                used[i] = <span class="hljs-keyword">true</span>;<br><br>                System.out.println(<span class="hljs-string">&quot;  递归之前 =&gt; &quot;</span> + path);<br>                dfs(nums, len, depth + <span class="hljs-number">1</span>, path, used, res);<br><br>                used[i] = <span class="hljs-keyword">false</span>;<br>                path.removeLast();<br>                System.out.println(<span class="hljs-string">&quot;递归之后 =&gt; &quot;</span> + path);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        Solution solution = <span class="hljs-keyword">new</span> Solution();<br>        List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);<br>        System.out.println(lists);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs text">递归之前 =&gt; [1]<br>递归之前 =&gt; [1, 2]<br>递归之前 =&gt; [1, 2, 3]<br>递归之后 =&gt; [1, 2]<br>递归之后 =&gt; [1]<br>递归之前 =&gt; [1, 3]<br>递归之前 =&gt; [1, 3, 2]<br>递归之后 =&gt; [1, 3]<br>递归之后 =&gt; [1]<br>递归之后 =&gt; []<br>递归之前 =&gt; [2]<br>递归之前 =&gt; [2, 1]<br>递归之前 =&gt; [2, 1, 3]<br>递归之后 =&gt; [2, 1]<br>递归之后 =&gt; [2]<br>递归之前 =&gt; [2, 3]<br>递归之前 =&gt; [2, 3, 1]<br>递归之后 =&gt; [2, 3]<br>递归之后 =&gt; [2]<br>递归之后 =&gt; []<br>递归之前 =&gt; [3]<br>递归之前 =&gt; [3, 1]<br>递归之前 =&gt; [3, 1, 2]<br>递归之后 =&gt; [3, 1]<br>递归之后 =&gt; [3]<br>递归之前 =&gt; [3, 2]<br>递归之前 =&gt; [3, 2, 1]<br>递归之后 =&gt; [3, 2]<br>递归之后 =&gt; [3]<br>递归之后 =&gt; []<br>[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>47. 全排列 II</title>
    <link href="/2020/09/19/tech/leetcode/47-%E5%85%A8%E6%8E%92%E5%88%97-II/"/>
    <url>/2020/09/19/tech/leetcode/47-%E5%85%A8%E6%8E%92%E5%88%97-II/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></p><p>参考<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p>示例:</p><p>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 交换位置，动态维护数组</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permuteUnique</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">count</span>):</span><br>            <span class="hljs-keyword">if</span> count == self.length: <br>                res.append(nums.copy())<br>                <span class="hljs-keyword">return</span> <br>            <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">            为了同一个位置避免重复元素，下一次深搜是后一个位置，</span><br><span class="hljs-string">            前一个位置的元素记录不影响当前位置，</span><br><span class="hljs-string">            此处的引入的visited 对比全排列I，</span><br><span class="hljs-string">            在那个问题里用动态维护数组的方法不涉及visited。</span><br><span class="hljs-string">            &#x27;&#x27;&#x27;</span><br>            visited = <span class="hljs-built_in">set</span>() <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count, self.length):<br>                <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">in</span> visited: <span class="hljs-keyword">continue</span> <br>                visited.add(nums[i])<br>                nums[i], nums[count] = nums[count], nums[i]<br>                backtrack(count + <span class="hljs-number">1</span>)<br>                nums[i], nums[count] = nums[count], nums[i]<br>                visited.remove(nums[i]) <span class="hljs-comment"># 不需要回溯是因为这里的visited不是</span><br>        <br>        res = []<br>        self.length = <span class="hljs-built_in">len</span>(nums)<br>        backtrack(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一般回溯，visited标记原数组具体位置对应的元素</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[] vis;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这里的perm相当于path，用于记录符合条件的路径。</span><br><span class="hljs-comment">用一般回溯算法时，注意两点：</span><br><span class="hljs-comment">1. path为引用，</span><br><span class="hljs-comment">- 作为dfs参数传入和作为全局变量效果相同；</span><br><span class="hljs-comment">- 作为状态变量，dfs完要进行回溯重置；</span><br><span class="hljs-comment">2. 添加到res时要添加其拷贝，否则最后的res为null。</span><br><span class="hljs-comment">*/</span><br>        List&lt;Integer&gt; perm = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br>        Arrays.sort(nums);<br>        backtrack(nums, ans, <span class="hljs-number">0</span>, perm);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, <span class="hljs-keyword">int</span> idx, List&lt;Integer&gt; perm)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (idx == nums.length) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(perm));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (vis[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !vis[i - <span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            perm.add(nums[i]);<br>            vis[i] = <span class="hljs-keyword">true</span>;<br>            backtrack(nums, ans, idx + <span class="hljs-number">1</span>, perm);<br>            vis[i] = <span class="hljs-keyword">false</span>;<br>            perm.remove(idx);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <link href="/2020/09/19/tech/leetcode/%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <url>/2020/09/19/tech/leetcode/%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>示例 1:</p><p>输入: [10,2]<br>输出: “102”<br>示例 2:</p><p>输入: [3,30,34,5,9]<br>输出: “3033459”</p><p>提示:</p><p>0 &lt; nums.length &lt;= 100<br>说明:</p><p>输出结果可能非常大，所以你需要返回一个字符串而不是整数<br>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>本质上要求返回的结果是一个升序序列；</li><li>与正常的排序算法的区别在于前者每次比较两个数值的大小，而此题比较的是两个字符串的大小；</li><li>确定比较规则，修改比较处的排序代码即可。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span>(<span class="hljs-params">nums</span>):</span><br>            quick_sort_recursion(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)<br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort_recursion</span>(<span class="hljs-params">nums, left, right</span>):</span><br>            <span class="hljs-keyword">if</span> left &gt;= right: <span class="hljs-keyword">return</span> <br>            pivot_loc = partition(nums, left, right)<br>            quick_sort_recursion(nums, left, pivot_loc-<span class="hljs-number">1</span>)<br>            quick_sort_recursion(nums, pivot_loc+<span class="hljs-number">1</span>, right)<br>            <br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span>(<span class="hljs-params">nums, left, right</span>):</span><br>            pivot = nums[left]<br>            <span class="hljs-keyword">while</span> left &lt; right:<br>                <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[right] + pivot &gt;= pivot + nums[right]: right -= <span class="hljs-number">1</span> <span class="hljs-comment"># 排序规则发生改变</span><br>                nums[left] = nums[right]<br>                <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> nums[left] + pivot &lt;= pivot + nums[left]: left += <span class="hljs-number">1</span> <span class="hljs-comment"># 排序规则发生改变</span><br>                nums[right] = nums[left]<br>            nums[left] = pivot <br>            <span class="hljs-keyword">return</span> left <br>        <br>        nums = [<span class="hljs-built_in">str</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums]<br>        quick_sort(nums)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(nums)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 38. 字符串的排列</title>
    <link href="/2020/09/19/tech/leetcode/%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2020/09/19/tech/leetcode/%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h4><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</p><p>限制：</p><p>1 &lt;= s 的长度 &lt;= 8</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li><strong>定位</strong>：通过选择，定住左面m位字符，再    考虑后面n-m位字符；（分治）</li><li>定住的位数，可以通过visited记录；（剪枝）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;一般想法&#x27;&#x27;&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">s, path</span>):</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s: self.res.append(path)<br>            visited = <span class="hljs-built_in">set</span>()<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> visited: <span class="hljs-keyword">continue</span><br>                visited.add(s[i])<br>                backtrack(s[:i]+s[i+<span class="hljs-number">1</span>:], path + s[i])<br>        self.res = []<br>        n = <span class="hljs-built_in">len</span>(s)<br>        backtrack(s, <span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-keyword">return</span> self.res<br></code></pre></td></tr></table></figure><p>通过交换操作，优化时间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;推荐解法&#x27;&#x27;&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permutation</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:</span><br>        c, res = <span class="hljs-built_in">list</span>(s), []<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">x</span>):</span><br>            <span class="hljs-keyword">if</span> x == <span class="hljs-built_in">len</span>(c) - <span class="hljs-number">1</span>:<br>                res.append(<span class="hljs-string">&#x27;&#x27;</span>.join(c)) <span class="hljs-comment"># 添加排列方案</span><br>                <span class="hljs-keyword">return</span><br>            visited = <span class="hljs-built_in">set</span>()<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(x, <span class="hljs-built_in">len</span>(c)):<br>                <span class="hljs-keyword">if</span> c[i] <span class="hljs-keyword">in</span> visited: <span class="hljs-keyword">continue</span> <span class="hljs-comment"># 重复，因此剪枝</span><br>                visited.add(c[i])<br>                c[i], c[x] = c[x], c[i] <span class="hljs-comment"># 交换，将 c[i] 固定在第 x 位</span><br>                backtrack(x + <span class="hljs-number">1</span>) <span class="hljs-comment"># 开启固定第 x + 1 位字符</span><br>                c[i], c[x] = c[x], c[i] <span class="hljs-comment"># 恢复交换</span><br>        backtrack(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
    <link href="/2020/09/19/tech/leetcode/%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/09/19/tech/leetcode/%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>用哈希表更新字符的最新出现的位置；</p><p>用双指针记录当前最长字符串的长度；</p><p><strong>左指针位置由以下两个值取最大得到：1. 当前字符上一个出现的位置；2. 上一个出现重复字符的位置；</strong></p><p>复杂度：$T(n) = O(n); S(n) = O(n)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        hash_table = &#123;&#125;<br>        length = <span class="hljs-built_in">len</span>(s)<br>        res = <span class="hljs-number">0</span><br>        loc_start = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hash_table: hash_table[s[i]] = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> loc_start &lt; hash_table[s[i]]:<br>                cur = i - hash_table[s[i]]<br>                loc_start = hash_table[s[i]] <span class="hljs-comment"># 更新左指针位置</span><br>            <span class="hljs-keyword">else</span>:<br>                cur = i - loc_start<br>            <span class="hljs-keyword">if</span> cur &gt; res: res = cur <br>            hash_table[s[i]] = i <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <link href="/2020/09/18/tech/leetcode/%E5%89%91%E6%8C%87-Offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2020/09/18/tech/leetcode/%E5%89%91%E6%8C%87-Offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h4><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,5,6,4]</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= 数组长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>涉及数组元素两两比较，想归并排序；结合归并排序过程，求解问题。</p><p>复杂度：$T(n) = O(nlogn); S(n) = O(n)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reversePairs</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">nums, left, mid, right</span>):</span><br>            temp = nums.copy()<br>            i, j = left, mid + <span class="hljs-number">1</span><br>            k = i<br>            <span class="hljs-keyword">while</span> i &lt;= mid <span class="hljs-keyword">and</span> j &lt;= right:<br>                <span class="hljs-keyword">if</span> temp[i] &lt;= temp[j]:<br>                    nums[k] = temp[i]<br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    nums[k] = temp[j]<br>                    j += <span class="hljs-number">1</span><br>                    self.count += (mid - i + <span class="hljs-number">1</span>)<br>                k += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &lt;= mid:<br>                nums[k] = temp[i]<br>                k += <span class="hljs-number">1</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &lt;= right:<br>                nums[k] = temp[j]<br>                k += <span class="hljs-number">1</span><br>                j += <span class="hljs-number">1</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span>(<span class="hljs-params">nums, left, right</span>):</span><br>            <span class="hljs-keyword">if</span> left &lt; right:<br>                mid = left + (right - left) // <span class="hljs-number">2</span><br>                merge_sort(nums, left, mid)<br>                merge_sort(nums, mid+<span class="hljs-number">1</span>, right)<br>                merge(nums, left, mid, right)<br><br>        self.count = <span class="hljs-number">0</span><br>        merge_sort(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> self.count <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>背包问题集合</title>
    <link href="/2020/09/09/tech/leetcode/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2020/09/09/tech/leetcode/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;problem1</span><br><span class="hljs-string">0-1背包</span><br><span class="hljs-string">输出受限背包容量的最优价值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 二维dp</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">knapsack</span>(<span class="hljs-params">w, n, wt, val</span>):</span><br>    dp = [[<span class="hljs-number">0</span>] * (w + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>): <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, w+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j - wt[i-<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j-wt[i-<span class="hljs-number">1</span>]] + val[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j])<br>    <span class="hljs-keyword">return</span> dp[n][w]<br><span class="hljs-comment"># 空间优化</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">knapsack</span>(<span class="hljs-params">w, n, wt, val</span>):</span><br>    dp = [<span class="hljs-number">0</span>] * (w+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(w, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> wt[i] &lt;= j:<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - wt[i]] + val[i])<br>    <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br>    <br>n = <span class="hljs-number">3</span><br>w = <span class="hljs-number">4</span><br>wt = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]<br>val = [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(knapsack(w, n, wt, val)) <span class="hljs-comment"># 6</span><br><br><span class="hljs-comment">#####################################################################################</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;problem2</span><br><span class="hljs-string">0-1背包变体 </span><br><span class="hljs-string">leetcode416</span><br><span class="hljs-string">输出能否凑出具体背包容量</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># 二维dp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canPartition</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        nums_sum = <span class="hljs-built_in">sum</span>(nums)<br>        <span class="hljs-keyword">if</span> nums_sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        nums_sum //= <span class="hljs-number">2</span><br>        nums_len = <span class="hljs-built_in">len</span>(nums)<br>        dp = [[<span class="hljs-literal">False</span>] * (nums_sum + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_len + <span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_len + <span class="hljs-number">1</span>): dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_len + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_sum + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> j - nums[i-<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>: dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>                <span class="hljs-keyword">else</span>: dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] <span class="hljs-keyword">or</span> dp[i-<span class="hljs-number">1</span>][j-nums[i-<span class="hljs-number">1</span>]]<br>        <span class="hljs-keyword">return</span> dp[nums_len][nums_sum]<br><br><span class="hljs-comment"># 空间优化     </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canPartition</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>nums_len = <span class="hljs-built_in">len</span>(nums)<br>nums_sum = <span class="hljs-built_in">sum</span>(nums)<br><span class="hljs-keyword">if</span> nums_sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>nums_sum //= <span class="hljs-number">2</span><br>dp = [<span class="hljs-literal">False</span>] * (nums_sum + <span class="hljs-number">1</span>)<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_len):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums_sum, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> j - nums[i] &gt;= <span class="hljs-number">0</span>:<br>dp[j] = dp[j] <span class="hljs-keyword">or</span> dp[j - nums[i]]<br><span class="hljs-keyword">return</span> dp[nums_sum]<br><br><br><span class="hljs-comment">#####################################################################################</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27; problem3</span><br><span class="hljs-string">完全背包</span><br><span class="hljs-string">输出可能的组合总数</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 二维dp</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combinationSum</span>(<span class="hljs-params">candidates, target</span>):</span><br>    n = <span class="hljs-built_in">len</span>(candidates)<br>    dp = [[<span class="hljs-number">0</span>] * (target + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>):<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, target + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j - candidates[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>: dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]<br>            <span class="hljs-keyword">else</span>: dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - candidates[i - <span class="hljs-number">1</span>]]<br>    <span class="hljs-built_in">print</span>(dp)<br>    <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br><span class="hljs-comment"># 空间优化</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combinationSum</span>(<span class="hljs-params">candidates, target</span>):</span><br>    n = <span class="hljs-built_in">len</span>(candidates)<br>    dp = [<span class="hljs-number">0</span>] * (target + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, target + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> j - candidates[i] &gt;= <span class="hljs-number">0</span>: dp[j] += dp[j - candidates[i]]<br>    <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br>    <br>candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>target = <span class="hljs-number">7</span><br><span class="hljs-built_in">print</span>(combinationSum(candidates, target))<br><br><span class="hljs-comment">#####################################################################################</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;problem4</span><br><span class="hljs-string">完全背包变体</span><br><span class="hljs-string">leetcode39</span><br><span class="hljs-string">输出具体组合情况</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combinationSum</span>(<span class="hljs-params">self, candidates: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:</span><br>        dp = &#123;i:[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target+<span class="hljs-number">1</span>)&#125;<br>        dp[<span class="hljs-number">0</span>] = [[]]<br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> candidates:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num, target+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> dp[i-num]:<br>                    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> dp[i-num]:<br>                        dp[i].append([num]+a)<br>        <span class="hljs-keyword">return</span> dp[target]<br>        <br><span class="hljs-comment">#####################################################################################</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术沉淀</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
