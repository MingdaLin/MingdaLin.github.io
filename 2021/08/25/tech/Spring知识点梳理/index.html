

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/turing.png">
  <link rel="icon" href="/img/turing.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="丰碑无语，行胜于言">
  <meta name="author" content="Mingda">
  <meta name="keywords" content="">
  
  <title>Spring知识点梳理 - Mingda&#39;s Life</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.10","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>A day is a miniature of eternity.   一天是永恒的缩影</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Spring知识点梳理">
              
                Spring知识点梳理
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-25 14:24" pubdate>
        2021年8月25日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      79
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Spring知识点梳理</h1>
            
            <div class="markdown-body">
              <h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><h2 id="IoC简介"><a href="#IoC简介" class="headerlink" title="IoC简介"></a>IoC简介</h2><p>IoC：控制反转（Inversion of Control）容器，是一种设计思想。它意味着将对象交给容器控制，而不是开发者在对象内部控制。IoC是通过DI来实现的。</p>
<blockquote>
<p>谁控制谁？IoC容器来控制对象。<br>控制什么？控制了外部资源获取（不只是对象包括比如文件等）<br>为什么是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转。<br>什么被反转了？依赖对象的获取被反转了。</p>
</blockquote>
<p>DI：依赖注入（Dependency Injection），组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。IoC和DI其实是同一个概念的不同角度描述。</p>
<p>DI是通过IoC容器来实现的。</p>
<p><img src="/img/2021/%E4%BC%A0%E7%BB%9F%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8EIoC%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94.png" srcset="/img/loading.gif" lazyload alt="传统获取对象的方式与IoC方式对比"></p>
<h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><h3 id="Spring的两种容器"><a href="#Spring的两种容器" class="headerlink" title="Spring的两种容器"></a>Spring的两种容器</h3><p>IoC容器本质是一个工厂。Spring主要提供了两种类型的容器。</p>
<p><em><strong>BeanFactory</strong></em></p>
<p>BeanFactory是IoC容器的顶层接口，ApplicationContext是在BeanFactory之上创建的。</p>
<p>BeanFactory一般采用延迟初始化的策略。只有当客户端访问容器里的对象的时候，才对对象进行初始化和依赖注入。因此容器启动初期速度较快。</p>
<p><em><strong>ApplicationContext</strong></em></p>
<p>ApplicationContext 在BeanFactory功能至上，还有事件发布等功能。</p>
<p>ApplicationContext 在容器启动时就完成所有对象的初始化，因此启动需要的资源多，启动慢。  </p>
<h3 id="Ioc容器的初始化过程（Bean的加载过程）"><a href="#Ioc容器的初始化过程（Bean的加载过程）" class="headerlink" title="Ioc容器的初始化过程（Bean的加载过程）"></a>Ioc容器的初始化过程（Bean的加载过程）</h3><ul>
<li><p>获取资源；</p>
</li>
<li><p>获取BeanFactory；</p>
</li>
<li><p>根据BeanFactory创建BeanDefinitionReader对象，该Reader对象作为资源的解析器；</p>
</li>
<li><p>装载资源；</p>
<ul>
<li>资源定位：通过ResourceLoader加载外部资源，通过外部资源描述Bean对象</li>
<li>加载：通过资源解析器(BeanDefinitionReader)解析外部资源(Resource)，封装成一个BeanDefiniton对象；</li>
<li>注册：通过实现BeanDefinitionRegistry接口，将BeanDefinition注入到Map容器中；</li>
</ul>
</li>
</ul>
<h2 id="Bean的实例化过程（Bean的生命周期）"><a href="#Bean的实例化过程（Bean的生命周期）" class="headerlink" title="Bean的实例化过程（Bean的生命周期）"></a>Bean的实例化过程（Bean的生命周期）</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6929672218322731022">参考地址</a></p>
<p>Bean的实例化过程分为两个阶段：1、容器启动阶段；2、Bean的实例化阶段。Bean的整个生命周期体现在实例化阶段。</p>
<!-- 如果一上来问Bean的生命周期，容器的启动阶段可以不说 -->
<p>在容器启动阶段，要完成bean在Ioc容器的注册。Spring是通过<code>BeanDefinitionReader</code>将对象配置信息转换成<code>BeanDefinition</code>存在<code>BeanDefinationRegistry</code>里的HashMap容器（<code>BeanDefinition</code>是在IoC容器里对bean的封装）</p>
<p><img src="/img/2021/Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="Spring容器启动过程"></p>
<p>bean的生命周期``AbstractAutowireCapableBeanFactory.doCreateBean()`</p>
<ul>
<li>实例化<code>createBeanInstance()</code>： 该过程会返回一个BeanWrapper对象，是一个没有注入属性的裸露的bean<ul>
<li>如果存在 Supplier回调，则从Supplier进行初始化（Supplier是一个泛型接口，在构造BeanDefinition的时候会进行设置，用于指定创建bean的回调，指定后其他构造器和工厂方法都会没用）；</li>
<li>如果存在工厂方法，则使用工厂方法进行初始化</li>
<li>首先判断缓存，如果缓存中有解析过的构造函数，则用解析过的构造函数进行实例化；</li>
<li>如果缓存中没有，通过<code>SmartInstantiationAwareBeanPostProcessor</code>(<code>BeanPostProcessor</code>的子类)到构造器列表，进行实例化。</li>
</ul>
</li>
<li>注入属性<code>populateBean()</code>：将 BeanDefinition 中的属性值赋值给 BeanWrapper 实例对象<ul>
<li>在注入属性的时候可以按照名称注入，也可以按照类型注入；二者会统一注入到PropertyValues中；再将PropertyValues填充到BeanWrapper中。</li>
</ul>
</li>
<li>初始化<code>initializeBean()</code><ul>
<li>激活<code>Aware</code>方法（实现了Aware接口的方法可以通过Spring回调接受Spring容器的通知）<ul>
<li>通过BeanNameAware可以注入名称属性；</li>
<li>通过BeanClassLoaderAware可以注入类加载器属性；</li>
<li>通过BeanFactoryAware可以注入工厂属性；</li>
</ul>
</li>
<li>后置处理器应用<ul>
<li>比如在AOP中利用后置处理器进行增强操作</li>
</ul>
</li>
<li>激活自定义的<code>init</code>方法<ul>
<li>自定义初始化方法可以是通过实现InitializingBean接口，进行初始化</li>
<li>还可以使用init-method解析配置文件进行初始化</li>
</ul>
</li>
</ul>
</li>
<li>销毁</li>
</ul>
<p><img src="/img/2021/Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="Bean实例化过程"></p>
<h2 id="Bean的管理"><a href="#Bean的管理" class="headerlink" title="Bean的管理"></a>Bean的管理</h2><p> Spring通过Ioc容器对Bean进行管理。可以通过注解或者xml文件的方式进行配置。</p>
<p> 管理Bean常用的注解：</p>
<ul>
<li><code>@ComponentScan</code>用于声名扫描Bean的策略，对哪些包哪些类型的Bean进行扫描；</li>
<li><code>@Component``Repository``Service``Controller</code>用于声明Bean；</li>
<li><code>@Autowired``@Qualifier</code>用于注入Bean；<code>Autowired</code>按照Bean的类型进行匹配，如果同一类型的Bean有多个，可以通过<code>@Qualifier</code>按Bean的名称进行匹配；</li>
<li><code>@Scope</code>用于声明Bean的作用域，Bean默认是单例的</li>
<li><code>PostConstruct``PreDestory</code>用于声明Bean的生命周期，<code>PostConstruct</code>在Bean初始化后调用，<code>PreDestory</code>在销毁Bean之前调用；</li>
</ul>
<h2 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h2><p>依赖注入的三种方式？</p>
<h3 id="Spring是如何解决循环依赖的？"><a href="#Spring是如何解决循环依赖的？" class="headerlink" title="Spring是如何解决循环依赖的？"></a>Spring是如何解决循环依赖的？</h3><h4 id="Spring解决单例对象setter注入原理"><a href="#Spring解决单例对象setter注入原理" class="headerlink" title="Spring解决单例对象setter注入原理"></a>Spring解决单例对象setter注入原理</h4><p>Spring只能解决setter方法注入的单例对象的循环依赖问题。（构造器注入的方式已经在调用构造器构建bean的时候注入好了，而非单例的对象都是）</p>
<p>三级缓存：</p>
<ul>
<li>一级缓存<code>SingletonObjects</code> 存的是已经初始化完成的bean</li>
<li>二级缓存<code>earlySingletonObjects</code>  缓存的是提前曝光的bean，但是还没有完成初始化</li>
<li>三级缓存<code>SingletonFactories</code> 存的是函数接口beanfactory，而非bean实例，提供一个提前引用</li>
</ul>
<p><strong>调用构造器构建对象</strong> &gt; <strong>实例化</strong> &gt; <u>三级缓存</u> &gt;<strong>注入属性</strong> &gt; <u>二级缓存</u> &gt; <strong>初始化</strong> &gt; <u>一级缓存</u> &gt; <strong>完成</strong></p>
<h4 id="为什么是三级缓存，不是一级、二级缓存？"><a href="#为什么是三级缓存，不是一级、二级缓存？" class="headerlink" title="为什么是三级缓存，不是一级、二级缓存？"></a>为什么是三级缓存，不是一级、二级缓存？</h4><p>一级缓存：要缓存正在实例化阶段但未完成初始化的bean，但这种情况只能解决单线程的循环依赖问题，在多线程环境下，线程可能通过缓存获得未注入属性的bean；</p>
<p>二级缓存：将初始化完成的bean设为一级缓存，将正在实例化阶段但未初始化的bean设为二级缓存，这种情况是可以解决没有AOP场景下的循环依赖的。</p>
<p>三级缓存：对于有AOP的场景，在通过beanFactory获取代理对象的时候，为了保证生成的代理对象是单例的，需要再在中间加一层缓存，去查二级缓存的代理对象。</p>
<h3 id="BeanFactory和ApplicationContext的区别？"><a href="#BeanFactory和ApplicationContext的区别？" class="headerlink" title="BeanFactory和ApplicationContext的区别？"></a>BeanFactory和ApplicationContext的区别？</h3><p>1、加载策略：BeanFactory采用的是延迟加载策略，使用到某个bean的时候才会对bean进行实例化，而ApplicationContext是在容器启动时，一次性创建所有的bean；</p>
<p>2、对BeanPostProcessor的支持：BeanFactory需要手动注册（调用<code>addBeanPostProcessor()</code>方法），而ApplicationContext是自动注册；</p>
<p>3、BeanFactory面对的是Spring框架，ApplicationContext主要面对开发者，提供了更多的扩展功能（事件发布、国际化信息），因此开发尝试用的容器是ApplicationContext。</p>
<h3 id="BeanFactory继承关系"><a href="#BeanFactory继承关系" class="headerlink" title="BeanFactory继承关系"></a>BeanFactory继承关系</h3><p>BeanFactory是一个一级接口，继承BeanFactory的二级接口有三个，分别是ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory。</p>
<ul>
<li>ListableBeanFactory：将bean列表化，不需要单个的获取bean，提供了如根据类型、注解获取beanNames的方法；</li>
<li>HierarchicalBeanFactory：表示bean有继承关系，可以获取父类BeanFactory的方法；</li>
<li>AutowireCapableBeanFactory：定义bean的自动装配规则，提供了bean创建、配置、注入、销毁等操作。</li>
</ul>
<p>对于后面的实现子类有一个比较重要的是<code>AbstractAutowireCapableBeanFactory</code>，该实现类用于bean的实例化。</p>
<h3 id="创建对象的策略"><a href="#创建对象的策略" class="headerlink" title="创建对象的策略"></a>创建对象的策略</h3><p>“策略模式”的实例化方式的选取策略：根据用户是否使用<code>replace</code>或<code>lookup</code>的配置方法，如果没有使用，用反射创建，否则用CGLIB。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/javastack/p/13431216.html">参考</a></p>
<h2 id="附：概念解释"><a href="#附：概念解释" class="headerlink" title="附：概念解释"></a>附：概念解释</h2><h3 id="BeanWrapper"><a href="#BeanWrapper" class="headerlink" title="BeanWrapper"></a>BeanWrapper</h3><p>BeanWrapper 是实例化后的Bean实例，相当于一个代理类，spring委托BeanWrapper进行属性填充。</p>
<h3 id="Aware接口"><a href="#Aware接口" class="headerlink" title="Aware接口"></a>Aware接口</h3><p>Aware接口是Spring提供的一个标识接口，Spring 容器在初始化主动检测当前 bean 是否实现了 Aware 接口，如果实现了则回调(<code>invokeAwareMethods</code>)其 set 方法将相应的参数 (比如<code>beanName</code>、<code>beanClassLoader</code>、<code>BeanFactory</code> 等)设置给该 bean 。</p>
<p>Aware接口就是在bean初始化的时候为bean注入属性的。</p>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>BeanPostProcessor是一个接口，实现了该接口的bean在初始化前后可以通过BeanPostprocessor进行一些配置和增加一些处理逻辑。</p>
<p>BeanPostProcessor会根据容器注册，注册完后会应用于同一容器内的bean。ApplicationContext 会自动检测所有实现了 BeanPostProcessor 接口的 bean，并完成注册，但是使用 BeanFactory 容器时则需要手动调用 <code>addBeanPostProcessor()</code> 完成注册。</p>
<p>BeanPostProcessor的原理：1、对于BeanFactory容器来说，在bean初始化的时候会分别调用BeanPostProcessor的前置处理方法和后置处理方法，在处理方法内部，会遍历Spring容器里完成注册的BeanPostProcessor，如果有，就调用处理方法去初始化一个增强的bean，否则直接初始化返回一个普通的bean。而注册BeanPostProcessor需要通过<code>addBeanPostProcessor()</code>方法完成，<code>getBean()</code>是不能注册BeanPostProcessor的；2、对于ApplicationContext容器来说，会通过调用<code>registerBeanPostProcessors()</code>自动检测BeanPostProcessor并注册到ApplicationContext容器中，同时应用到创建的bean中。</p>
<h3 id="InitializingBean-amp-init-method"><a href="#InitializingBean-amp-init-method" class="headerlink" title="InitializingBean &amp; init-method"></a>InitializingBean &amp; init-method</h3><p>bean在初始化阶段initializeBean调用后置处理器的前置后置方法中间，会调用<code>invokeInitMethods()</code>来检测bean是否实现了InitializingBean接口，如果实现了则进一步调用<code>afterPropertiesSet()</code>方法对bean对象的状态进行进一步的调整。</p>
<p>相对于initializeBean要bean实现方法， init-method只需要在xml配置文件中进行绑定，通过反射执行可以完成对象的状态更新。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a target="_blank" rel="noopener" href="http://www.4k8k.xyz/article/weixin_38405253/116279890">http://www.4k8k.xyz/article/weixin_38405253/116279890</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cmsblogs.com/article/1391375268060467200">https://www.cmsblogs.com/article/1391375268060467200</a></li>
<li>《Spring5核心原理与30个类手写实战.pdf》</li>
</ol>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><h2 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h2><!-- 背住！一言毕之AOP -->

<p>spring的AOP就是把切面（Advice、Advisor）织入（Weaving）到满足切点（PointCut）限定条件的连接点（JoinPoint）的过程。</p>
<!-- option: 介绍下AOP的术语 -->

<p>所谓切面是通知和切点的结合，通常我们是面对切面进行编程的；通知是指切面对连接点的一组增强处理的操作；切点是匹配连接点的断言，通过切点表达式和通知相关联；连接点是指程序在执行时的行为，一般对应目标对象的方法。</p>
<!-- 接着再讲一下Spring是如何实现AOP的 -->
<!-- 首先要讲的是创建代理对象的时机——是在初始化Bean的时候通过后置处理器操作的 -->

<p>Spring在Bean的创建过程中的初始化阶段的后置处理（<code>BeanPostProcessor</code>接口的<code>postProcessAfterInitialization</code>方法）的时候，在满足条件的情况下会对Bean进行AOP增强。</p>
<p>从代码实现上具体来说就是：Spring通过<code>AbstractAutowireCapableBeanFactory</code>抽象类对Bean进行创建和依赖注入。在该抽象类里实现了<code>doCreateBean()</code>方法，在该方法内部又是通过<code>initializeBean()</code>方法为Bean添加后置处理器(<code>BeanPostProcessor</code>)。</p>
<!-- 接着要说后置处理方法的实现逻辑 -->

<p>对于<code>BeanPostProcessor</code>接口的核心实现就是<code>AbstractAutoProxyCreator</code>的<code>wrapIfNecessary</code>方法（有不同子类的实现，以<code>AbstractAutoProxyCreator</code>为例）。该方法主要做的事情是，找到容器中能够应用到当前所创建的bean的切面，再利用切面为bean创建代理对象；在创建代理对象的时候，用的是代理工厂获取的代理对象(<code>proxyFactory.getProxy()</code>)，在底层对于JDK代理对象还是CGLib代理对象的选择是通过<code>DefaultAopProxyFactory</code>的<code>createAopProxy()</code>方法判断的。</p>
<blockquote>
<p>Spring在target实现了接口的情况下默认使用JDK动态代理；也可以通过配置强制使用CGLib；如果target没有实现接口，则使用CGLib。</p>
</blockquote>
<!-- JDK具体如何创建代理对象的，又回到JDK创建代理对象的原理了。可以再结合JDK和CGLib创建代理对象讲一下 -->
<!-- 至此，代理对象就生成完了，接下来要讲的是切面是如何织入的 -->

<p><code>InvocationHandler</code>是JDK动态代理的核心，生成的代理对象的方法调用会委派到<code>invoke()</code>方法中去，因此Spring将切面织入连接点的核心逻辑是体现在<code>invoke()</code>方法中的。Spring实现<code>invoke()</code>方法的核心逻辑是，获取应用在此方法上的拦截器链(Interceptor Chain)，如果有拦截器，则应用拦截器执行连接点；如果没有拦截器，则通过反射执行连接点。</p>
<!-- 下面这些可以不说了，作为补充，写一下 -->
<!-- 拦截器链是如何获取的，以及拦截器链是如何作用的？ -->

<p>拦截器链的获取是通过一个工厂方法(<code>AdvisorChainFactory</code>的<code>getInterceptorsAndDynamicInterception-Advice()</code>方法)完成的，该方法完成了两件事：1、将拦截器链进行缓存；2、得到一个拦截器列表（连接点(JoinPoint)或目标对象(Target)的通知(Advisor)都会转换成<code>MethodInterceptor</code>）；在具体使用拦截器链的时候，通过创建一个<code>MethodInocation</code>对象，执行<code>proceed()</code>方法完成织入的。</p>
<p><em><strong>参考资料</strong></em></p>
<ol>
<li>《Spring5核心原理与30各类手写实战.pdf》</li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6877137943149051911#heading-2">https://juejin.cn/post/6877137943149051911#heading-2</a></li>
</ol>
<h3 id="AOP-amp-Spring-AOP"><a href="#AOP-amp-Spring-AOP" class="headerlink" title="AOP &amp; Spring AOP"></a>AOP &amp; Spring AOP</h3><p>AOP(Aspect oriented programming)面向切面编程，是OOP的一种补充。</p>
<p>OOP的一大特性——继承，体现了对象之间的“上下关系”，而AOP的切面之间则可以为分散的对象提供公共行为，是一种“左右关系”。</p>
<p>利用AOP可以为业务逻辑进行解耦，提高开发效率。</p>
<p>spring aop 有两种实现方式：</p>
<ul>
<li>JDK动态代理:这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默 认采用这种方式，在接口的代理实例中织入代码。 </li>
<li>CGLib动态代理:采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。</li>
</ul>
<p><img src="/img/2021/AOP&OOP.png" srcset="/img/loading.gif" lazyload alt="AOP &amp; OOP"></p>
<h2 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h2><ol>
<li>切面（ Aspect）: 切面是通知和切点的结合；对应Spring中的注解@Aspect修饰的一个类；可以由ApplicationContext中的<code>&lt;aop:aspect&gt;</code>来配置；</li>
<li>通知 （Advice）: 指切面对连接点的操作，为AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理；通知类型，主要有以下几种：<ul>
<li>Before ：前置通知，在连接点方法前调用；对应Spring中@Before注解；</li>
<li>After ：后置通知，在连接点方法后调用；对应Spring中的@After注解；</li>
<li>AfterReturning：返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常；对应Spring中的@AfterReturning注解；</li>
<li>AfterThrowing：异常通知，当连接点方法异常时调用；对应Spring中的@AfterThrowing注解；</li>
<li>Around：环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法；对应Spring中的@Around注解；</li>
</ul>
</li>
<li>切点（Pointcut）: 匹配连接点的断言，通过一个切点表达式和通知关联；</li>
<li>连接点（JointPoint）: 指程序执行过程中的某一行为，可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用，可以说目标对象中的方法就是一个连接点；</li>
<li>目标对象（Target object）：即被代理的对象；</li>
<li>代理对象（AOP proxy）：包含了目标对象的代码和增强后的代码的那个对象；</li>
</ol>
<h2 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h2><h3 id="AOP的实现方式"><a href="#AOP的实现方式" class="headerlink" title="AOP的实现方式"></a>AOP的实现方式</h3><p>AOP的实现核心在于如何把切面织入到核心业务逻辑中。Java提供了3种方式：</p>
<ol>
<li>在编译期把切面编入到字节码，通过使用关键字来实现织入（AspectJ使用的是aspect关键字）；</li>
<li>在目标类被装入JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li>
<li>在运行期通过JVM动态代理织入。</li>
</ol>
<p>Spring采用动态代理方式实现AOP。当代理接口实现类的时候默认用JDK，代理普通类用CGLIB。</p>
<h3 id="JDK实现"><a href="#JDK实现" class="headerlink" title="JDK实现"></a>JDK实现</h3><p><code>JDK</code>的动态代理是基于<strong>反射</strong>实现。<code>JDK</code>通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的<code>InvocationHandler</code>接口的<code>invoke</code>方法。<strong>并且这个代理类是Proxy类的子类</strong>（记住这个结论，后面测试要用）。这就是<code>JDK</code>动态代理大致的实现方式。</p>
<h3 id="CGLIB实现"><a href="#CGLIB实现" class="headerlink" title="CGLIB实现"></a>CGLIB实现</h3><p>  <code>CGLib</code>实现动态代理的原理是，底层采用了<code>ASM</code>字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为<code>Spring</code>中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。</p>
<h2 id="Spring-AOP的使用"><a href="#Spring-AOP的使用" class="headerlink" title="Spring AOP的使用"></a>Spring AOP的使用</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/joy99/p/10941543.html">参考实例1</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35387940/article/details/85261279">参考实例2</a></p>
<h2 id="问题整理-1"><a href="#问题整理-1" class="headerlink" title="问题整理"></a>问题整理</h2><h3 id="如何配置CGLIB生成代理？"><a href="#如何配置CGLIB生成代理？" class="headerlink" title="如何配置CGLIB生成代理？"></a>如何配置CGLIB生成代理？</h3><p>前面说过Spring使用动态代理或是CGLIB生成代理是有规则的，高版本的Spring会自动选择是使用动态代理还是CGLIB生成代理内容，当然我们也可以强制使用CGLIB生成代理，那就是<a href="aop:config">aop:config</a>里面有一个”proxy-target-class”属性，这个属性值如果被设置为true，那么基于类的代理将起作用，如果proxy-target-class被设置为false或者这个属性被省略，那么基于接口的代理将起作用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyly/p/13171660.html">https://www.cnblogs.com/zyly/p/13171660.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/joy99/p/10941543.html">https://www.cnblogs.com/joy99/p/10941543.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/spring/spring-aop.html">https://www.pdai.tech/md/spring/spring-aop.html</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html</a></li>
</ol>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="问题整理-2"><a href="#问题整理-2" class="headerlink" title="问题整理"></a>问题整理</h2><h3 id="MVC简介"><a href="#MVC简介" class="headerlink" title="MVC简介"></a>MVC简介</h3><h3 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h3><p>执行流程：</p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器</li>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet</li>
<li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li>
<li>执行处理器(Controller，也叫后端控制器)</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体View</li>
<li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</li>
<li>DispatcherServlet响应用户</li>
</ol>
<p><img src="/img/2021/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="SpringMVC执行流程"></p>
<p>组件说明：</p>
<ul>
<li><p>DispatcherServlet：前端控制器<br>用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>
</li>
<li><p>HandlerMapping：处理器映射器<br>HandlerMapping负责根据用户请求url找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>
</li>
<li><p>Handler：处理器<br>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</p>
</li>
<li><p>HandlAdapter：处理器适配器<br>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>
</li>
<li><p>ViewResolver：视图解析器<br>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p>View：视图<br>springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</p>
</li>
</ul>
<h3 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h3><p>SpringMVC拦截器要实现<code>HandlerInterceptor</code>接口，包含三个方法：<code>preHandle()</code>、<code>postHandle()</code>、<code>afterCompletion()</code>。</p>
<p>开发拦截器：实现handlerInterceptor接口，重写三个接口方法。</p>
<p>注册拦截器：定义配置类，让它实现<code>WebMvcConfigurer</code>接口，在接口的<code>addInterceptors</code>方法中，注册拦截器，并定义该拦截器匹配哪些请求路径。</p>
<h3 id="MVC拦截器-amp-Filter-amp-AOP"><a href="#MVC拦截器-amp-Filter-amp-AOP" class="headerlink" title="MVC拦截器 &amp; Filter &amp; AOP"></a>MVC拦截器 &amp; Filter &amp; AOP</h3><ul>
<li>Filter：如果对所有的请求（包括静态资源）进行拦截，可以使用Filter；和框架无关，过滤器拦截的是URL，可以控制最初的http请求，但是更细一点的类和方法控制不了。</li>
<li>Interceptor：SpringMVC一般是对Controller进行拦截的；拦截器拦截的也是URL，拦截器有三个方法，相对于过滤器更加细致，有被拦截逻辑执行前、后等。</li>
<li>AOP: 如果对Controller外的其他bean进行拦截，可以使用SpringAOP；面向切面拦截的是类的元数据（包、类、方法名、参数等） 相对于拦截器更加细致，而且非常灵活，拦截器只能针对URL做拦截，而AOP针对具体的代码，能够实现更加复杂的业务逻辑。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>filter</th>
<th>interceptor</th>
<th>aop</th>
</tr>
</thead>
<tbody><tr>
<td>使用方式</td>
<td>函数回调</td>
<td>反射机制</td>
<td>动态代理</td>
</tr>
<tr>
<td>使用场景</td>
<td>处理URL，过滤一些非法URL、非法字符，</td>
<td>日志记录、权限检查</td>
<td>日志记录、性能监控、权限控制、缓存优化、事务管理（声明式事务）</td>
</tr>
<tr>
<td>粒度</td>
<td>粗</td>
<td>中</td>
<td>细</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/9554509.html">filter interceptor 使用场景</a> –&gt;</p>
<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p><code>@RequestMapping</code>是用于处理请求地址映射的注解，请求地址为类地址和方法地址的拼接（如果类上没有该注解则直接为方法地址）。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li><code>value</code>：指定请求的实际地址，指定的地址可以是URI Template 模式；</li>
<li><code>method</code>： 指定请求的method类型， GET、POST、PUT、DELETE等；</li>
<li><code>consumes</code>： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</li>
<li><code>produces</code>: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li>
<li><code>params</code>： 指定request中<strong>必须</strong>包含某些参数值时，才让该方法处理。</li>
<li><code>headers</code>： 指定request中<strong>必须</strong>包含某些指定的header值，才能让该方法处理请求。</li>
</ol>
<blockquote>
<p>在设置<code>value</code>参数的时候，可能涉及的相关注解为：<a href="#PathVariable">@PathVariable</a>；<br>在设置<code>params</code>参数的时候，可能涉及的相关注解为：<a href="#RequestParam">@RequestParam</a>；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// value可以是一个具体的URI，也可以是含有变量的URI（URI Template Patterns with Path Variables–restful风格）。</span><br><span class="hljs-meta">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testPathVariable</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id2)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;testPathVariable: &quot;</span> + id2);<br>    <span class="hljs-keyword">return</span> SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/J080624/article/details/55193269">参考</a></p>
<h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p><code>@PathVariable</code>用来获得请求url中的动态参数，一般修饰于方法中的入参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;  <br><br>     <span class="hljs-meta">@RequestMapping(value=&quot;/user/&#123;userId&#125;/roles/&#123;roleId&#125;&quot;,method = RequestMethod.GET)</span>  <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLogin</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> String userId,  </span></span><br><span class="hljs-function"><span class="hljs-params">         <span class="hljs-meta">@PathVariable(&quot;roleId&quot;)</span> String roleId)</span></span>&#123;<br>           <br>         System.out.println(<span class="hljs-string">&quot;User Id : &quot;</span> + userId);  <br>         System.out.println(<span class="hljs-string">&quot;Role Id : &quot;</span> + roleId);  <br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;  <br>     <br>     &#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p><code>@RequestParam</code>用于获取request请求的参数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CopperVO&gt; <span class="hljs-title">getOpList</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-meta">@RequestParam(value = &quot;pageIndex&quot;, required = false)</span> Integer pageIndex,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-meta">@RequestParam(value = &quot;pageSize&quot;, required = false)</span> Integer pageSize)</span> </span>&#123;<br><br> &#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="ResponseBody-amp-RequestBody"><a href="#ResponseBody-amp-RequestBody" class="headerlink" title="@ResponseBody &amp; @RequestBody"></a>@ResponseBody &amp; @RequestBody</h2><p><code>@ResponseBody</code>用于将Controller的方法返回的对象，根据HTTP Request Header的Accept的内容,通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p>
<p><code>@ResponseBody</code>使用在返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用.</p>
<p><code>@RequestBody</code>用于将Controller的方法参数，根据HTTP Request Header的content-Type的内容,通过适当的HttpMessageConverter转换为JAVA类</p>
<p><code>@RequestBody</code>使用在POST或者PUT的数据是JSON格式或者XML格式,而不是普通的键值对形式.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/testRequestBody&quot;, method= RequestMethod.POST)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">testRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Person p)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;creating a employee:&quot;</span> + p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;   <br></code></pre></td></tr></table></figure>

<p><img src="/img/2021/@ResponseBody&@RequestBody%E4%BD%BF%E7%94%A8.png" srcset="/img/loading.gif" lazyload alt="数据的格式的转换过程"></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7097fea8ce3f">参考</a></p>
<h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p><code>@RestController</code>一般是使用在类上的，它表示的意思其实就是结合了<code>@Controller</code>和<code>@ResponseBody</code>两个注解，如果哪个类下的所有方法需要返回json数据格式的，就在哪个类上使用该注解，具有</p>
<p><code>@ResponseBody</code>，一般是使用在单独的方法上的，需要哪个方法返回json数据格式，就在哪个方法上使用，具有针对性，统一性；</p>
<p>使用了<code>@RestController</code>注解之后，其本质相当于在该类的所有方法上都统一使用了<code>@ResponseBody</code>注解，所以该类下的所有方法都会返回json数据格式，输出在页面上，而不会再返回视图。</p>
<h1 id="Spring-MyBatis"><a href="#Spring-MyBatis" class="headerlink" title="Spring MyBatis"></a>Spring MyBatis</h1><!-- toread：https://juejin.cn/post/6844904079827664903 -->

<!-- toread：https://www.w3cschool.cn/mybatis/mybatis-dyr53b5w.html -->

<h2 id="问题整理-3"><a href="#问题整理-3" class="headerlink" title="问题整理"></a>问题整理</h2><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM "></a>ORM <!--todo：了解ORM框架--></h3><p>MyBatis属于半ORM框架，MyBatis并没有将java对象与数据库关联起来，而是将java方法和sql语句关联起来。</p>
<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h3><p><code>#&#123;&#125;</code>是预编译处理，<code>$&#123;&#125;</code>是字符串替换。</p>
<p>使用<code>#&#123;&#125;</code>设置参数，mybatis会创建一个预编译的sql，用<code>?</code>将<code>#&#123;&#125;</code>替换，在执行sql的时候，会通过PreparedStatement的set方法进行赋值；</p>
<p>使用<code>$&#123;&#125;</code>设置参数，mybatis会直接将其替换成变量的值，然后执行sql。</p>
<p>使用预编译的方式可以提高sql执行效率，并且更加安全。<!--预编译为什么会提高sql执行效率？--></p>
<p><code>$&#123;&#125;</code>使用的一些特殊场景：根据不同条件生成不同的动态的列，然后根据列名排序，在传递列名的时候就不能用预编译的方式了。</p>
<h3 id="Mapper接口绑定方式"><a href="#Mapper接口绑定方式" class="headerlink" title="Mapper接口绑定方式"></a>Mapper接口绑定方式</h3><ol>
<li>通过注解：在接口的方法上面添加@Select@Update等注解，里面写上对应的SQL语句进行SQL语句的绑定。</li>
<li>通过xml文件绑定：通过配置文件的namespac标签指定对应的接口的全路径名</li>
</ol>
<h3 id="Mapper的CRUD配置属性"><a href="#Mapper的CRUD配置属性" class="headerlink" title="Mapper的CRUD配置属性"></a>Mapper的CRUD配置属性</h3><p>select：</p>
<ul>
<li>id</li>
<li>parameterType：参数类型</li>
<li>resultType/resultMap：返回类型</li>
<li>useCache：二级缓存</li>
<li>flushCache：刷新缓存</li>
</ul>
<p>update/insert/delete：</p>
<ul>
<li>id</li>
<li>parameterType</li>
<li>flushCache</li>
<li>statementType：Statement、PreparedStatement、CallableStatement</li>
<li>timeout</li>
</ul>
<h3 id="一对多关联查询"><a href="#一对多关联查询" class="headerlink" title="一对多关联查询"></a>一对多关联查询</h3><p>通过collection标签实现。</p>
<ol>
<li>首先在主表对应的实体类中增加集合的属性；</li>
<li>在mapper配置文件里，用select标签定义一个主表的查询方法，返回结果通过resultmap进行映射；</li>
<li>在collection标签里映射子表的属性，属性名property、集合元素类型javaType、实体类型ofType；</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.dy.dao.StudentDao&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 这儿定义一个resultMap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentMap&quot;</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">            数据库中主键是id, 但是我这儿却是指定idCard为主键，为什么？ </span><br><span class="hljs-comment">            刚刚讲了，id用来表示唯一性， 我们可以认为只要idCard一样，那么他就是同一个学生。</span><br><span class="hljs-comment">            如果此处用数据库中id， 那么mybatis将会认为数据库中每条记录都是一个student, 这显然不符合逻辑</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;idCard&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stu_id_card&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stu_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stu_name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deleteFlag&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stu_delete_flg&quot;</span>/&gt;</span><br>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">idArg</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;STUDENT_ID&quot;</span>/&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;STUDENT_NAME&quot;</span>/&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;STUDENT_SEX&quot;</span>/&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Date&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;STUDENT_BIRTHDAY&quot;</span>/&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span><br>        <br>        <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">            这儿就是实现一对多的关键。 </span><br><span class="hljs-comment">            在Student中，courseList为List&lt;Course&gt;, 因此，ofType也应该与之对应（当然，我用了别名，不然要蛋疼的写全名了）。</span><br><span class="hljs-comment">            collection的子标签是在指定Course的映射关系（由于Course的javabean的属性名与数据库的列名不一致）</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;courseList&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;stu_course_id&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Course&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;course_id&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;course_name&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deleteFlag&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;course_delete_flg&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 这儿将返回类型设置成了上面指定的studentMap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findStudentById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentMap&quot;</span>&gt;</span><br>        SELECT s.*, c.* FROM t_student s LEFT JOIN t_course c ON s.stu_course_id=c.course_id WHERE s.stu_id_card=#&#123;idCard&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">        sql –可以重用的SQL块，可以被其他数据库操作语句引用。</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span> userid,username,password<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryUsers&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;UserDto&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;UserDto&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>	select <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;userColumns&quot;</span>/&gt;</span> from t_user t where t.username = #&#123;username&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>mybatis有两级缓存。</p>
<p>一级缓存：默认启动，不能关闭；sqlsession级别；在同一个sqlsession中查询时，会根据方法和参数计算key，通过map查找和存储；</p>
<p>二级缓存：sqlsessionfactory级别；需要在全局配置settings中将cacheEnabled设为true；和命名空间绑定，需要在mapper中配置cache的标签。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/">技术沉淀</a>
                    
                      <a class="hover-with-bg" href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/Java/">Java</a>
                    
                  </div>
                
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/26/tech/%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86-%E7%A4%BE%E5%8C%BA%E8%AE%BA%E5%9D%9B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">项目梳理-社区论坛系统</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/20/tech/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A2%B3%E7%90%86/">
                        <span class="hidden-mobile">Java多线程梳理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
