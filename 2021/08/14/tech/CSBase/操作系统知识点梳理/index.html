

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/turing.png">
  <link rel="icon" href="/img/turing.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="丰碑无语，行胜于言">
  <meta name="author" content="Mingda">
  <meta name="keywords" content="">
  
  <title>操作系统知识点梳理 - Mingda&#39;s Life</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.10","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>A day is a miniature of eternity.   一天是永恒的缩影</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="操作系统知识点梳理">
              
                操作系统知识点梳理
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-14 19:11" pubdate>
        2021年8月14日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      75
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统知识点梳理</h1>
            
            <div class="markdown-body">
              <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><p>操作系统是管理硬件和软件的一种应用程序，它为计算机硬件和软件提供了一种中间层，使应用软件和硬件进行分离，让我们无需关注硬件的实现，把关注点更多放在软件应用上。</p>
<h3 id="操作系统是干什么的？"><a href="#操作系统是干什么的？" class="headerlink" title="操作系统是干什么的？"></a>操作系统是干什么的？</h3><p>管理计算机资源，这些资源包括 CPU、内存、磁盘驱动器、打印机等。<br>提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁。<br>为其他软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。</p>
<h3 id="用户态和核心态"><a href="#用户态和核心态" class="headerlink" title="用户态和核心态"></a>用户态和核心态</h3><p>用户态和内核态是操作系统的两种运行状态。</p>
<p><em><strong>内核态</strong></em></p>
<p> 处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</p>
<p><em><strong>用户态</strong></em></p>
<p> 处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</p>
<p><em><strong>为什么要有用户态和内核态？</strong></em></p>
<p> 这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。</p>
<p><em><strong>用户态和内核态是如何切换的？</strong></em></p>
<p>只能<code>系统调用</code>才能操作用户态与内核态的切换，而只有<code>操作系统</code>才能操作系统调用。</p>
<p>用户态 -&gt; 内核态 的工作流程：</p>
<ol>
<li>首先用户程序会调用 glibc 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li>
<li>glibc 库知道针对不同体系结构调用系统调用的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li>
<li>然后，glibc 库调用软件中断指令(SWI) ，这个指令通过更新 CPSR 寄存器将模式改为超级用户模式，然后跳转到地址 0x08 处。</li>
<li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li>
<li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 vector_swi()。</li>
<li>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 sys_call_table 的索引，调转到系统调用函数。</li>
<li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li>
</ol>
<p><img src="/img/2021/%E7%94%A8%E6%88%B7%E6%80%81-%3E%E5%86%85%E6%A0%B8%E6%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="用户态-&gt;内核态工作流程"></p>
<p><em><strong>内核</strong></em></p>
<p>内核是一个计算机程序，它是操作系统的核心，可以控制操作系统中所有的内容。内核通常是在 <code>boot loader</code>装载程序之前加载的第一个程序。</p>
<blockquote>
<p>boot loader又被称为引导加载程序，能够将计算机的操作系统放入内存中。在电源通电或者计算机重启时，BIOS会执行一些初始测试，然后将控制权转移到引导加载程序所在的主引导记录(MBR) 。</p>
</blockquote>
<h3 id="操作系统启动过程"><a href="#操作系统启动过程" class="headerlink" title="操作系统启动过程"></a>操作系统启动过程</h3><!--todo-->

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p><em><strong>进程</strong></em></p>
<p>进程就是正在执行程序的实例，比如说 Web 程序就是一个进程，shell 也是一个进程，文章编辑器 typora 也是一个进程。</p>
<p><em><strong>进程表</strong></em></p>
<p>操作系统为了跟踪每个进程的活动状态，维护了一个进程表。在进程表的内部，列出了每个进程的状态以及每个进程使用的资源等。</p>
<p><em><strong>进程控制块（PCB）</strong></em></p>
<p>PCB是进程的唯一标识，系统通过PCB来控制和管理进程的状态。</p>
<p>PCB主要包含的信息：进程描述信息、进程控制和管理信息、资源分配清单、处理机相关信息。</p>
<blockquote>
<p>PCB里含有进程的标识信息、状态信息、资源的占有情况等。</p>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><em><strong>线程的实现方式</strong></em></p>
<ol>
<li>用户级线程：线程的控制和管理发生在应用程序，内核不感知。而且一般从单线程开始，运行过程中派生出其他线程。</li>
<li>内核级线程：线程的控制和管理发生在内核，应用程序不感知。</li>
<li>组合方式：线程的创建、调度、同步都发生在用户空间，一个内核线程映射多个用户线程。</li>
</ol>
<p><em><strong>线程模型</strong></em></p>
<ol>
<li>多对一：所有用户线程都对应一个内核线程。<strong>线程管理在用户空间</strong>。优点是效率高，缺点是内核线程阻塞，所有用户线程都受到影响。</li>
<li>一对一：一个用户线程对应一个内核线程。<strong>线程管理在内核空间</strong>。有点是并发能力强，缺点是开销大，程序性能低。</li>
<li>多对多：少量内核线程映射多量的用户线程。取二者所长，弥补二者所短。</li>
</ol>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p><em><strong>进程和线程的区别</strong></em></p>
<p>资源和调度：进程是资源分配的最小单位；线程是cpu调度的最小单位。</p>
<p>并发：进程是用来实现各应用程序并发的，线程是为了提高并发性能的。（因为进程切换需要虚拟内存空间的切换，而线程可以共享进程资源，因此上下文切换的开销小。）</p>
<p>系统开销：进程的上下文切换开销大，而线程的上下文切换开销小。</p>
<p>地址空间：进程间相互独立，进程内的线程共享资源，并且对其他进程的线程不可见。</p>
<p>通信：进程间通信通过同步和互斥保证数据的一致性，线程可以直接读写数据。</p>
<h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>并发：一个cpu处理多个线程；<br>并行：多个cpu，每个cpu处理一个线程。</p>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>IPC(Inter Process Communication)：进程间通信。</p>
<ul>
<li><p>共享内存</p>
<p>  多个进程可以直接在内核专门预留一块内存空间读写，是最快的IPC形式。</p>
<p>  需要同步机制（信号量）达到进程间的同步及互斥。</p>
<ul>
<li>信号量<ul>
<li>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</li>
<li>进程获得共享资源需要进行的操作：1、创建一个信号量，初始值为0或1；2、等待一个信号量：该操作测试信号量的值，如果小于0，就阻塞，也称为P操作；3、挂出一个信号量：该操作将信号量的值加1，也称为V操作。</li>
<li>信号量的操作都是原子的（PV原语，或wait、signal），是在内核中实现的。</li>
<li>信号量和互斥量之间的区别：互斥量用于线程的互斥，信号量用于线程的同步。</li>
</ul>
</li>
</ul>
</li>
<li><p>管道</p>
<p>  半双工通信方式，双方通信需要建立两个管道；</p>
<p>  是一个独立的文件系统，只存在在内存中；</p>
<p>  本质是一个内核缓冲区，可以认为是一个循环队列。进程以先进先出的方式从缓冲区存取数据，一端进程顺序写到队尾，一端进程从队头开始读数据，且每个数据只能被读一次；</p>
<p>  只能用于亲缘进程之间的通信。（非亲缘进程可以通过有名管道通信） </p>
</li>
<li><p>消息队列 </p>
<p>  消息队列是以消息（每个消息都被认为是一个管道，接收进程可以独立地接收含有不同管道的数据结构）为单位的链表，存放在内存中并由消息队列标识符标识，能提供不同进程间的全双工通信。</p>
<ul>
<li>消息队列 &amp; 管道 对比：<ul>
<li>管道是跟随进程的，进程结束之后，管道随之销毁；消息队列是跟随内核的，进程结束之后，消息队列还会存在，只有在操作系统关机之后才会销毁；</li>
<li>管道是文件，存储在磁盘上，消息队列是数据结构，存储在内存上，因此消息队列的性能比管道更高；</li>
<li>管道是流式存储，消息队列是数据块式存储。</li>
</ul>
</li>
</ul>
</li>
<li><p>信号</p>
<p>  信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p>
<p>  SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。</p>
</li>
<li><p>socket</p>
<p>  这种通信方式可以实现跨机器的进程通信。</p>
<p>  socket是对TCP/IP协议簇的接口抽象。</p>
<ul>
<li>socket通信的建立过程：<ul>
<li>服务端：<ol>
<li>服务器系统调用socket创建一个套接字；</li>
<li>服务器进程调用<code>bind</code>方法给套接字命名，并等待客户端连接到这个套接字；</li>
<li>系统调用<code>listen</code>来创建一个队列并将其用于存放来自客户的进入连接；</li>
<li>服务器通过系统调用<code>accept</code>来接受客户的连接，并创建新的套接字用于特定客户端的连接。</li>
</ol>
</li>
<li>客户端：<ol>
<li>客户端系统调用socket创建一个未命名套接字;</li>
<li>然后将服务器创建的命名套接字作为地址，调用<code>connect</code>与服务器进行连接；</li>
<li>建立连接后，就可以用套接字进行数据双向通信。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="同步-amp-互斥"><a href="#同步-amp-互斥" class="headerlink" title="同步 &amp; 互斥"></a>同步 &amp; 互斥</h3><p><em><strong>临界资源</strong></em></p>
<p>一次仅允许一个进程使用的资源称为临界资源。</p>
<p><em><strong>临界区</strong></em></p>
<p>访问临界资源的代码块称为临界区。</p>
<p><em><strong>互斥</strong></em></p>
<p>互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>
<p><em><strong>同步</strong></em></p>
<p>同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</p>
<p><em><strong>同步机制的四个原则</strong></em></p>
<p>同步机制的四个原则：空闲让进、忙则等待、有限等待、让权等待。</p>
<p><em><strong>实现临界区互斥的方法</strong></em></p>
<p>软件方法：peterson算法</p>
<p>硬件方法：中断屏蔽、硬件指令</p>
<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><p><em><strong>生产者-消费者问题</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 临界区互斥信号量</span><br>semaphore empty = n; <span class="hljs-comment">// 空闲缓冲区</span><br>semaphore full = <span class="hljs-number">0</span>; <span class="hljs-comment">// 缓冲区初始化为空</span><br>Producer() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        data = produce(); <span class="hljs-comment">// 生产数据</span><br>        P(empty); <span class="hljs-comment">// 要用一个empty，p一下</span><br>        P(mutex); <span class="hljs-comment">// 进入临界区，互斥夹紧</span><br>        buffer.add(data); <span class="hljs-comment">// 将数据放到缓冲区</span><br>        V(mutex); <span class="hljs-comment">// 离开临界区，释放信号量，互斥夹紧</span><br>        V(full); <span class="hljs-comment">// 提供了一个full，v一下</span><br>    &#125;<br>&#125;<br>Consumer() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        P(full); <span class="hljs-comment">// 用full，p一下</span><br>        P(mutex); <span class="hljs-comment">// 进入临界区</span><br>        data = buffer.remove(); <span class="hljs-comment">// 消费一个data</span><br>        V(mutex); <span class="hljs-comment">// 离开临界区，释放信号量</span><br>        V(empty); <span class="hljs-comment">// 提供了一个empty，v一下</span><br>        consume(data); <span class="hljs-comment">// 消费数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程是共享资源抽象出的一组数据结构及在该数据结构是那个实施操作的一组过程所组成的资源管理程序。</p>
<p>管程包含的要素：</p>
<ol>
<li>管程的名称</li>
<li>内部的数据结构</li>
<li>对数据结构进行操作的一组过程（函数）</li>
<li>对内部共享数据的初始化操作</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">monitor Demo &#123;<br>    struct S &#123;<br>        ... // 共享数据结构<br>    &#125;<br>    conditon x; // 定义一个条件变量x<br>    init_code() &#123;<br>        ... // 对共享数据进行初始化<br>    &#125;<br>    take_away() &#123;<br>        if (S &lt;= 0) x.wait(); // 资源不够，在条件变量x上进行阻塞<br>        ... // 资源充足，分配资源，做一系列相应处理<br>    &#125;<br>    give_back() &#123;<br>        ... // 归还资源，做一系列相应处理<br>        if (有进程在等待) x.signal; //唤醒一个阻塞进程<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><em><strong>死锁产生的原因</strong></em></p>
<p>资源竞争和程序执行顺序不当</p>
<p><em><strong>死锁产生的必要条件</strong></em></p>
<ol>
<li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li>
<li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li>
<li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li>
<li>循环等待条件：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li>
</ol>
<p><em><strong>死锁的处理策略</strong></em></p>
<ol>
<li>死锁预防<ol>
<li>破坏互斥条件：一般不会破坏互斥的条件，但可以尽量做到尽可能少的进程可以请求资源。</li>
<li>破坏保持和等待条件：让进程在运行前一次申请完它需要的全部资源，会造成“饥饿”。</li>
<li>破坏不可抢占条件：cpu的中断等，</li>
<li>破坏循环等待条件：顺序资源分配法，给资源分配编号，每次申请比之前编号大的资源。</li>
</ol>
</li>
<li>死锁避免<ol>
<li>银行家算法</li>
</ol>
</li>
<li>死锁检测和解除<ol>
<li>检测方法：根据死锁定理，如果资源分配图可以被完全简化，说明不存在死锁，反之，则会死锁。</li>
<li>死锁解除的方法：资源剥夺；撤销进程；进程回退。</li>
</ol>
</li>
</ol>
<p><em><strong>银行家算法</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 进程集合</span><br><span class="hljs-keyword">static</span> HashSet&lt;Integer&gt; processSet;<br><span class="hljs-comment">// 当前可用资源，m代表资源总类，available[j] 代表第j类资源可用的数量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] available;<br><span class="hljs-comment">// 已分配资源, allocation[i][j] 代表进程i已经分配到的j资源的数量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] allocation;<br><span class="hljs-comment">// 资源最大请求数，need[i][j]代表进程i对j资源的最大请求数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] need;<br><span class="hljs-comment">// 资源总类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 银行家算法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i 进程</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> j 资源类别</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k 进程申请资源数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Banker</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (k &gt;= need[i][j]) &#123;<br>            <span class="hljs-comment">// 抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &gt; available[j]) &#123;<br>            <span class="hljs-comment">// 阻塞进程i</span><br>            wait(i);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            available[j] -= k;<br>            allocation[i][j] += k;<br>            need[i][j] -= k;<br>            <span class="hljs-keyword">if</span> (!isSafe()) &#123;<br>                available[j] += k;<br>                allocation[i][j] -= k;<br>                need[i][j] -= k;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 为进程i分配资源</span><br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 处理异常</span><br>        log.error(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true: 存在安全序列 false: 不存在安全序列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSafe</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">while</span> (processSet.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (Integer i: processSet) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (available[j] &gt;= need[i][j] - allocation[i][j]) &#123;<br>                    available[j] += allocation[i][j];<br>                    processSet.remove(i);<br>                    found = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (! found) <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="进程的状态模型"><a href="#进程的状态模型" class="headerlink" title="进程的状态模型"></a>进程的状态模型</h2><h3 id="进程的五种状态"><a href="#进程的五种状态" class="headerlink" title="进程的五种状态"></a>进程的五种状态</h3><p>进程的五种状态：运行态、就绪态、阻塞态、创建态、结束态。</p>
<ol>
<li>运行态：进程在处理机上运行；</li>
<li>就绪态：进程除了处理机外获取了其他一切资源，等待处理机被调度执行；</li>
<li>阻塞态：进程正在等待某一事件而释放处理机资源；</li>
<li>创建态：进程正在被创建；</li>
<li>结束态：进程正从系统中消失。</li>
</ol>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p><em><strong>操作系统创建一个进程的过程</strong></em></p>
<ol>
<li>为新进程分配一个唯一标识号，并申请一个空白的PCB；</li>
<li>为进程分配内存空间等资源（体现在PCB），资源不足，则进入阻塞状态；</li>
<li>初始化PCB，主要包括初始化标志信息、处理机状态信息、处理机控制信息、进程优先级等；</li>
<li>将进程加入到就绪队列里，等待执行。</li>
</ol>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p><em><strong>进程终止的原因</strong></em></p>
<ol>
<li>正常结束</li>
<li>异常结束：存储区越界、非法指令、运行超时、IO故障等；</li>
<li>外界干扰，如操作系统干预、父进程终止等。</li>
</ol>
<p><em><strong>进程终止的过程</strong></em></p>
<ol>
<li>根据标示号，检索PCB，读出进程状态；</li>
<li>如果进程处于运行态，终止运行，释放处理机资源；</li>
<li>若进程有子进程，终止子进程；</li>
<li>将进程拥有的全部资源归还给父进程或操作系统；</li>
<li>将该PCB从所在队列中清除。</li>
</ol>
<h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><p><em><strong>阻塞的执行过程</strong></em></p>
<ol>
<li>找到进程标识对应的PCB；</li>
<li>如果进程状态为运行态，保护现场，转换状态为阻塞态，停止运行；</li>
<li>将PCB插入事件的等待队列，释放处理机资源。</li>
</ol>
<p><em><strong>唤醒的执行过程</strong></em></p>
<ol>
<li>在事件的等待队列中找到相应进程的PCB；</li>
<li>将其从等待队列中移除，并置进程状态为就绪态；</li>
<li>把PCB插入就绪队列，等待调度程序调度。</li>
</ol>
<h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><p><em><strong>进程切换的执行过程</strong></em></p>
<ol>
<li>保存处理机上下文，包括程序计数器及一些寄存器；</li>
<li>更新PCB信息；</li>
<li>把PCB移到相应的队列（就绪队列、阻塞队列）</li>
<li>选择另一个进程执行，并更新其PCB；</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理机的上下文。</li>
</ol>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="影响调度程序性能的指标"><a href="#影响调度程序性能的指标" class="headerlink" title="影响调度程序性能的指标"></a>影响调度程序性能的指标</h3><ul>
<li>cpu使用率</li>
<li>等待时间</li>
<li>吞吐量：单位时间内完成进程的数量</li>
<li>响应时间：从提交作业到开始执行作业的时间</li>
<li>周转时间：从提交作业到完成作业的时间</li>
</ul>
<h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>算法简单，效率低，非抢占，长作业有利，有利于cpu繁忙型作业，不利于IO繁忙型作业。</p>
<h3 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h3><p>对长作业不利（饥饿），不能保证紧迫性作业及时处理。</p>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>优先级用于描述作业的紧迫程度。</p>
<p>分为抢占式和非抢占式。</p>
<p>IO型 &gt; CPU型；系统进程 &gt; 用户进程</p>
<h3 id="高响应比调度"><a href="#高响应比调度" class="headerlink" title="高响应比调度"></a>高响应比调度</h3><p>是先来先服务和短作业优先的平衡算法。</p>
<p><code>响应比 = （等待时间 + 要求服务时间）/ 要求服务时间</code></p>
<h3 id="时间片轮转调度"><a href="#时间片轮转调度" class="headerlink" title="时间片轮转调度"></a>时间片轮转调度</h3><h3 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h3><p>是对优先级和时间轮转的发展。</p>
<ol>
<li>设置多个就绪队列，赋予不同的优先级；</li>
<li>为就绪队列赋予时间片，优先级越高的就绪队列时间片越短；</li>
<li>新进程进入内存后，放到最高优先级的队列，按先来先服务等待调度，执行时间为分配的时间片时间；如果没有执行完就放到第二优先级的队列的队尾；</li>
<li>仅当第一优先级为空的时候，再来调度第二优先级队列里的进程。</li>
</ol>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><p><em><strong>程序装入内存要经过哪几步？</strong></em></p>
<ol>
<li>编译：由编译器将用户源代码编译成若干目标块；</li>
<li>链接：由链接程序将编译后的形成的一组目标块及所需的库函数链接在一起，形成一个完整的装入模块；</li>
<li>装入：由装入程序将装入模块装入内存运行。</li>
</ol>
<p><em><strong>程序的链接有哪几种方式？</strong></em></p>
<ol>
<li>静态链接：程序在运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。</li>
<li>装入时动态链接：装入内存时，边装入边链接。</li>
<li>运行时动态链接：程序执行中需要该模块时才进行链接。</li>
</ol>
<p><em><strong>程序的装入有哪几种方式？</strong></em></p>
<ol>
<li>绝对装入：逻辑地址和实际内存地址相同，直接把程序装入内存某个位置，只适用于单道程序环境。</li>
<li>静态重定位装入：将作业一次性装入内存，装入时对程序的指令和数据的修改，相对于起始位置进行重定位。</li>
<li>动态重定位装入：程序执行时，再把相对地址转为绝对地址。</li>
</ol>
<p><em><strong>覆盖 &amp; 交换</strong></em></p>
<p>覆盖和交换是多道程序下扩充内存的两种方法。</p>
<p>覆盖用在同一程序和进程中，交换技术用在不同进程之间。</p>
<p><em><strong>覆盖</strong></em></p>
<p>把用户空间分成一个固定区和若干个覆盖区，将经常活跃的部分放到固定区，将即将要访问的段放到覆盖区，其他段放在外存，在需要调用前，系统将其从外存调到覆盖区，替换覆盖区原有的段。</p>
<p><em><strong>交换</strong></em></p>
<p>把等待状态的程序从内存移到辅存，即<code>唤出</code>；把准备好竞争cpu资源的程序从辅存移到内存，即<code>唤入</code>。</p>
<blockquote>
<p>区别于换页，交换是针对等待资源的程序而言的。</p>
</blockquote>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="按需分页"><a href="#按需分页" class="headerlink" title="按需分页"></a>按需分页</h3><p>在操作系统中，进程是以页为单位加载到内存中的，按需分页是一种虚拟内存的管理方式。</p>
<p>当操作系统需要访问的页未在内存中，会出现<code>缺页异常</code>。操作系统才会将磁盘页面复制到内存中。</p>
<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p><em><strong>连续的分配管理方式</strong></em></p>
<ol>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li>动态分区分配</li>
</ol>
<p><em><strong>非连续的分配管理方式</strong></em></p>
<ol>
<li>基于分页存储管理方式</li>
<li>基于分段存储管理方式 </li>
<li>段页式管理方式</li>
</ol>
<h3 id="空闲内存管理方式"><a href="#空闲内存管理方式" class="headerlink" title="空闲内存管理方式"></a>空闲内存管理方式</h3><p>操作系统在动态分配内存时，需要对空闲内存进行管理。一般采用了两种方式：位图和空闲链表。</p>
<p><em><strong>位图</strong></em></p>
<p>用1位（0/1）来表示一块内存区域的使用情况，以此来跟踪内存的使用情况。</p>
<p>位图的缺点是，很难通过位图来找到一块连续的确定大小的内存空间。</p>
<p><em><strong>空闲链表</strong></em></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是一种基于非连续分配管理方式的内存分配的机制。</p>
<p><em><strong>虚拟内存的实现方式</strong></em></p>
<p>虚拟内存在软件层面使用的是非连续的分配管理方式。</p>
<p>需要的硬件方面的支持：</p>
<ol>
<li>一定容量的内存和外存；</li>
<li>页表机制（或段表机制），作为主要的数据结构；</li>
<li>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断；</li>
<li>地址变换机构，逻辑地址到物理地址的变换。</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ol>
<li><p>最佳置换（OPT）算法</p>
<p>当调入新的一页而必须预先置换某个老页时，所选择的老页应是将来不再被使用，或者是在最远的将来才被访问。</p>
</li>
<li><p>先进先出（FIFO）算法：</p>
<p> 优先淘汰最早进入内存的页。</p>
<p> 但是会出现Belady异常（分配的物理块增大但页故障数不减反增）。</p>
<p> 效率不高，在按线性顺序访问地址空间时才是理想的。</p>
</li>
<li><p>最近最久未使用（LRU）算法</p>
<p> 该算法认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。</p>
<p> LRU算法需要为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰时选择页面字段最大的值进行淘汰。</p>
<p> LRU性能较好，但是需要寄存器和栈的硬件支持。</p>
<p> LRU是堆栈类的算法，而FIFO是基于队列实现的。</p>
</li>
<li><p>时钟（CLOCK）置换算法</p>
</li>
</ol>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><ol>
<li>固定分配局部置换：为每个进程分配一定数目的物理块，整个运行期不改变。缺页时候，从内存中唤出一页，唤进一页。</li>
<li>可变分配全局置换：为每个进程分配一定数目的物理块，操作系统维护一个空闲物理块的队列，缺页时，从队列中出队空闲的物理块，并进行换页。</li>
<li>可变分配局部置换：为每个进程分配一定数目的物理块，缺页时，从该进程的内存中换页，不会影响其他进程的运行。</li>
</ol>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>刚刚唤出的页马上又要唤入内存，刚刚唤入的页马上又要唤出，这种频繁的页面调度就称为抖动。</p>
<p>其原因在于频繁访问的页面数目多于可用的物理页数目。</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件在磁盘，访问磁盘的速度远小于内存。 </p>
<h2 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h2><p>提高文件系统性能的方法：</p>
<ol>
<li><p>高速缓存</p>
<p> 最常见的减少访问磁盘次数的技术：缓冲区高速缓存(buffer cache)。</p>
<p> 高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</p>
</li>
<li><p>块提前读：直接将接下来可能用到的块先写到高速缓存中。</p>
</li>
<li><p>减少磁盘臂运动：把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数。</p>
</li>
<li><p>磁盘碎片整理</p>
</li>
</ol>
<h2 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h2><p><em><strong>影响磁盘快速读写的因素</strong></em></p>
<ol>
<li>寻道时间：活动头磁盘在读写信息前，将磁头移动到指定磁道所需要的时间。</li>
<li>延迟时间：磁头定位到某一磁道的扇区（块号）所需要的时间。</li>
<li>传输时间：从磁盘读写数据所需要的时间。</li>
</ol>
<p><em><strong>调度算法</strong></em></p>
<ol>
<li>先来先服务（FCFS）算法</li>
<li>最短寻找时间优先算法</li>
<li>扫描（电梯调度）算法</li>
<li>循环扫描算法</li>
</ol>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h2><ol>
<li>程序直接控制方式：cpu要不断检测外设状态，直到确定已经把数据读到寄存器中。cpu使用率低。</li>
<li>中断驱动方式：解决cpu等待io的问题，但数据从存储器到IO都要走cpu。</li>
<li>DMA方式：数据开始和结束传输的时候走cpu，其他时间都是dma芯片来管理控制数据的传输的。</li>
<li>通道控制方式：在dma技术之上发展的，把对一个数据块的读写单位扩展为对一个组数据块的读写，同时实现cpu、通道、io的并行操作，进一步提高系统的资源利用率。</li>
</ol>
<h3 id="DMA-直接内存访问"><a href="#DMA-直接内存访问" class="headerlink" title="DMA(直接内存访问)"></a>DMA(直接内存访问)</h3><p>CPU授权IO模块权限跳过CPU直接读写内存，整个过程由DMA的芯片管理，这样可以缓解总线上的拥塞。</p>
<p>DMA的特点：</p>
<ol>
<li>数据传送以数据块为基本单位</li>
<li>数据从设备直接送入主存，或者从主存直接输出到设备上</li>
<li>仅在传输数据的开始和结束的时候需要cpu的介入，而整个传输的过程只需要dma的芯片参与。</li>
</ol>
<h3 id="中断处理的过程"><a href="#中断处理的过程" class="headerlink" title="中断处理的过程"></a>中断处理的过程</h3><ol>
<li>关中断。CPU关闭中断，即不再接受其他外部中断请求。</li>
<li>保存断点。将发生中断处的指令地址压入堆栈，以使中断处理完后能正确的返回（注意，有可能保存中断处的指令地址，也有可能是中断处的指令的下一条指令的地址，具体情况视中断的类型）。</li>
<li>识别中断源。CPU识别中断的来源，确定中断类型号，从而找到相应的中断处理程序的入口地址</li>
<li>保存现场（以上三步一般由处理中断的硬件电路完成）。将发生中断处的有关寄存器（中断服务程序要使用的寄存器）以及标志寄存器的内容压入堆栈。</li>
<li>执行中断服务程序。转到中断服务程序入口开始执行，可在适时时刻重新开放中断，以便允许响应较高优先级的外部中断。</li>
<li>恢复现场并返回（后三步一般软件，即中断处理程序完成）。把“保护现场”时压入堆栈的信息弹回寄存器，然后执行中断返回指令，从而返回主程序继续运行。（IRET指令，无操作数，从栈顶弹出3个字，分别送入IP、CS和FLAGS寄存器）</li>
</ol>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>计算机程序，用来控制和操作连接到计算机的设备。</p>
<p>驱动程序提供了与硬件交互的软件接口，使操作系统或计算机程序可以直接访问硬件，而不需要了解硬件的具体构造。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/">技术沉淀</a>
                    
                      <a class="hover-with-bg" href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
                    
                  </div>
                
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/16/tech/CSBase/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据库知识点梳理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/12/tech/CSBase/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">
                        <span class="hidden-mobile">计算机网络知识点梳理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
